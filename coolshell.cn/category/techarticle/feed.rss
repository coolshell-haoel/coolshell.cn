<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>技术读物 | 酷 壳 - CoolShell</title>
	<atom:link href="https://coolshell.cn/category/techarticle/feed" rel="self" type="application/rss+xml" />
	<link>https://coolshell.cn</link>
	<description>享受编程和技术所带来的快乐 - Coding Your Ambition</description>
	<lastBuildDate>Sun, 12 Sep 2021 02:34:06 +0000</lastBuildDate>
	<language>zh-CN</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=6.2</generator>
	<item>
		<title>如何做一个有质量的技术分享</title>
		<link>https://coolshell.cn/articles/21589.html</link>
					<comments>https://coolshell.cn/articles/21589.html#comments</comments>
		
		<dc:creator><![CDATA[陈皓]]></dc:creator>
		<pubDate>Tue, 13 Jul 2021 05:00:46 +0000</pubDate>
				<category><![CDATA[技术读物]]></category>
		<category><![CDATA[杂项资源]]></category>
		<category><![CDATA[Knowledge Sharing]]></category>
		<category><![CDATA[Programmer]]></category>
		<category><![CDATA[程序员]]></category>
		<guid isPermaLink="false">https://coolshell.cn/?p=21589</guid>

					<description><![CDATA[<p>分享信息并不难，大多数人都能做到，就算是不善言谈性格内向的技术人员，通过博客或社交媒体，或是不正式的交流，他们都能或多或少的做到。但是如果你想要做一个有质量有高...</p>
<p class="read-more"><a class="btn btn-default" href="https://coolshell.cn/articles/21589.html"> Read More<span class="screen-reader-text">  Read More</span></a></p>
The post <a href="https://coolshell.cn/articles/21589.html">如何做一个有质量的技术分享</a> first appeared on <a href="https://coolshell.cn">酷 壳 - CoolShell</a>.]]></description>
										<content:encoded><![CDATA[<p><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3415450859608158"
     crossorigin="anonymous"></script><img decoding="async" loading="lazy" class="alignright size-medium" src="https://coolshell.cn/wp-content/uploads/2021/07/knowledge_sharing-300x169.jpeg" alt="" width="300" height="169" />分享信息并不难，大多数人都能做到，就算是不善言谈性格内向的技术人员，通过博客或社交媒体，或是不正式的交流，他们都能或多或少的做到。但是如果你想要做一个有质量有高度的分享，这个就难了，所谓的有质量和有高度，我心里面的定义有两点：1）分享内容的保鲜期是很长的，2）会被大范围的传递。我们团队内每周都在做技术分享，虽然分享的主题都很有价值，但是分享的质量参差不齐，所以，想写下这篇文章 。供大家参考。</p>
<p>首先，我们先扪心自问一下，我们自己觉得读到的好的技术文章是什么？我不知道大家的是什么，我个人认为的好的文章是下面这样的：</p>
<ul>
<li><strong>把复杂的问题讲解的很简单也很清楚</strong>。比如我高中时期读到这本1978年出版的《<a href="https://book.douban.com/subject/1441922/" target="_blank" rel="noopener">从一到无穷大</a>》，用各种简单通俗通懂的话把各种复杂的科学知识讲的清清楚楚。还有看过的几本很好的书，有一本是《<a href="https://book.douban.com/subject/5273955/" target="_blank" rel="noopener">Windows程序设计</a>》，从一个hello world的程序开始一步一步教你Windows下的原生态编程。</li>
<li><strong>有各种各样的推导和方案的比较，让你知其然知其所以然</strong>。有了不同方案的比较，才可能让人有全面的认识。这个方面的经典作著是《<a href="https://book.douban.com/subject/5387403/" target="_blank" rel="noopener">Effective C++</a>》。</li>
<li><strong>原理、为什么、思路、方法论会让人一通百通</strong>。这里面最经典的恐怕就是《<a href="https://book.douban.com/subject/5387403/" target="_blank" rel="noopener">十万个为什么</a>》了，在计算机方面也有几本经典书，有《<a href="https://book.douban.com/subject/1467587/" target="_blank" rel="noopener">Unix编程艺术</a>》、《<a href="https://book.douban.com/subject/1052241/" target="_blank" rel="noopener">设计模式</a>》、《<a href="https://book.douban.com/subject/1230413/" target="_blank" rel="noopener">深入理解计算机系统</a>》等书，以及《<a href="http://www.kegel.com/c10k.html" target="_blank" rel="noopener">The C10K Problem</a>》等很多技术论文。</li>
</ul>
<p>其实，从教科书，到专业书，再到论文，都有上面这些不错的特质。<span id="more-21589"></span></p>
<p>所以，如果你想做一个好的技术分享的话，下面是我总结出来的方法，供你参考。</p>
<ul>
<li><strong>先描述好一个问题</strong>。这样能够听众带入进来，如果这个问题是他们感同身受的，那是最好了。千万不要一上来就说What，或是直接冲进答案里。这样的分享是在灌输和填鸭。把Why说清楚。没有Why，直接谈What的技术分享，通常来说价值不大。</li>
<li><strong>How比What重要</strong>。在讲How的时候，也就是如何解这个问题。
<ul>
<li>先要把问题模型说清楚，有了问题模型这个框框后，方案才有意义。</li>
<li>然后要有不同技术的比较。有了比较后，听众才会更相信你。</li>
<li>直接上What的技术细节，其实没有太大意义。</li>
</ul>
</li>
<li><strong>一定要有Best Practice或方法论总结</strong>，否则上不了档次的。也就是分享中大家可以得到的重要收获。</li>
</ul>
<p>说明了这个模型就是：<strong>问题 &#8211;&gt; 方案 &#8211;&gt; 总结。这其中是有一定的心理学模型的，具体表现如下：</strong></p>
<ul>
<li>用问题来吸引受众，带着受众来一起思考</li>
<li>用问题模型来框住受众的思考范围，让受众聚焦</li>
<li>给出几种不同的解决方案，比较他们的优缺点，让受众有一种解决问题的参与感。</li>
<li>最后，给出最佳实践，方法论或套路，因为有了前三步的铺垫，受众欣然接受。</li>
<li>整个过程会让受众有强烈的成长感和收获感。</li>
</ul>
<p>这里有几个示例，也是我在我司 MegaEase 内部的技术分享，供你参考（<a href="https://www.youtube.com/user/chenhaox/videhttps://www.youtube.com/channel/UCJhxX8SXcYdNWc6QMbWKs7Aos" target="_blank" rel="noopener">我个人的YouTube频道</a>）</p>
<p>技术分享：<a href="https://youtu.be/qB40kqhTyYM" target="_blank" rel="noopener">Prometheus是怎么存储数据的</a>（Youtube）</p>
<p><iframe loading="lazy" title="技术分享：Prometheus是怎么存储数据的（陈皓）" width="640" height="360" src="https://www.youtube.com/embed/qB40kqhTyYM?feature=oembed" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></p>
<p>技术分享：<a href="https://www.youtube.com/watch?v=VnbC5RG1fEo" target="_blank" rel="noopener">Distributed Lock Manager</a>（Youtube）</p>
<p><iframe loading="lazy" title="技术分享：Distributed Lock Manager（陈皓）" width="640" height="360" src="https://www.youtube.com/embed/VnbC5RG1fEo?feature=oembed" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></p>
<p>下面是我写在我们公司内的Knowledge Sharing中的Best Practice，供参考</p>
<h2>Sharing Guideline</h2>
<p>Please follow the following sharing protocols</p>
<h3><a id="user-content-understand-sharing" class="anchor" href="https://github.com/megaease/team/tree/master/sharing#understand-sharing" aria-hidden="true"></a>Understand Sharing</h3>
<ul>
<li>Sharing is the hard way to learn knowledge. The presenter gains the biggest advantages. not audience. 分享是学习知识的最难的方式。分享者获得的好处最最多的，而不是观众。</li>
<li>Sharing can open the knowledge door for the audience, but you have to walk to knowledge by yourself. 分享可以为听众打开知识的大门，但你能不能获得知识还要靠你自己。</li>
</ul>
<h3><a id="user-content-best-practices" class="anchor" href="https://github.com/megaease/team/tree/master/sharing#best-practices" aria-hidden="true"></a>Best Practices</h3>
<p>To perform a great sharing, please follow the below practices.</p>
<ul>
<li>Do not share a big topic, a small topic is better. A big topic could make the audience lose focus. Remember, <a href="https://en.wikipedia.org/wiki/Minimalism#Minimalist_design_and_architecture" rel="nofollow">Less is More!</a></li>
<li>Sharing time less than 60 mins is the best.</li>
<li>English language for slides is preferred.</li>
<li>While prepare the sharing contents, it&#8217;s better to discuss with the senior people to help you to see the whole picture, understand the good side and bad side, know what you don&#8217;t know &#8230; etc.</li>
<li>Strong Recommend Materials Outlines
<ul>
<li>What&#8217;s the Problem?</li>
<li>How to Solve the Problem?</li>
<li>The Best Solution or Practice.</li>
<li>The Mechanism, Key Techniques, and Source Code</li>
<li>Pros/Cons</li>
<li>References (Further reading)</li>
</ul>
</li>
</ul>
<blockquote><p>For example, if you want to sharing a topic about Docker. the following outlines would be good one:</p>
<ul>
<li>What&#8217;s the major problems need to solve. (Provision, Environment, Isolation etc.)</li>
<li>The Alternative solutions. (Puppet/Chef/Ansible, VM, LXC etc.)</li>
<li>The Best Solution &#8211; Docker. Why?</li>
<li>Docker&#8217;s key techniques &#8211; image, cgroup, union fs, namespace&#8230;</li>
<li>Docker&#8217;s Pros/Cons</li>
<li>Further reading list.</li>
</ul>
</blockquote>
<p><img decoding="async" loading="lazy" class="aligncenter size-full" src="https://coolshell.cn/wp-content/uploads/2021/07/截屏2021-07-13-12.53.33.png" alt="" width="573" height="173" /></p>
<p>（全文完）<!--



<p align="center"><a href= target=_blank><img decoding="async" src=""></a></p>





<p align="center"><img decoding="async" src="https://coolshell.cn/wp-content/uploads/2020/03/coolshell.weixin.jpg"> <img decoding="async" loading="lazy" src="https://coolshell.cn/wp-content/uploads/2020/03/coolshell.mini_.jpg" width="300" height="300"> <br />关注CoolShell微信公众账号和微信小程序</p>

 

--></p>
<div style="margin-top: 15px; font-size: 16px;color: #cc0000;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 &#8211; CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>

<div class="wp_rp_wrap  wp_rp_vertical_m" id="wp_rp_first"><div class="wp_rp_content"><h3 class="related_post_title">相关文章</h3><ul class="related_post wp_rp"><li ><a href="https://coolshell.cn/articles/22298.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2022/10/communication-150x150.png" alt="聊聊团队协同和协同工具" width="150" height="150" /></a><a href="https://coolshell.cn/articles/22298.html" class="wp_rp_title">聊聊团队协同和协同工具</a></li><li ><a href="https://coolshell.cn/articles/22173.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2022/02/http_method-150x150.png" alt="“一把梭：REST API 全用 POST”" width="150" height="150" /></a><a href="https://coolshell.cn/articles/22173.html" class="wp_rp_title">“一把梭：REST API 全用 POST”</a></li><li ><a href="https://coolshell.cn/articles/22157.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2022/02/monitoring-150x150.jpeg" alt="谈谈公司对员工的监控" width="150" height="150" /></a><a href="https://coolshell.cn/articles/22157.html" class="wp_rp_title">谈谈公司对员工的监控</a></li><li ><a href="https://coolshell.cn/articles/20977.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2020/08/programmer.01-e1596792460687-150x150.png" alt="程序员如何把控自己的职业" width="150" height="150" /></a><a href="https://coolshell.cn/articles/20977.html" class="wp_rp_title">程序员如何把控自己的职业</a></li><li ><a href="https://coolshell.cn/articles/20765.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2020/01/remote-150x150.jpg" alt="MegaEase的远程工作文化" width="150" height="150" /></a><a href="https://coolshell.cn/articles/20765.html" class="wp_rp_title">MegaEase的远程工作文化</a></li><li ><a href="https://coolshell.cn/articles/20276.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2019/12/open-your-creative-mind-150x150.jpg" alt="别让自己“墙”了自己" width="150" height="150" /></a><a href="https://coolshell.cn/articles/20276.html" class="wp_rp_title">别让自己“墙”了自己</a></li></ul></div></div>The post <a href="https://coolshell.cn/articles/21589.html">如何做一个有质量的技术分享</a> first appeared on <a href="https://coolshell.cn">酷 壳 - CoolShell</a>.]]></content:encoded>
					
					<wfw:commentRss>https://coolshell.cn/articles/21589.html/feed</wfw:commentRss>
			<slash:comments>28</slash:comments>
		
		
			</item>
		<item>
		<title>Unix 50 年：Ken Thompson 的密码</title>
		<link>https://coolshell.cn/articles/19996.html</link>
					<comments>https://coolshell.cn/articles/19996.html#comments</comments>
		
		<dc:creator><![CDATA[陈皓]]></dc:creator>
		<pubDate>Sun, 03 Nov 2019 06:12:54 +0000</pubDate>
				<category><![CDATA[Unix/Linux]]></category>
		<category><![CDATA[技术读物]]></category>
		<category><![CDATA[操作系统]]></category>
		<category><![CDATA[杂项资源]]></category>
		<category><![CDATA[BSD]]></category>
		<category><![CDATA[Dennis Ritchie]]></category>
		<category><![CDATA[Ken Thompson]]></category>
		<category><![CDATA[Unix]]></category>
		<guid isPermaLink="false">https://coolshell.cn/?p=19996</guid>

					<description><![CDATA[<p>50年前，除了Apollo上天之外，还有一个大事的发生，就是Unix操作系统的诞生，若干年前我写过《Unix的传奇，上篇，下篇》，Unix是我入行前十年伴我成长...</p>
<p class="read-more"><a class="btn btn-default" href="https://coolshell.cn/articles/19996.html"> Read More<span class="screen-reader-text">  Read More</span></a></p>
The post <a href="https://coolshell.cn/articles/19996.html">Unix 50 年：Ken Thompson 的密码</a> first appeared on <a href="https://coolshell.cn">酷 壳 - CoolShell</a>.]]></description>
										<content:encoded><![CDATA[<p><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3415450859608158"
     crossorigin="anonymous"></script><img decoding="async" loading="lazy" class="alignright size-medium" src="https://coolshell.cn/wp-content/uploads/2019/11/ken.dennis-300x186.jpeg" alt="" width="300" height="186" />50年前，除了Apollo上天之外，还有一个大事的发生，就是Unix操作系统的诞生，若干年前我写过《Unix的传奇，<a href="https://coolshell.cn/articles/2322.html" target="_blank" rel="noopener noreferrer">上篇</a>，<a href="https://coolshell.cn/articles/2324.html" target="_blank" rel="noopener noreferrer">下篇</a>》，Unix是我入行前十年伴我成长的操作系统，虽然现在Linux早已接过了Unix的时代交接棒，但是，Unix文化对我个人的技术观影响是非常大的（注：《<a href="https://book.douban.com/subject/1467587/" target="_blank" rel="noopener noreferrer">Unix编程艺术</a>》是一本对影响我很深的书），而对于 <a href="https://en.wikipedia.org/wiki/Ken_Thompson">Ken Thompson</a> 和 <a href="https://en.wikipedia.org/wiki/Dennis_Ritchie" target="_blank" rel="noopener noreferrer">Dennis Ritchie</a> 这两位 Unix 的缔造者，也是计算机圈中的神一般的人物。今天，Dennis已经去逝，Ken在Google里跟 Rob Pike和 Robert Griesemer 这两位大神在开发Go语言。</p>
<p>P.S. 今年，我一直想写篇Unix 50周年纪念的文章，但一直无从下手，因为不想写过大的命题，如果能写个轶事最好不过。正好过完国庆节，技术圈里有个“热搜”——Ken Thompson的密码。但一直没有时间，所以拖到今天才写下来。</p>
<p>正文开始，2014年，有个叫Leah Neukirchen的程序员（<a href="https://leahneukirchen.org/blog/" target="_blank" rel="noopener noreferrer">blog</a>）在 BSD 3 的源代码中的 <code><a href="https://leahneukirchen.org/blog/archive/2019/10/ken-thompson-s-unix-password.html" target="_blank" rel="noopener noreferrer">/etc/passwd</a></code> 看到了早年Unix黑客们的被 hash了的密码，该文件如下所示：</p>
<p><span id="more-19996"></span></p>
<pre>root:OVCPatZ8RFmFY:0:10:Ernie Co-vax,4156427925:/:
daemon:*:1:1:The devil himself:/:
bill:.2xvLVqGHJm8M:8:10:&amp; Joy,4156424948:/usr/bill:/bin/csh
ozalp:m5syt3.lB5LAE:40:10:&amp; Babaoglu,4156423806:/usr/ozalp:/bin/csh
sklower:8PYh/dUBQT9Ss:2:10:Keith &amp;,4156424972:/usr/staff/sklower:/bin/csh
kridle:4BkcEieEtjWXI:3:10:Bob &amp;,4156426744:/usr/staff/kridle:/bin/csh
kurt:olqH1vDqH38aw:4:10:&amp; Shoens,4156420572:/usr/staff/kurt:/bin/csh
schmidt:FH83PFo4z55cU:7:10:Eric &amp;,4156424951:/usr/staff/schmidt:/bin/csh
hpk:9ycwM8mmmcp4Q:9:10:Howard Katseff,2019495337:/usr/staff/hpk:/bin/csh
tbl:cBWEbG59spEmM:10:10:Tom London,2019492006:/usr/staff/tbl:
jfr:X.ZNnZrciWauE:11:10:John Reiser:/usr/staff/jfr:
mark:Pb1AmSpsVPG0Y:12:10:&amp; Horton,4156428311:/usr/staff/mark:/bin/csh
dmr:gfVwhuAMF0Trw:42:10:Dennis Ritchie:/usr/staff/dmr:
ken:ZghOT0eRm4U9s:52:10:&amp; Thompson:/usr/staff/ken:
sif:IIVxQSvq1V9R2:53:10:Stuart Feldman:/usr/staff/sif:
scj:IL2bmGECQJgbk:60:10:Steve Johnson:/usr/staff/scj:
pjw:N33.MCNcTh5Qw:61:10:Peter J. Weinberger,2015827214:/usr/staff/pjw:/bin/csh
bwk:ymVglQZjbWYDE:62:10:Brian W. Kernighan,2015826021:/usr/staff/bwk:
uucp:P0CHBwE/mB51k:66:10:UNIX-to-UNIX Copy:/usr/spool/uucp:/usr/lib/uucp/uucico
srb:c8UdIntIZCUIA:68:10:Steve Bourne,2015825829:/usr/staff/srb:
finger::199:199:The &amp; Program:/usr/ucb:/usr/ucb/finger
who::199:199:The &amp; Program:/usr/ucb:/bin/who
w::199:199:The &amp; Program:/usr/ucb:/usr/ucb/w
mckusick:AAZk9Aj5/Ue0E:201:10:Kirk &amp;,4156424948:/usr/staff/mckusick:/bin/csh
peter:Nc3IkFJyW2u7E:202:10:&amp; Kessler,4156424948:/usr/staff/peter:/bin/csh
henry:lj1vXnxTAPnDc:203:10:Robert &amp;,4156424948:/usr/staff/henry:/bin/csh
jkf:9ULn5cWTc0b9E:209:10:John Foderaro,4156424972:/usr/staff/jkf:/bin/csh
fateman:E9i8fWghn1p/I:300:10:Richard &amp;,4156421879:/usr/staff/fateman:/bin/csh
fabry:d9B17PTU2RTlM:305:10:Bob &amp;,4156422714:/usr/staff/fabry:/bin/csh
network:9EZLtSYjeEABE:501:50:*:/usr/net/network:/usr/net/network/nsh
tty::504:50::/:/bin/tty我</pre>
<p>（注，以前Unix是一个服务器，所有人都用一个终端到服务器上进行操作，于是，这个服务上的 <code>/etc/passwd</code> 下保存着所有的人的登录密码，能让所有的人都能读到，为了不让别人猜到，这个文件中的密码保存（第二列）被做过哈希处理）</p>
<p>这位程序员一看，这些个用户不就是<a href="https://en.wikipedia.org/wiki/Dennis_Ritchie" target="_blank" rel="noopener noreferrer">Dennis Ritchie</a>, <a href="https://en.wikipedia.org/wiki/Ken_Thompson">Ken Thompson</a>, <a href="https://en.wikipedia.org/wiki/Brian_Kernighan" target="_blank" rel="noopener noreferrer">Brian W. Kernighan</a>, <a href="https://en.wikipedia.org/wiki/Stephen_R._Bourne" target="_blank" rel="noopener noreferrer">Steve Bourne</a>, <a href="https://en.wikipedia.org/wiki/Bill_Joy" target="_blank" rel="noopener noreferrer">Bill Joy</a> 这些神人的密码吗？！于是，他想看看这些人用什么样的密码。考虑到当时的加密算法用的是基于DES的 <a href="https://minnie.tuhs.org/cgi-bin/utree.pl?file=V7/usr/man/man3/crypt.3">crypt(3)</a> 算法（这个算法今天还在用，像Perl/PHP/Python/Ruby都提供<code>crypt()</code> 函数），而且当时的密码最长只支持8个长度，所以，感觉还是很容易暴力破解的。</p>
<p>一般来说，暴力破解的这种hash密码的工具主要是用<a href="https://hashcat.net/" target="_blank" rel="noopener noreferrer">hashcat</a> 或 <a href="https://www.openwall.com/john/" target="_blank" rel="noopener noreferrer">john</a> ，很快，Leah 破解了大多数人的密码，因为大多数都使用的是比较弱的密码，比如： <a href="https://en.wikipedia.org/wiki/Brian_Kernighan" target="_blank" rel="noopener noreferrer">Brian W. Kernighan</a> （<code>bwk</code>）使用了 <code>/.,/.,</code> 这样的密码，而 <a href="https://en.wikipedia.org/wiki/Dennis_Ritchie" target="_blank" rel="noopener noreferrer">Dennis Ritchie</a> （<code>dmr</code>）则使用了 <code>dmac</code> 这样的密码。然后，在破解到 Ken Thompson的密码时，搞不定了，花了好几天穷举完了所有的小写字母+数字都没有找到。</p>
<p>因为这个<code>crypt</code>的算法也是Ken Thompson 和 Robert Morris 写的，他们在40年前就发现，原来的hash算法太快了，这样很容易被暴力穷举，于是在第七版的Unix（1979年发布），他们把算法改成DES的算法，就是要让这个算法变慢。详细地说，用户密码被截断为八个字符，每个字符仅被压缩为7位。这形成56位DES密钥。然后，该密钥用于加密全零位块，然后再次使用相同的密钥对密文进行加密，依此类推，总共进行了25次DES加密。感觉跟区块链的“挖矿”有点像。<strong>在最早的Unix计算机上，这个算法需要花了整整一秒钟的时间来计算密码哈希</strong>。</p>
<p>这几十年来，计算机的计算速度根据摩尔定律至少double了20次，所以，DES算法已经很容被攻击了，然而，对于Ken Thompson的密码，在2014年还是很不容易被破解的，因为，<strong>如果要加上所有的大小写字符数字和其它特殊字符，那么，在2014年，就算用最快的GPU来穷举所有的8位长度的密码，也需要花上至少2年以上的时间</strong>。</p>
<p>在2019年10月份，在 <a href="https://www.tuhs.org/">The Unix Heritage Society</a> 这个社区中，<a href="https://inbox.vuxu.org/tuhs/6dceffe228804a76de1e12f18d1fc0dc@inventati.org/" target="_blank" rel="noopener noreferrer">这个事又被人问起来</a>，说以前有个人破解这些密码，不知道有没有全破解出来了？于是Leah看到了，就回应说，那个人是我，但是还是没干出来……于是好些人进来留言。</p>
<p>5天后，2019年10月08日，一个来自澳大利亚的程序员Nigel Williams说，<a href="https://inbox.vuxu.org/tuhs/CACCFpdx_6oeyNkgH_5jgfxbxWbZ6VtOXQNKOsonHPF2=747ZOw@mail.gmail.com/" target="_blank" rel="noopener noreferrer">Ken的密码我破解出来了</a>，哈希串<code>ZghOT0eRm4U9s</code> 明文是 <code>p/q2-q4!</code>（果然是有数字有特殊字符），小伙说，我在 AMD Radeon Vega 64 的 GPU上运行了 <code>hashcat</code> 这个命令，干了我 4天多，每秒钟的“配速”是930MH/s （每秒钟9亿3千万次hash运算）。然后，<a href="https://inbox.vuxu.org/tuhs/CAG=a+rj8VcXjS-ftaj8P2_duLFSUpmNgB4-dYwnTsY_8g5WdEA@mail.gmail.com/" target="_blank" rel="noopener noreferrer">Ken Thompson 也留言到 “恭喜”</a> ，这样，Ken 的密码在40年后被破解了……</p>
<p>马上，就有人问到，这个密码是不是国际象棋的走棋？嗯，很像中国象棋中的“车五进一”，“马三退一”，这个密码中的 <code>p</code> 代表 <code>pawn</code> 小兵，从 <code>q2</code> 的位置走到 <code>q4</code>，这个看来是国际象棋中的开局进兵——用来做登录密码，非常合适。而且，Ken Thompson 在 Unix中写下的一个国际象棋的程序 <a href="https://en.wikipedia.org/wiki/Belle_(chess_machine)" target="_blank" rel="noopener noreferrer">Belle</a>，在1978年首次参加<a href="https://en.wikipedia.org/wiki/North_American_Computer_Chess_Championship">计算机协会的北美计算机国际象棋锦标赛</a>时，它获得了第一个冠军头衔，其搜索深度为八层。之后又赢得了四次冠军。1983年，它也成为第一台获得国际象棋“大师”称号的计算机。所以，Ken用这个做密码相当make sense!</p>
<p style="text-align: center;"><img decoding="async" loading="lazy" class="aligncenter size-full" src="https://coolshell.cn/wp-content/uploads/2019/11/ken.chess_.jpg" alt="" width="600" height="800" />Ken在贝尔实验室调程序（图片来源：<a href="https://spectrum.ieee.org/tech-history/silicon-revolution/in-1983-this-bell-labs-computer-was-the-first-machine-to-become-a-chess-master" target="_blank" rel="noopener noreferrer">IEEE SPECTRUM</a>）</p>
<p>当然，还有一个人的密码是所有人里最难破解的，这个人就是<a href="https://en.wikipedia.org/wiki/Bill_Joy" target="_blank" rel="noopener noreferrer">Bill Joy</a>，他最初作为加州大学伯克利分校的研究生，在校期间着手改进Unix 内核，并管理BSD发行版。他最著名的贡献是ex和vi编辑器以及C shell。在Sun公司成立6个月后，他正式成为公司的联合创始人，他在Sun公司的推动了NFS，SPARC处理器，以及Java语言。他还是一个风险投资人员。</p>
<p>在Ken的密被破解后两周（2019年10月19日），有人号称已经破解了Bill的密码，他在<a href="https://minnie.tuhs.org/pipermail/tuhs/2019-October/019124.html" target="_blank" rel="noopener noreferrer">邮件组中这样写到</a>：</p>
<blockquote><p>一开始，我使用了大小写字符和数字，8位长度来破解所有的组合，花了我6天的时间，失败了。然后，我开始尝试只用小写字母和控制字符，结果在40分钟内就破解了。但是因为Bill现健在，所以，只要bill同意他才公布这个密码。</p></blockquote>
<p>在密码里存控制字符？这脑洞，Ctrl+C么？破解者还说，他在一个有三个结点的DELL 的HPC集群上完成这个工作，每个结点包括两个 Tesla V100 nVidia GPU 的显卡，一共30720个CUDA核…… 关于这个显卡多少钱，你可以上网搜吧…… 相当于一块劳力士吧……（我估计这组机器平时是用来挖矿的……[狗头]）</p>
<p>好了，我们来看一下这个 <code>/etc/passwd</code> 中的这些人的密码是什么样的，<strong>但最主要的是向这些为人类做过巨大贡献的程序员科学家们致敬</strong>！</p>
<ul>
<li><strong><a href="https://en.wikipedia.org/wiki/Ken_Thompson" target="_blank" rel="noopener noreferrer">Ken Thompson</a></strong><br />
除了是Unix、B语言和Go语言作者之外，他还贡献过正则表达式，QED/ed编辑器，UTF-8编码定义，以及计算机国际象棋Belle……</p>
<table>
<tbody>
<tr>
<td colspan="1" rowspan="1">登录名</td>
<td colspan="1" rowspan="1"><b>哈希串</b></td>
<td colspan="1" rowspan="1"><b>密码</b></td>
</tr>
<tr>
<td colspan="1" rowspan="1"><code>ken</code></td>
<td colspan="1" rowspan="1"><code>ZghOT0eRm4U9s</code></td>
<td colspan="1" rowspan="1"><code>p/q2-q4!</code></td>
</tr>
</tbody>
</table>
</li>
<li><strong><a href="https://en.wikipedia.org/wiki/Dennis_Ritchie" target="_blank" rel="noopener noreferrer">Dennis Ritchie</a></strong><br />
Unix和C语言之父，与Ken于1983年获图灵奖，1990年美国国家海明奖章，于2011年去世。</p>
<table>
<tbody>
<tr>
<td colspan="1" rowspan="1">登录名</td>
<td colspan="1" rowspan="1"><b>哈希串</b></td>
<td colspan="1" rowspan="1"><b>密码</b></td>
</tr>
<tr>
<td colspan="1" rowspan="1"><code>dmr</code></td>
<td colspan="1" rowspan="1"><code>gfVwhuAMF0Trw</code></td>
<td colspan="1" rowspan="1"><code>dmac</code></td>
</tr>
</tbody>
</table>
</li>
<li><strong><a href="https://en.wikipedia.org/wiki/Brian_Kernighan" target="_blank" rel="noopener noreferrer">Brian W. Kernighan</a></strong><br />
AWK的作者，是AWK中的“K”，也是与Dennis写的K&amp;C的C语言编程书中的“K”，他还编写了很多Unix的其它程序，如：<code>ditroff</code>，而且，设计了著名的<a href="https://en.wikipedia.org/wiki/Heuristic" target="_blank" rel="noopener noreferrer">启发式算法</a>。</p>
<table>
<tbody>
<tr>
<td colspan="1" rowspan="1">登录名</td>
<td colspan="1" rowspan="1"><b>哈希串</b></td>
<td colspan="1" rowspan="1"><b>密码</b></td>
</tr>
<tr>
<td colspan="1" rowspan="1"><code>bwk</code></td>
<td colspan="1" rowspan="1"><code>ymVglQZjbWYDE</code></td>
<td colspan="1" rowspan="1"><code>/.,/.,</code></td>
</tr>
</tbody>
</table>
</li>
<li><strong><a href="https://en.wikipedia.org/wiki/Stephen_R._Bourne" target="_blank" rel="noopener noreferrer">Stephen R. Bourne</a></strong><br />
Bourne shell（<code>sh</code>）的作者，Unix Shell作者，同时也是Unix调试器的作者。</p>
<table>
<tbody>
<tr>
<td colspan="1" rowspan="1">登录名</td>
<td colspan="1" rowspan="1"><b>哈希串</b></td>
<td colspan="1" rowspan="1"><b>密码</b></td>
</tr>
<tr>
<td colspan="1" rowspan="1"><code>srb</code></td>
<td colspan="1" rowspan="1"><code>c8UdIntIZCUIA</code></td>
<td colspan="1" rowspan="1"><code>bourne</code></td>
</tr>
</tbody>
</table>
</li>
<li><strong><a href="https://en.wikipedia.org/wiki/Eric_Schmidt" target="_blank" rel="noopener noreferrer">Eric Schmidt</a></strong><br />
你可能知道他是Google的CEO，苹果的董事，但是你可能不知道，他当年是是贝尔实施室的实习生，他对Unix的词法分析器 Lex 进行为了完全的重写。他的密码是中的wendy应该是他的妻子。</p>
<table>
<tbody>
<tr>
<td colspan="1" rowspan="1">登录名</td>
<td colspan="1" rowspan="1"><b>哈希串</b></td>
<td colspan="1" rowspan="1"><b>密码</b></td>
</tr>
<tr>
<td colspan="1" rowspan="1"><code>schmidt</code></td>
<td colspan="1" rowspan="1"><code>FH83PFo4z55cU</code></td>
<td colspan="1" rowspan="1"><code>wendy!!!</code></td>
</tr>
</tbody>
</table>
</li>
<li><strong><a href="https://en.wikipedia.org/wiki/Stuart_Feldman" target="_blank" rel="noopener noreferrer">Stuart Feldman</a></strong><br />
他除了是Unix系统小组的成员，他还是第一个Fortran 77 编译器的作者，也是 <code>make</code> 的作者。他还是楼上Shmidt慈善基金会的科学负责人，在Google/IBM Research任过职，也担任过ACM的主席。</p>
<table>
<tbody>
<tr>
<td colspan="1" rowspan="1">登录名</td>
<td colspan="1" rowspan="1"><b>哈希串</b></td>
<td colspan="1" rowspan="1"><b>密码</b></td>
</tr>
<tr>
<td colspan="1" rowspan="1"><code>sif</code></td>
<td colspan="1" rowspan="1"><code>IIVxQSvq1V9R2</code></td>
<td colspan="1" rowspan="1"><code>axolotl</code></td>
</tr>
</tbody>
</table>
</li>
<li><strong><a href="https://en.wikipedia.org/wiki/Mary_Ann_Horton" target="_blank" rel="noopener noreferrer">Mark Horton</a></strong><br />
Unix贡献者，包括vi和curses，后来变性为女性，新的名字叫Mary Ann Horton。原来的照片在<a href="http://www.ugu.com/sui/ugu/show?I=info.Mark_R._Horton" target="_blank" rel="noopener noreferrer">Unix Guru Universe</a></p>
<table>
<tbody>
<tr>
<td colspan="1" rowspan="1">登录名</td>
<td colspan="1" rowspan="1"><b>哈希串</b></td>
<td colspan="1" rowspan="1"><b>密码</b></td>
</tr>
<tr>
<td colspan="1" rowspan="1"><code>mark</code></td>
<td colspan="1" rowspan="1"><code>Pb1AmSpsVPG0Y</code></td>
<td colspan="1" rowspan="1"><code>uio</code></td>
</tr>
</tbody>
</table>
</li>
<li><strong><a href="https://en.wikipedia.org/wiki/Marshall_Kirk_McKusick" target="_blank" rel="noopener noreferrer">Kirk McKusick</a></strong><br />
BSD贡献者，主要负责文件系统UFS以及fsck命令，同时也是<code>gprof</code>的贡献者，公开的同性恋者。</p>
<table>
<tbody>
<tr>
<td colspan="1" rowspan="1">登录名</td>
<td colspan="1" rowspan="1"><b>哈希串</b></td>
<td colspan="1" rowspan="1"><b>密码</b></td>
</tr>
<tr>
<td colspan="1" rowspan="1"><code>mckusick</code></td>
<td colspan="1" rowspan="1"><code>AAZk9Aj5/Ue0E</code></td>
<td colspan="1" rowspan="1"><code>foobar</code></td>
</tr>
</tbody>
</table>
</li>
<li><strong><a href="https://en.wikipedia.org/wiki/Richard_Fateman" target="_blank" rel="noopener noreferrer">Richard Fateman</a></strong><br />
他在伯克利的VAX UNIX系统的开发工作中发挥了重要作用，以及开发了<a href="https://en.wikipedia.org/wiki/Franz_Lisp" target="_blank" rel="noopener noreferrer"> Franz Lisp</a>。</p>
<table>
<tbody>
<tr>
<td colspan="1" rowspan="1">登录名</td>
<td colspan="1" rowspan="1"><b>哈希串</b></td>
<td colspan="1" rowspan="1"><b>密码</b></td>
</tr>
<tr>
<td colspan="1" rowspan="1"><code>fateman</code></td>
<td colspan="1" rowspan="1"><code>E9i8fWghn1p/I</code></td>
<td colspan="1" rowspan="1"><code>apr1744</code></td>
</tr>
</tbody>
</table>
</li>
<li><strong>Peter Kessler</strong><br />
这位老兄能在网上查到的资料基本没有，可以查到他是 <code>gprof</code> 的贡献者，以及有名字的<a href="https://web.eecs.umich.edu/~weimerw/2009-4610/reading/graham-gprof.pdf" target="_blank" rel="noopener noreferrer">gprof的一篇论文</a></p>
<table>
<tbody>
<tr>
<td colspan="1" rowspan="1">登录名</td>
<td colspan="1" rowspan="1"><b>哈希串</b></td>
<td colspan="1" rowspan="1"><b>密码</b></td>
</tr>
<tr>
<td colspan="1" rowspan="1"><code>peter</code></td>
<td colspan="1" rowspan="1"><code>Nc3IkFJyW2u7E</code></td>
<td colspan="1" rowspan="1"><code>...hello</code></td>
</tr>
</tbody>
</table>
</li>
<li><strong>Kurt Shoens</strong><br />
BSD电子邮件开发者。Unix早期版本中使用 <code>uux</code> 和 <code>sendmail</code> 来进行远程消息传递，1978年，Kurt为Unix编写了一个邮件用户代理 Berkeley Mail。相关的历史可以参看<a href="http://heirloom.sourceforge.net/mailx_history.html" target="_blank" rel="noopener noreferrer">这篇文章</a>。</p>
<table>
<tbody>
<tr>
<td colspan="1" rowspan="1">登录名</td>
<td colspan="1" rowspan="1"><b>哈希串</b></td>
<td colspan="1" rowspan="1"><b>密码</b></td>
</tr>
<tr>
<td colspan="1" rowspan="1"><code>kurt</code></td>
<td colspan="1" rowspan="1"><code>olqH1vDqH38aw</code></td>
<td colspan="1" rowspan="1"><code>sacristy</code></td>
</tr>
</tbody>
</table>
</li>
<li><strong><a href="https://franz.com/about/press_room/foderaro_2-2-2015.lhtml" target="_blank" rel="noopener noreferrer">John Foderaro</a></strong><br />
他为Berkeley的Lisp语言编写原始的编译器，Lisp语言是一种类似于数据代数的语言，在计算机历史上有和C语言一样的作用。后来他成立了Franz公司，主要开发和部署图形搜索解决方案。</p>
<table>
<tbody>
<tr>
<td colspan="1" rowspan="1">登录名</td>
<td colspan="1" rowspan="1"><b>哈希串</b></td>
<td colspan="1" rowspan="1"><b>密码</b></td>
</tr>
<tr>
<td colspan="1" rowspan="1"><code>jkf</code></td>
<td colspan="1" rowspan="1"><code>9ULn5cWTc0b9E</code></td>
<td colspan="1" rowspan="1"><code>sherril.</code></td>
</tr>
</tbody>
</table>
</li>
<li><strong><a href="https://en.wikipedia.org/wiki/Peter_J._Weinberger" target="_blank" rel="noopener noreferrer">Peter J. Weinberger</a></strong><br />
他就是AWK中的那个“W”，同时也是Fortan编译器f77的贡献者，后来是<a title="" href="https://en.wikipedia.org/wiki/Renaissance_Technologies">Renaissance Technologies</a> （一家对冲基金）的CTO，现在在Google工作，</p>
<table>
<tbody>
<tr>
<td colspan="1" rowspan="1">登录名</td>
<td colspan="1" rowspan="1"><b>哈希串</b></td>
<td colspan="1" rowspan="1"><b>密码</b></td>
</tr>
<tr>
<td colspan="1" rowspan="1"><code>pjw</code></td>
<td colspan="1" rowspan="1"><code>N33.MCNcTh5Qw</code></td>
<td colspan="1" rowspan="1"><code>uucpuucp</code></td>
</tr>
</tbody>
</table>
</li>
<li><strong>John Reiser</strong><br />
他主要工作是将Unix和C移植到了DEC VAX上，这个机器在学术界相当流行（陈皓注：我在1994年上大学的时候，就是在这个机器上学习的C语言）。这扩大了Unix和C的影响力。</p>
<table>
<tbody>
<tr>
<td colspan="1" rowspan="1">登录名</td>
<td colspan="1" rowspan="1"><b>哈希串</b></td>
<td colspan="1" rowspan="1"><b>密码</b></td>
</tr>
<tr>
<td colspan="1" rowspan="1"><code>jfr</code></td>
<td colspan="1" rowspan="1"><code>X.ZNnZrciWauE</code></td>
<td colspan="1" rowspan="1"><code>5%ghj</code></td>
</tr>
</tbody>
</table>
</li>
<li><strong><a href="https://en.wikipedia.org/wiki/Stephen_C._Johnson" target="_blank" rel="noopener noreferrer">Steve Johnson</a></strong><br />
曾在贝尔实验室和AT＆T工作近20年。他以Yacc，Lint，spell和Portable C编译器而闻名。后来他去了硅谷，加入了一些创业公司，主要从事编译器的工作，以及2D和3D图形，大规模并行系统和嵌入式系统的开发工作。现在他在Wave Computing从事机器学习的工作。</p>
<table>
<tbody>
<tr>
<td colspan="1" rowspan="1">登录名</td>
<td colspan="1" rowspan="1"><b>哈希串</b></td>
<td colspan="1" rowspan="1"><b>密码</b></td>
</tr>
<tr>
<td colspan="1" rowspan="1"><code>scj</code></td>
<td colspan="1" rowspan="1"><code>IL2bmGECQJgbk</code></td>
<td colspan="1" rowspan="1"><code>pdq;dq</code></td>
</tr>
</tbody>
</table>
</li>
<li><strong>Bob Kridle</strong><br />
这位老兄的资料在没有太多，只能在 <a href="https://www.oreilly.com/openbook/opensources/book/kirkmck.html_original" target="_blank" rel="noopener noreferrer">Berkeley Unix 20 年</a> 上看到他跟Ken Thompson混过一段时间。</p>
<table>
<tbody>
<tr>
<td colspan="1" rowspan="1">登录名</td>
<td colspan="1" rowspan="1"><b>哈希串</b></td>
<td colspan="1" rowspan="1"><b>密码</b></td>
</tr>
<tr>
<td colspan="1" rowspan="1"><code>kridle</code></td>
<td colspan="1" rowspan="1"><code>4BkcEieEtjWXI</code></td>
<td colspan="1" rowspan="1"><code>jilland1</code></td>
</tr>
</tbody>
</table>
</li>
<li><strong><a href="https://people.eecs.berkeley.edu/~sklower/" target="_blank" rel="noopener noreferrer">Keith Sklower</a></strong><br />
BSD 的一个程序员。从他的主页上可以看到他目前在Berkeley大学，信息分析师，主要研究一些网络通信相关的技术。</p>
<table>
<tbody>
<tr>
<td colspan="1" rowspan="1">登录名</td>
<td colspan="1" rowspan="1"><b>哈希串</b></td>
<td colspan="1" rowspan="1"><b>密码</b></td>
</tr>
<tr>
<td colspan="1" rowspan="1"><code>sklower</code></td>
<td colspan="1" rowspan="1"><code>8PYh/dUBQT9Ss</code></td>
<td colspan="1" rowspan="1"><code>theik!!!</code></td>
</tr>
</tbody>
</table>
</li>
<li><strong>Robert Henry</strong><br />
网上的资料不多，只在<a href="https://www.tuhs.org/Archive/Documentation/Books/Life_with_Unix.pdf" target="_blank" rel="noopener noreferrer">Life with Unix</a>这本电子书中查到，他写了 <code>error</code></p>
<table>
<tbody>
<tr>
<td colspan="1" rowspan="1">登录名</td>
<td colspan="1" rowspan="1"><b>哈希串</b></td>
<td colspan="1" rowspan="1"><b>密码</b></td>
</tr>
<tr>
<td colspan="1" rowspan="1"><code>henry</code></td>
<td colspan="1" rowspan="1"><code>lj1vXnxTAPnDc</code></td>
<td colspan="1" rowspan="1"><code>sn74193n</code></td>
</tr>
</tbody>
</table>
</li>
<li><strong>Howard Katseff</strong><br />
网上的资料不多，只在<a href="https://www.tuhs.org/Archive/Documentation/Books/Life_with_Unix.pdf" target="_blank" rel="noopener noreferrer">Life with Unix</a>这本电子书中查到，他写了 <code>sdb</code> 和 <code>last</code></p>
<table>
<tbody>
<tr>
<td colspan="1" rowspan="1">登录名</td>
<td colspan="1" rowspan="1"><b>哈希串</b></td>
<td colspan="1" rowspan="1"><b>密码</b></td>
</tr>
<tr>
<td colspan="1" rowspan="1"><code>hpk</code></td>
<td colspan="1" rowspan="1"><code>9ycwM8mmmcp4Q</code></td>
<td colspan="1" rowspan="1"><code>graduat;</code></td>
</tr>
</tbody>
</table>
</li>
<li><strong><a href="https://en.wikipedia.org/wiki/%C3%96zalp_Babao%C4%9Flu" target="_blank" rel="noopener noreferrer">Özalp Babaoğlu</a></strong><br />
土耳其计算机科学家，1981年在Berkeley担任 BSD Unix的首席设计师，曾经与Sun的创造人Bill Joy在BSD上实现了虚拟内存。</p>
<table>
<tbody>
<tr>
<td colspan="1" rowspan="1">登录名</td>
<td colspan="1" rowspan="1"><b>哈希串</b></td>
<td colspan="1" rowspan="1"><b>密码</b></td>
</tr>
<tr>
<td colspan="1" rowspan="1"><code>ozalp</code></td>
<td colspan="1" rowspan="1"><code>m5syt3.lB5LAE</code></td>
<td colspan="1" rowspan="1"><code>12ucdort</code></td>
</tr>
</tbody>
</table>
</li>
<li><strong><a href="https://en.wikipedia.org/wiki/Bob_Fabry" target="_blank" rel="noopener noreferrer">Bob Fabry</a></strong><br />
他主要推动美国国防部高级研究计划局DARPA采用了Unix系统</p>
<table>
<tbody>
<tr>
<td colspan="1" rowspan="1">登录名</td>
<td colspan="1" rowspan="1"><b>哈希串</b></td>
<td colspan="1" rowspan="1"><b>密码</b></td>
</tr>
<tr>
<td colspan="1" rowspan="1"><code>fabry</code></td>
<td colspan="1" rowspan="1"><code>d9B17PTU2RTlM</code></td>
<td colspan="1" rowspan="1"><code>561cml..</code></td>
</tr>
</tbody>
</table>
</li>
<li><strong>Tom London</strong><br />
他和John Reiser在把Unix移植到了VAX-11机上。</p>
<table>
<tbody>
<tr>
<td colspan="1" rowspan="1">登录名</td>
<td colspan="1" rowspan="1"><b>哈希串</b></td>
<td colspan="1" rowspan="1"><b>密码</b></td>
</tr>
<tr>
<td colspan="1" rowspan="1"><code>tbl</code></td>
<td colspan="1" rowspan="1"><code>cBWEbG59spEmM</code></td>
<td colspan="1" rowspan="1"><code>..pnn521</code></td>
</tr>
</tbody>
</table>
</li>
</ul>
<p>最后，再首尾呼应一下，在我的技术生涯中，Unix文化对我个人的技术观影响是非常大的，<strong>我个人认为 Unix 就像摇滚乐一样，上世纪60年代-80年代，是整个人类最经典最光亮的时代，值得我们每个人向那个时代的人和事致敬！</strong></p>
<p>————————————————————————</p>
<p>P.S.</p>
<p>你可以浏览 Github 的 <a href="https://github.com/dspinellis/unix-history-repo/tree/BSD-3-Snapshot-Development" target="_blank" rel="noopener noreferrer">unix-history-repo</a> 目录（注：本文给的这个链接不在master分支上），这个repo是40年前的代码，涵盖了从1970年创建时的2.5万行内核和26条命令到2017年为止广泛使用的2700万行系统。1.1GB的存储库包含大约一百万次提交和两千多次合并。通过<a href="http://www.dmst.aueb.gr/dds/pubs/jrnl/2016-EMPSE-unix-history/html/unix-history.html" target="_blank" rel="noopener noreferrer">这个链接</a>你可以了解一下这个代码的历史！</p>
<p>下载这些代码需要你的1.5GB的硬盘空间，你可以查看各个大神写的代码，包括 Ken Thompson 和 Dennis的，以及相关的注释。</p>
<p>根据这些，你还可以找到 Ken Thompson的 Github账号 <a href="https://github.com/ken" target="_blank" rel="noopener noreferrer">https://github.com/ken</a> 以及别人为dmr建的github帐号 <a href="https://github.com/dmr-1941-2011">https://github.com/dmr-1941-2011</a></p>
<p>P.S.S</p>
<p>下面是一些和Unix相关的维基百科资料</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/History_of_Unix" target="_blank" rel="nofollow noopener noreferrer">History of Unix</a></li>
<li><a href="https://en.wikipedia.org/wiki/List_of_Unix_systems" target="_blank" rel="nofollow noopener noreferrer">List of Unix systems</a></li>
<li><a href="https://en.wikipedia.org/wiki/List_of_Unix_commands" target="_blank" rel="nofollow noopener noreferrer">List of Unix commands</a></li>
<li><a href="https://en.wikipedia.org/wiki/List_of_Unix_daemons" target="_blank" rel="nofollow noopener noreferrer">List of Unix daemons</a></li>
<li><a href="https://en.wikipedia.org/wiki/Research_Unix" target="_blank" rel="nofollow noopener noreferrer">Research Unix</a></li>
<li><a href="http://en.wikipedia.org/wiki/BSD_Unix" target="_blank" rel="nofollow noopener noreferrer">Berkeley Software Distribution</a></li>
<li><a href="https://en.wikipedia.org/wiki/Unix_philosophy" target="_blank" rel="nofollow noopener noreferrer">Unix philosophy</a></li>
</ul>
<p>还有Unix的社区：TUHS: The Unix Heritage Society &#8211; <a href="http://minnie.tuhs.org/cgi-bin/utree.pl" rel="nofollow">The Unix Tree</a></p>
<p>（全文完）<!--



<p align="center"><a href= target=_blank><img decoding="async" src=""></a></p>





<p align="center"><img decoding="async" src="https://coolshell.cn/wp-content/uploads/2020/03/coolshell.weixin.jpg"> <img decoding="async" loading="lazy" src="https://coolshell.cn/wp-content/uploads/2020/03/coolshell.mini_.jpg" width="300" height="300"> <br />关注CoolShell微信公众账号和微信小程序</p>

 

--></p>
<div style="margin-top: 15px; font-size: 16px;color: #cc0000;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 &#8211; CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>

<div class="wp_rp_wrap  wp_rp_vertical_m" ><div class="wp_rp_content"><h3 class="related_post_title">相关文章</h3><ul class="related_post wp_rp"><li ><a href="https://coolshell.cn/articles/2322.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2010/04/o_unixrichiethompson-150x150.jpg" alt="Unix传奇(上篇)" width="150" height="150" /></a><a href="https://coolshell.cn/articles/2322.html" class="wp_rp_title">Unix传奇(上篇)</a></li><li ><a href="https://coolshell.cn/articles/9410.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2013/04/figure1-150x150.gif" alt="Unix考古记：一个“遗失”的shell" width="150" height="150" /></a><a href="https://coolshell.cn/articles/9410.html" class="wp_rp_title">Unix考古记：一个“遗失”的shell</a></li><li ><a href="https://coolshell.cn/articles/1761.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2009/11/spell_it_with_e-150x150.jpg" alt="Go语言源码的一个改动" width="150" height="150" /></a><a href="https://coolshell.cn/articles/1761.html" class="wp_rp_title">Go语言源码的一个改动</a></li><li ><a href="https://coolshell.cn/articles/18360.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2018/05/300x262-150x150.jpg" alt="程序员练级攻略（2018)  与我的专栏" width="150" height="150" /></a><a href="https://coolshell.cn/articles/18360.html" class="wp_rp_title">程序员练级攻略（2018)  与我的专栏</a></li><li ><a href="https://coolshell.cn/articles/17998.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2017/07/systemd-1-150x150.jpeg" alt="Linux PID 1 和 Systemd" width="150" height="150" /></a><a href="https://coolshell.cn/articles/17998.html" class="wp_rp_title">Linux PID 1 和 Systemd</a></li><li ><a href="https://coolshell.cn/articles/12103.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2014/11/tux-fork-150x150.gif" alt="vfork 挂掉的一个问题" width="150" height="150" /></a><a href="https://coolshell.cn/articles/12103.html" class="wp_rp_title">vfork 挂掉的一个问题</a></li></ul></div></div>The post <a href="https://coolshell.cn/articles/19996.html">Unix 50 年：Ken Thompson 的密码</a> first appeared on <a href="https://coolshell.cn">酷 壳 - CoolShell</a>.]]></content:encoded>
					
					<wfw:commentRss>https://coolshell.cn/articles/19996.html/feed</wfw:commentRss>
			<slash:comments>30</slash:comments>
		
		
			</item>
		<item>
		<title>HTTP的前世今生</title>
		<link>https://coolshell.cn/articles/19840.html</link>
					<comments>https://coolshell.cn/articles/19840.html#comments</comments>
		
		<dc:creator><![CDATA[陈皓]]></dc:creator>
		<pubDate>Tue, 01 Oct 2019 11:21:10 +0000</pubDate>
				<category><![CDATA[技术读物]]></category>
		<category><![CDATA[程序设计]]></category>
		<category><![CDATA[系统架构]]></category>
		<category><![CDATA[网络安全]]></category>
		<category><![CDATA[HTTP]]></category>
		<category><![CDATA[QUIC]]></category>
		<category><![CDATA[TCP]]></category>
		<category><![CDATA[TLS]]></category>
		<category><![CDATA[UDP]]></category>
		<guid isPermaLink="false">https://coolshell.cn/?p=19840</guid>

					<description><![CDATA[<p>HTTP (Hypertext transfer protocol) 翻译成中文是超文本传输协议，是互联网上重要的一个协议，由欧洲核子研究委员会CERN的英国工...</p>
<p class="read-more"><a class="btn btn-default" href="https://coolshell.cn/articles/19840.html"> Read More<span class="screen-reader-text">  Read More</span></a></p>
The post <a href="https://coolshell.cn/articles/19840.html">HTTP的前世今生</a> first appeared on <a href="https://coolshell.cn">酷 壳 - CoolShell</a>.]]></description>
										<content:encoded><![CDATA[<p><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3415450859608158"
     crossorigin="anonymous"></script><img decoding="async" loading="lazy" class="alignright" src="https://coolshell.cn/wp-content/uploads/2019/10/HTTP-770x513-300x200.jpg" alt="" width="300" height="200" />HTTP (Hypertext transfer protocol) 翻译成中文是超文本传输协议，是互联网上重要的一个协议，由欧洲核子研究委员会CERN的英国工程师 <a title="" href="https://en.wikipedia.org/wiki/Tim_Berners-Lee">Tim Berners-Lee</a> v发明的，同时，他也是WWW的发明人，最初的主要是用于传递通过HTML封装过的数据。在1991年发布了HTTP 0.9版，在1996年发布1.0版，1997年是1.1版，1.1版也是到今天为止传输最广泛的版本（初始<a class="external text" href="https://tools.ietf.org/html/rfc2068" rel="nofollow">RFC 2068</a> 在1997年发布， 然后在1999年被 <a class="external text" href="https://tools.ietf.org/html/rfc2616" rel="nofollow">RFC 2616</a> 取代，再在2014年被 <a class="external text" href="https://tools.ietf.org/html/rfc7230" rel="nofollow">RFC 7230</a> /<a class="external text" href="https://tools.ietf.org/html/rfc7231" rel="nofollow">7231</a>/<a class="external text" href="https://tools.ietf.org/html/rfc7232" rel="nofollow">7232</a>/<a class="external text" href="https://tools.ietf.org/html/rfc7233" rel="nofollow">7233</a>/<a class="external text" href="https://tools.ietf.org/html/rfc7234" rel="nofollow">7234</a>/<a class="external text" href="https://tools.ietf.org/html/rfc7235" rel="nofollow">7235</a>取代），2015年发布了2.0版，其极大的优化了HTTP/1.1的性能和安全性，而2018年发布的3.0版，继续优化HTTP/2，激进地使用UDP取代TCP协议，目前，HTTP/3 在2019年9月26日 被 Chrome，Firefox，和Cloudflare支持，所以我想写下这篇文章，简单地说一下HTTP的前世今生，让大家学到一些知识，并希望可以在推动一下HTTP标准协议的发展。</p>
<h4>HTTP 0.9 / 1.0</h4>
<p>0.9和1.0这两个版本，就是最传统的 request &#8211; response的模式了，HTTP 0.9版本的协议简单到极点，请求时，不支持请求头，只支持 <code>GET</code> 方法，没了。HTTP 1.0 扩展了0.9版，其中主要增加了几个变化：</p>
<p><span id="more-19840"></span></p>
<ul>
<li>在请求中加入了HTTP版本号，如：<code>GET /coolshell/index.html HTTP/1.0</code></li>
<li>HTTP 开始有 header了，不管是request还是response 都有header了。</li>
<li>增加了HTTP Status Code 标识相关的状态码。</li>
<li>还有 <code>Content-Type</code> 可以传输其它的文件了。</li>
</ul>
<p>我们可以看到，HTTP 1.0 开始让这个协议变得很文明了，一种工程文明。因为：</p>
<ul>
<li>一个协议有没有版本管理，是一个工程化的象征。</li>
<li>header是协议可以说是把元数据和业务数据解耦，也可以说是控制逻辑和业务逻辑的分离。</li>
<li>Status Code 的出现可以让请求双方以及第三方的监控或管理程序有了统一的认识。最关键是还是控制错误和业务错误的分离。</li>
</ul>
<p>（注：国内很多公司HTTP无论对错只返回200，这种把HTTP Status Code 全部抹掉完全是一种工程界的倒退）</p>
<p>但是，HTTP1.0性能上有一个很大的问题，那就是每请求一个资源都要新建一个TCP链接，而且是串行请求，所以，就算网络变快了，打开网页的速度也还是很慢。所以，HTTP 1.0 应该是一个必需要淘汰的协议了。</p>
<h4> HTTP/1.1</h4>
<p>HTTP/1.1 主要解决了HTTP 1.0的网络性能的问题，以及增加了一些新的东西：</p>
<ul>
<li>可以设置 <code>keepalive</code> 来让HTTP重用TCP链接，重用TCP链接可以省了每次请求都要在广域网上进行的TCP的三次握手的巨大开销。这是所谓的“<strong>HTTP 长链接</strong>” 或是 “<strong>请求响应式的HTTP 持久链接</strong>”。英文叫 HTTP Persistent connection.</li>
<li>然后支持pipeline网络传输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。（注：非幂等的POST 方法或是有依赖的请求是不能被pipeline化的）</li>
<li>支持 Chunked Responses ，也就是说，在Response的时候，不必说明 <code>Content-Length</code> 这样，客户端就不能断连接，直到收到服务端的EOF标识。这种技术又叫 “<strong>服务端Push模型</strong>”，或是 “<strong>服务端Push式的HTTP 持久链接</strong>”</li>
<li>还增加了 cache control 机制。</li>
<li>协议头注增加了 Language, Encoding, Type 等等头，让客户端可以跟服务器端进行更多的协商。</li>
<li>还正式加入了一个很重要的头—— <code><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Host" target="_blank" rel="noopener noreferrer">HOST</a></code>这样的话，服务器就知道你要请求哪个网站了。因为可以有多个域名解析到同一个IP上，要区分用户是请求的哪个域名，就需要在HTTP的协议中加入域名的信息，而不是被DNS转换过的IP信息。</li>
<li>正式加入了 <code>OPTIONS</code> 方法，其主要用于 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS" target="_blank" rel="noopener noreferrer">CORS &#8211; Cross Origin Resource Sharing</a> 应用。</li>
</ul>
<p>HTTP/1.1应该分成两个时代，一个是2014年前，一个是2014年后，因为2014年HTTP/1.1有了一组RFC（<a class="external text" href="https://tools.ietf.org/html/rfc7230" rel="nofollow">7230</a> /<a class="external text" href="https://tools.ietf.org/html/rfc7231" rel="nofollow">7231</a>/<a class="external text" href="https://tools.ietf.org/html/rfc7232" rel="nofollow">7232</a>/<a class="external text" href="https://tools.ietf.org/html/rfc7233" rel="nofollow">7233</a>/<a class="external text" href="https://tools.ietf.org/html/rfc7234" rel="nofollow">7234</a>/<a class="external text" href="https://tools.ietf.org/html/rfc7235" rel="nofollow">7235</a>），这组RFC又叫“HTTP/2 预览版”。其中影响HTTP发展的是两个大的需求：</p>
<ul>
<li>一个需要是加大了HTTP的安全性，这样就可以让HTTP应用得广泛，比如，使用TLS协议。</li>
<li>另一个是让HTTP可以支持更多的应用，在HTTP/1.1 下，HTTP已经支持四种网络协议：
<ul>
<li>传统的短链接。</li>
<li>可重用TCP的的长链接模型。</li>
<li>服务端push的模型。</li>
<li>WebSocket模型。</li>
</ul>
</li>
</ul>
<p>自从2005年以来，整个世界的应用API越来多，这些都造就了整个世界在推动HTTP的前进，我们可以看到，<strong>自2014的HTTP/1.1 以来，这个世界基本的应用协议的标准基本上都是向HTTP看齐了，也许2014年前，还有一些专用的RPC协议，但是2014年以后，HTTP协议的增强，让我们实在找不出什么理由不向标准靠拢，还要重新发明轮子了。</strong></p>
<h4>HTTP/2</h4>
<p>虽然 HTTP/1.1 已经开始变成应用层通讯协议的一等公民了，但是还是有性能问题，虽然HTTP/1.1 可以重用TCP链接，但是请求还是一个一个串行发的，需要保证其顺序。然而，大量的网页请求中都是些资源类的东西，这些东西占了整个HTTP请求中最多的传输数据量。所以，理论上来说，如果能够并行这些请求，那就会增加更大的网络吞吐和性能。</p>
<p>另外，HTTP/1.1传输数据时，是以文本的方式，借助耗CPU的zip压缩的方式减少网络带宽，但是耗了前端和后端的CPU。这也是为什么很多RPC协议诟病HTTP的一个原因，就是数据传输的成本比较大。</p>
<p>其实，在2010年时，Google 就在搞一个实验型的协议，这个协议叫<a href="https://en.wikipedia.org/wiki/SPDY">SPDY</a>，这个协议成为了HTTP/2的基础（也可以说成HTTP/2就是SPDY的复刻）。HTTP/2基本上解决了之前的这些性能问题，其和HTTP/1.1最主要的不同是：</p>
<ul>
<li>HTTP/2是一个二进制协议，增加了数据传输的效率。</li>
<li>HTTP/2是可以在一个TCP链接中并发请求多个HTTP请求，移除了HTTP/1.1中的串行请求。</li>
<li>HTTP/2会压缩头，如果你同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你消除重复的部分。这就是所谓的HPACK算法（参看<a class="external mw-magiclink-rfc" href="https://tools.ietf.org/html/rfc7541" target="_blank" rel="nofollow noopener noreferrer">RFC 7541</a> 附录A）</li>
<li>HTTP/2允许服务端在客户端放cache，又叫服务端push，也就是说，你没有请求的东西，我服务端可以先送给你放在你的本地缓存中。比如，你请求X，我服务端知道X依赖于Y，虽然你没有的请求Y，但我把把Y跟着X的请求一起返回客户端。</li>
</ul>
<p>对于这些性能上的改善，在Medium上有篇文章你可看一下相关的细节说明和测试“<a href="https://medium.com/@factoryhr/http-2-the-difference-between-http-1-1-benefits-and-how-to-use-it-38094fa0e95b" target="_blank" rel="noopener noreferrer">HTTP/2: the difference between HTTP/1.1, benefits and how to use it</a>”</p>
<p>当然，还需要注意到的是HTTP/2的协议复杂度比之前所有的HTTP协议的复杂度都上升了许多许多，其内部还有很多看不见的东西，比如其需要维护一个“优先级树”来用于来做一些资源和请求的调度和控制。如此复杂的协议，自然会产生一些不同的声音，或是降低协议的可维护和可扩展性。所以也有一些争议。尽管如此，HTTP/2还是很快地被世界所采用。</p>
<p>HTTP/2 是2015年推出的，其发布后，Google 宣布移除对SPDY的支持，拥抱标准的 HTTP/2。过了一年后，就有8.7%的网站开启了HTTP/2，根据 <a href="https://w3techs.com/technologies/details/ce-http2/all/all" target="_blank" rel="noopener noreferrer">这份报告</a> ，截止至本文发布时（2019年10月1日 ）， 在全世界范围内已经有41%的网站开启了HTTP/2。</p>
<p>HTTP/2的官方组织在 Github 上维护了一份<a href="https://github.com/http2/http2-spec/wiki/Implementations" target="_blank" rel="noopener noreferrer">各种语言对HTTP/2的实现列表</a>，大家可以去看看。</p>
<p>我们可以看到，HTTP/2 在性能上对HTTP有质的提高，所以，HTTP/2 被采用的也很快，所以，<strong>如果你在你的公司内负责架构的话，HTTP/2是你一个非常重要的需要推动的一个事，除了因为性能上的问题，推动标准落地也是架构师的主要职责，因为，你企业内部的架构越标准，你可以使用到开源软件，或是开发方式就会越有效率，跟随着工业界的标准的发展，你的企业会非常自然的享受到标准所带来的红利。</strong></p>
<h4>HTTP/3</h4>
<p>然而，这个世界没有完美的解决方案，HTTP/2也不例外，其主要的问题是：若干个HTTP的请求在复用一个TCP的连接，底层的TCP协议是不知道上层有多少个HTTP的请求的，所以，一旦发生丢包，造成的问题就是所有的HTTP请求都必需等待这个丢了的包被重传回来，哪怕丢的那个包不是我这个HTTP请求的。因为TCP底层是没有这个知识了。</p>
<p>这个问题又叫<a href="https://en.wikipedia.org/wiki/Head-of-line_blocking" target="_blank" rel="noopener noreferrer">Head-of-Line Blocking</a>问题，这也是一个比较经典的流量调度的问题。这个问题最早主要的发生的交换机上。下图来自Wikipedia。</p>
<p><img decoding="async" loading="lazy" class="aligncenter" src="https://coolshell.cn/wp-content/uploads/2019/10/HOL_blocking.png" alt="" width="423" height="220" /></p>
<p>图中，左边的是输入队列，其中的1，2，3，4表示四个队列，四个队列中的1，2，3，4要去的右边的output的端口号。此时，第一个队列和第三个队列都要写右边的第四个端口，然后，一个时刻只能处理一个包，所以，一个队列只能在那等另一个队列写完后。然后，其此时的3号或1号端口是空闲的，而队列中的要去1和3号端号的数据，被第四号端口给block住了。这就是所谓的HOL blocking问题。</p>
<p>HTTP/1.1中的pipeline中如果有一个请求block了，那么队列后请求也统统被block住了；HTTP/2 多请求复用一个TCP连接，一旦发生丢包，就会block住所有的HTTP请求。这样的问题很讨厌。好像基本无解了。</p>
<p>是的TCP是无解了，但是UDP是有解的 ！<strong>于是HTTP/3破天荒地把HTTP底层的TCP协议改成了UDP！</strong></p>
<p>然后又是Google 家的协议进入了标准 &#8211; QUIC （Quick UDP Internet Connections）。接下来是QUIC协议的几个重要的特性，为了讲清楚这些特性，我需要带着问题来讲（注：下面的网络知识，如果你看不懂的话，你需要学习一下《<a href="https://book.douban.com/subject/1088054/" target="_blank" rel="noopener noreferrer">TCP/IP详解</a>》一书（在我写blog的这15年里，这本书推荐了无数次了），或是看一下本站的《<a href="https://coolshell.cn/articles/11564.html">TCP的那些事</a>》。）：</p>
<ul>
<li>首先是上面的Head-of-Line blocking问题，在UDP的世界中，这个就没了。这个应该比较好理解，因为UDP不管顺序，不管丢包（当然，QUIC的一个任务是要像TCP的一个稳定，所以QUIC有自己的丢包重传的机制）</li>
<li>TCP是一个无私的协议，也就是说，如果网络上出现拥塞，大家都会丢包，于是大家都会进入拥塞控制的算法中，这个算法会让所有人都“冷静”下来，然后进入一个“慢启动”的过程，包括在TCP连接建立时，这个慢启动也在，所以导致TCP性能迸发地比较慢。QUIC基于UDP，使用更为激进的方式。同时，QUIC有一套自己的丢包重传和拥塞控制的协，一开始QUIC是重新实现一TCP 的 CUBIC算法，但是随着BBR算法的成熟（BBR也在借鉴CUBIC算法的数学模型），QUIC也可以使用BBR算法。这里，多说几句，<strong>从模型来说，以前的TCP的拥塞控制算法玩的是数学模型，而新型的TCP拥塞控制算法是以BBR为代表的测量模型</strong>，理论上来说，后者会更好，但QUIC的团队在一开始觉得BBR不如CUBIC的算法好，所以没有用。现在的BBR 2.x借鉴了CUBIC数学模型让拥塞控制更公平。这里有文章大家可以一读“<a href="https://medium.com/google-cloud/tcp-bbr-magic-dust-for-network-performance-57a5f1ccf437" target="_blank" rel="noopener noreferrer">TCP BBR : Magic dust for network performance.</a>”</li>
<li>接下来，现在要建立一个HTTPS的连接，先是TCP的三次握手，然后是TLS的三次握手，要整出六次网络交互，一个链接才建好，虽说HTTP/1.1和HTTP/2的连接复用解决这个问题，但是基于UDP后，UDP也得要实现这个事。于是QUIC直接把TCP的和TLS的合并成了三次握手（对此，在HTTP/2的时候，是否默认开启TLS业内是有争议的，反对派说，TLS在一些情况下是不需要的，比如企业内网的时候，而支持派则说，TLS的那些开销，什么也不算了）。</li>
</ul>
<table>
<tbody>
<tr>
<td><img decoding="async" loading="lazy" src="https://coolshell.cn/wp-content/uploads/2019/10/http-request-over-tcp-tls@2x-292x300.png" alt="" width="292" height="300" /></td>
<td><img decoding="async" loading="lazy" class="" src="https://coolshell.cn/wp-content/uploads/2019/10/http-request-over-quic@2x-300x215.png" alt="" width="312" height="227" /></td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>所以，QUIC是一个在UDP之上的伪TCP +TLS +HTTP/2的多路复用的协议。</p>
<p>但是对于UDP还是有一些挑战的，这个挑战主要来自互联网上的各种网络设备，这些设备根本不知道是什么QUIC，他们看QUIC就只能看到的就是UDP，所以，在一些情况下，UDP就是有问题的，</p>
<ul>
<li>比如在NAT的环境下，如果是TCP的话，NAT路由或是代理服务器，可以通过记录TCP的四元组（源地址、源端口，目标地址，目标端口）来做连接映射的，然而，在UDP的情况下不行了。于是，QUIC引入了个叫connection id的不透明的ID来标识一个链接，用这种业务ID很爽的一个事是，如果你从你的3G/4G的网络切到WiFi网络（或是反过来），你的链接不会断，因为我们用的是connection id，而不是四元组。</li>
</ul>
<ul>
<li>然而就算引用了connection id，也还是会有问题 ，比如一些不够“聪明”的等价路由交换机，这些交换机会通过四元组来做hash把你的请求的IP转到后端的实际的服务器上，然而，他们不懂connection id，只懂四元组，这么导致属于同一个connection id但是四元组不同的网络包就转到了不同的服务器上，这就是导致数据不能传到同一台服务器上，数据不完整，链接只能断了。所以，你需要更聪明的算法（可以参看 Facebook 的 <a href="https://github.com/facebookincubator/katran" target="_blank" rel="noopener noreferrer">Katran</a> 开源项目 ）</li>
</ul>
<p>好了，就算搞定上面的东西，还有一些业务层的事没解，这个事就是 HTTP/2的头压缩算法 HPACK，HPACK需要维护一个动态的字典表来分析请求的头中哪些是重复的，HPACK的这个数据结构需要在encoder和decoder端同步这个东西。在TCP上，这种同步是透明的，然而在UDP上这个事不好干了。所以，这个事也必需要重新设计了，基于QUIC的QPACK就出来了，利用两个附加的QUIC steam，一个用来发送这个字典表的更新给对方，另一个用来ack对方发过来的update。</p>
<p>目前看下来，HTTP/3目前看上去没有太多的协议业务逻辑上的东西，更多是HTTP/2 + QUIC协议。但，HTTP/3 因为动到了底层协议，所以，在普及方面上可能会比 HTTP/2要慢的多的多。但是，可以看到QUIC协议的强大，细思及恐，QUIC这个协议真对TCP是个威胁，如果QUIC成熟了，TCP是不是会有可能成为历史呢？</p>
<p>未来十年，让我们看看UDP是否能够逆袭TCP……</p>
<p>(全文完)<!--



<p align="center"><a href= target=_blank><img decoding="async" src=""></a></p>





<p align="center"><img decoding="async" src="https://coolshell.cn/wp-content/uploads/2020/03/coolshell.weixin.jpg"> <img decoding="async" loading="lazy" src="https://coolshell.cn/wp-content/uploads/2020/03/coolshell.mini_.jpg" width="300" height="300"> <br />关注CoolShell微信公众账号和微信小程序</p>

 

--></p>
<div style="margin-top: 15px; font-size: 16px;color: #cc0000;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 &#8211; CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>

<div class="wp_rp_wrap  wp_rp_vertical_m" ><div class="wp_rp_content"><h3 class="related_post_title">相关文章</h3><ul class="related_post wp_rp"><li ><a href="https://coolshell.cn/articles/7490.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2012/06/f1-150x150.jpg" alt="性能调优攻略" width="150" height="150" /></a><a href="https://coolshell.cn/articles/7490.html" class="wp_rp_title">性能调优攻略</a></li><li ><a href="https://coolshell.cn/articles/22263.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2022/07/wall_clock-300x167-1-150x150.jpeg" alt="从一次经历谈 TIME_WAIT 的那些事" width="150" height="150" /></a><a href="https://coolshell.cn/articles/22263.html" class="wp_rp_title">从一次经历谈 TIME_WAIT 的那些事</a></li><li ><a href="https://coolshell.cn/articles/22173.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2022/02/http_method-150x150.png" alt="“一把梭：REST API 全用 POST”" width="150" height="150" /></a><a href="https://coolshell.cn/articles/22173.html" class="wp_rp_title">“一把梭：REST API 全用 POST”</a></li><li ><a href="https://coolshell.cn/articles/21708.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2022/01/iStock-1175502114-150x150.png" alt="网络数字身份认证术" width="150" height="150" /></a><a href="https://coolshell.cn/articles/21708.html" class="wp_rp_title">网络数字身份认证术</a></li><li ><a href="https://coolshell.cn/articles/18094.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2017/08/enable-https-banner-150x150.png" alt="如何免费的让网站启用HTTPS" width="150" height="150" /></a><a href="https://coolshell.cn/articles/18094.html" class="wp_rp_title">如何免费的让网站启用HTTPS</a></li><li ><a href="https://coolshell.cn/articles/11609.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2014/05/xin_2001040422167711230318-150x150.jpg" alt="TCP 的那些事儿（下）" width="150" height="150" /></a><a href="https://coolshell.cn/articles/11609.html" class="wp_rp_title">TCP 的那些事儿（下）</a></li></ul></div></div>The post <a href="https://coolshell.cn/articles/19840.html">HTTP的前世今生</a> first appeared on <a href="https://coolshell.cn">酷 壳 - CoolShell</a>.]]></content:encoded>
					
					<wfw:commentRss>https://coolshell.cn/articles/19840.html/feed</wfw:commentRss>
			<slash:comments>77</slash:comments>
		
		
			</item>
		<item>
		<title>50年前的登月程序和程序员有多硬核</title>
		<link>https://coolshell.cn/articles/19612.html</link>
					<comments>https://coolshell.cn/articles/19612.html#comments</comments>
		
		<dc:creator><![CDATA[陈皓]]></dc:creator>
		<pubDate>Sun, 21 Jul 2019 11:00:30 +0000</pubDate>
				<category><![CDATA[业界新闻]]></category>
		<category><![CDATA[技术读物]]></category>
		<category><![CDATA[杂项资源]]></category>
		<category><![CDATA[Programmer]]></category>
		<category><![CDATA[Programming]]></category>
		<category><![CDATA[程序员]]></category>
		<guid isPermaLink="false">https://coolshell.cn/?p=19612</guid>

					<description><![CDATA[<p>2019年7月20日，是有纪念意义的一天，这天不是因为广大网民帮周杰伦在新浪微博上的超话刷到第一，而是阿波罗登月的50周年的纪念日。早在几年前，在Github上...</p>
<p class="read-more"><a class="btn btn-default" href="https://coolshell.cn/articles/19612.html"> Read More<span class="screen-reader-text">  Read More</span></a></p>
The post <a href="https://coolshell.cn/articles/19612.html">50年前的登月程序和程序员有多硬核</a> first appeared on <a href="https://coolshell.cn">酷 壳 - CoolShell</a>.]]></description>
										<content:encoded><![CDATA[<p><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3415450859608158"
     crossorigin="anonymous"></script>2019年7月20日，是有纪念意义的一天，这天不是因为广大网民帮周杰伦在新浪微博上的超话刷到第一，而是阿波罗登月的50周年的纪念日。早在几年前，在Github上放出了当年Apollo飞船使用的源代码（当然是汇编的），但完全不明白为什么这几天会有一些中国的小朋友到这个github的issue里灌水……，人类历史上这么伟大的一件事，为什么不借这个机会学习一下呢？下面是一些阿波罗登月与程序员相关的小故事，顺着这些东西，你可以把你的周末和精力用得更有价值。</p>
<p><img decoding="async" loading="lazy" class=" size-full alignright" src="https://coolshell.cn/wp-content/uploads/2019/07/1920px-Margaret_Hamilton_-_restoration-e1563697198766.jpg" alt="" width="400" height="498" /></p>
<p>首先，要说的是Apollo 11导航的源代码，这些代码的设计负责人叫<a href="https://en.wikipedia.org/wiki/Margaret_Hamilton_(software_engineer)" target="_blank" rel="noopener noreferrer">Margaret Heafield Hamilton </a>，是一个女程序员，专业是数学和哲学，1960年得到一个MIT麻省理工大学的临时的软件开发职位，负责在PDP-1和LGP-30上运行天气预报的软件（注：在计算机历史上，PDP系统机器被称为Hack文化的重要推手，PDP-11推了Unix操作系统，而Unix操作系统则是黑客文化的重要产品。参看《<a href="https://coolshell.cn/articles/2322.html" target="_blank" rel="noopener noreferrer">Unix传奇</a>》）。然后，她又为美国空军编写探测知敌方飞行的软件，之后，于1965年的时候，她加入了MIT仪器实验室，并成为了这个实验室的主管，这个实验实就是Apollo计划的一部分，她负责编写全新的月球登录的导航软件，以及后来该软件在其他项目中的各个版本。</p>
<p><span id="more-19612"></span></p>
<p>上图是Hamilton站在她和她的麻省理工团队为阿波罗项目制作的导航软件源代码旁边，在Github上的开源的代码 &#8211; <a href="https://github.com/chrislgarry/Apollo-11" target="_blank" rel="noopener noreferrer">Apollo-11</a> （2016年开源）。我们可以看到，有两个重要的目录，一个目录叫“Comanche055”，一个目录叫“Luminary099”，前者是指挥舱用的（英文为 <a href="https://en.wikipedia.org/wiki/Apollo_command_and_service_module#Command_Module_(CM)" target="_blank" rel="noopener noreferrer">Command Module</a> ）后者为登月舱用的（英文为 <a href="https://en.wikipedia.org/wiki/Apollo_Lunar_Module" target="_blank" rel="noopener noreferrer">Lunar Module</a>），这里需要说明一下的是，指挥舱是把登录舱推到月球上，在返回的时候，登录舱是被抛弃掉的，而返回到地球的是指挥舱。如果你想看这两份源代码的纸版，你可以访问这两个链接：<a href="https://archive.org/details/Comanche55J2k60" target="_blank" rel="noopener noreferrer">Comanche 55 AGC Program Listing</a> 和 <a href="https://archive.org/details/Luminary99001J2k60" target="_blank" rel="noopener noreferrer">Luminary 99 REv.1 AGC Program Listing</a>。其中的55 和 90 是各自的build 版本号。</p>
<p>我们细看一下，这些文件的日期是，1969年7月14日，而Apollo 11登月的日期是1969年7月16日起程，7月19日经过月球背面，7月20日下午8点登月。代码写好，两天后就直接上生产，然后就登月，还是导航代码，这代码写的的健壮性得有多强。</p>
<p>如果你仔细比较一下这两个目录中的文件，你会发现有些文件是一样的，不但文件名一样，而且内容也一样。这说明这两个模块中的一些东西是相似的。</p>
<p><img decoding="async" loading="lazy" class="size-full aligncenter" src="https://coolshell.cn/wp-content/uploads/2019/07/source.code_.compare.png" alt="" width="800" height="402" /></p>
<p>这些代码应该是很难读了，因为当时写这些代码的时候，C语言都没有被发明，所以基本上来说都是汇编代码了，而且还可以发现，这些代码的源文件全是以agc后缀结尾的， 看来这还不是我们平时所了解的汇编，所谓的AGC代表了运行这些代码的计算机 &#8211;<a href="https://en.wikipedia.org/wiki/Apollo_Guidance_Computer" target="_blank" rel="noopener noreferrer"> Apollo Guideance Computer</a> 。沿着这个Wikipedia的链接，你可以看到AGC这个电脑的指令是什么样的，看懂那几条指令后，这些源代码也就能读懂了。当然，因为是写成汇编的，所以，读起来还是要费点神的。不过，其中有一个文件是 <code><a href="https://github.com/chrislgarry/Apollo-11/blob/master/Luminary099/LUNAR_LANDING_GUIDANCE_EQUATIONS.agc" target="_blank" rel="noopener noreferrer">LUNAR_LANDING_GUIDANCE_EQUATIONS.agc</a></code> 你会不会很好奇想去看看？</p>
<p>打开源文件，你还可以看到每个文件都有很多很多的注释，非常友好，但是也有一些注释比较有趣。这里有一组短视频带你读这些代码 &#8211; <a href="https://www.pluralsight.com/courses/moon-landing-apollo-11" target="_blank" rel="noopener noreferrer">Exploring the Apollo Guidance Computer(AGC) Code</a>，一供10个小视频，每个2分钟左右，如果你英文听边还行（我觉得很容易听懂），可以看看，了解一下AGC的工作方式，挺有趣意思的。</p>
<p>当时的AGC有32公斤，主频只有2MHz，2K的RAM，36K的ROM。嗯，当年就是这么一个小玩意，把人送上了月球，今天，一个聊天程序就占内存几GB……</p>
<p>下面是AGC在Apollo 1指挥舱里的样子（图片截自上面的视频），这个高质量的3D扫描来自<a href="https://www.3d.si.edu/explorer/apollo-11-command-module" target="_blank" rel="noopener noreferrer"> Simithsonian 3D: Apollo 11 Command Module</a> （我觉得美国人干这些事干就是很漂亮啊，这种高清的3D扫描太牛了，如果你仔细看，这个舱里还有宇航员在舱壁上的手写）</p>
<p><img decoding="async" loading="lazy" class="aligncenter size-full" src="https://coolshell.cn/wp-content/uploads/2019/07/AGC.DSKY_.png" alt="" width="800" height="402" /></p>
<p>这个AGC的操作界面又叫DSKY &#8211; Display 和 Keyboard的缩写，下图是一个 AGC 模拟器，其官方主页在 <a href="https://www.ibiblio.org/apollo/" target="_blank" rel="noopener noreferrer">https://www.ibiblio.org/apollo/</a>源代码在 <a href="https://github.com/virtualagc/virtualagc" target="_blank" rel="noopener noreferrer">Github/VirtualAGC</a>。在这个界面上我们可以看到：下面的键盘上左边有两个键，一个是动词Verb一个是名词Noun，Verb指定操作类型，Noun指定要由Verb命令修改的数据。右边的显示器下面有三个5位的数字，这三个数值显示表示航天器姿态的矢量，以及所需速度变化的显示矢量。是的，当年的导航就靠这三个数字和里面的程序了。</p>
<p><img decoding="async" loading="lazy" class="aligncenter size-full" src="https://coolshell.cn/wp-content/uploads/2019/07/DSKY.png" alt="" width="588" height="669" /></p>
<p>&nbsp;</p>
<p>如果你想了解AGC更多的细节，你可以看看 这篇 <a href="http://www.ibiblio.org/apollo/ForDummies.html" target="_blank" rel="noopener noreferrer">AGC for Dummies</a>。这篇文章讲述了AGC这个嵌入式系统的背景和操作指令。一份详细的<a href="http://www.ibiblio.org/apollo/assembly_language_manual.html" target="_blank" rel="noopener noreferrer">AGC 汇编语言手册</a>可以让你了解更多的细节。</p>
<p>另外，我在Youtube上找到了一个讲当时Apollo电脑的纪录片 &#8211; <a href="https://www.youtube.com/watch?v=9YA7X5we8ng" target="_blank" rel="noopener noreferrer">Navigation Computer</a>，太有趣了。比如：21分51秒开始讲存储用的 <a href="https://en.wikipedia.org/wiki/Core_rope_memory" target="_blank" rel="noopener noreferrer">Rope Memory</a> 绕线内存，Hamilton 也出来讲了一下在这种内存上编程，画面切到一个人用个比较长的金属针在一个像主板一样的东西上，左右穿梭，就像刺绣一样，但是绣的不是图案，而是程序……太硬核了，真正的通过“硬编织”的方式来写程序。</p>
<p><a href="https://www.youtube.com/watch?v=9YA7X5we8ng" target="_blank" rel="noopener noreferrer"><img decoding="async" loading="lazy" class="aligncenter size-full" src="https://coolshell.cn/wp-content/uploads/2019/07/rope.memory.png" alt="" width="800" height="497" /></a></p>
<p>看完上面这个纪录篇，我是非常之惊叹，惊叹于50年前的工程能力，惊叹于50年前这些人面对技术的的一丝不苟，对技术的尊重和严谨的这种精神和方法，一点都不比较今天差。</p>
<p>不过，最牛的还不是这个，我在Hamilton的Wikipedia词条上找到了他说的一个事件—— 当年Apollo登陆雷达开关放在了错误的位置，导致AGC收到了不少错误的信号。结果就是AGC既得执行着陆必须的计算，又要接受这些占用其15%时间的额外数据。但是AGC的程序居然可以用高优先级的任务打断低优先级的任务，于是，AGC自动剔除了低级别的任务以保证了重要的任务完成。Hamilton 原话说—— 如果当时的程序不能识别错误并从错误中恢复，我怀疑阿波罗不能成功登月。if the computer hadn&#8217;t recognized this problem and taken recovery action, I doubt if Apollo 11 would have been the successful moon landing it was。</p>
<p>看到这里，你有没有觉得——“这个女程序员的一小步，是整个人类的一大步”？</p>
<p>Hamilton 的牛逼之外还在于，她是第一个将“软件工程”提出来的人，在MIT，她想让软件开发就像其它工程一样，有相应的工程纪律，给于相关的尊重，于是她创造了Software Engineering这个词。2018年，<a href="https://www.computer.org/csdl/magazine/so/2018/05" target="_blank" rel="noopener noreferrer">IEEE在纪念软件工程50周年</a>的时候，他们把 Hamilton 请过去讲了一个叫 <a href="https://ieeexplore.ieee.org/document/8409915" target="_blank" rel="noopener noreferrer">What the Errors Tell Us</a> 的主题。她绝对可以称得上是程序员的Pioneer。</p>
<p>三年前，Apollo的源代码被开源时候，Twitter有个叫 Lin Clark 的人发了一条推：“我妈50年前的代码被放到Github上了”，虽然，她不是 Hamilton 的女儿，但她妈妈也是Apollo其中一个程序员，现在Lin Clark同样也是一个程序员，目前在 Mozilla工作，Staff Engineer，专长 <span class="lt-line-clamp__line">WebAssembly, Rust, 和 JavaScript</span> ，也是个非常厉害的程序，Youtube上各种演讲，也是一个跟他妈妈一样牛的人。</p>
<p>当她在Twitter上这么自豪地发了一条这样的推后，我不知道各位有什么想法？想不想你的后代在未来也会这样自豪的发条微博？<br />
<img decoding="async" loading="lazy" class="aligncenter size-full" src="https://coolshell.cn/wp-content/uploads/2019/07/Lin-Clark-e1563706128853.jpg" alt="" width="400" height="629" /></p>
<p>&nbsp;</p>
<p>最后，尤其是想对那些到Apollo源代码的issue里发spam垃圾信息的人说一下，你看看人家，再看看你们自己，你们是不是想让你们的孩子在登月100周年纪念的时候说——50年前我爹那个傻叉在Apollo的github的issue列表时写了些垃圾，还以为自己多机灵？！</p>
<p>（全文完）<!--



<p align="center"><a href= target=_blank><img decoding="async" src=""></a></p>





<p align="center"><img decoding="async" src="https://coolshell.cn/wp-content/uploads/2020/03/coolshell.weixin.jpg"> <img decoding="async" loading="lazy" src="https://coolshell.cn/wp-content/uploads/2020/03/coolshell.mini_.jpg" width="300" height="300"> <br />关注CoolShell微信公众账号和微信小程序</p>

 

--></p>
<div style="margin-top: 15px; font-size: 16px;color: #cc0000;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 &#8211; CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>

<div class="wp_rp_wrap  wp_rp_vertical_m" ><div class="wp_rp_content"><h3 class="related_post_title">相关文章</h3><ul class="related_post wp_rp"><li ><a href="https://coolshell.cn/articles/12052.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/plugins/wordpress-23-related-posts-plugin/static/thumbs/29.jpg" alt="Leetcode 编程训练" width="150" height="150" /></a><a href="https://coolshell.cn/articles/12052.html" class="wp_rp_title">Leetcode 编程训练</a></li><li ><a href="https://coolshell.cn/articles/8387.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2012/10/Learnable_Programming-150x150.jpg" alt="Bret Victor &#8211; Learnable Programming" width="150" height="150" /></a><a href="https://coolshell.cn/articles/8387.html" class="wp_rp_title">Bret Victor &#8211; Learnable Programming</a></li><li ><a href="https://coolshell.cn/articles/22298.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2022/10/communication-150x150.png" alt="聊聊团队协同和协同工具" width="150" height="150" /></a><a href="https://coolshell.cn/articles/22298.html" class="wp_rp_title">聊聊团队协同和协同工具</a></li><li ><a href="https://coolshell.cn/articles/22173.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2022/02/http_method-150x150.png" alt="“一把梭：REST API 全用 POST”" width="150" height="150" /></a><a href="https://coolshell.cn/articles/22173.html" class="wp_rp_title">“一把梭：REST API 全用 POST”</a></li><li ><a href="https://coolshell.cn/articles/22157.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2022/02/monitoring-150x150.jpeg" alt="谈谈公司对员工的监控" width="150" height="150" /></a><a href="https://coolshell.cn/articles/22157.html" class="wp_rp_title">谈谈公司对员工的监控</a></li><li ><a href="https://coolshell.cn/articles/21589.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2021/07/knowledge_sharing-300x169-1-150x150.jpeg" alt="如何做一个有质量的技术分享" width="150" height="150" /></a><a href="https://coolshell.cn/articles/21589.html" class="wp_rp_title">如何做一个有质量的技术分享</a></li></ul></div></div>The post <a href="https://coolshell.cn/articles/19612.html">50年前的登月程序和程序员有多硬核</a> first appeared on <a href="https://coolshell.cn">酷 壳 - CoolShell</a>.]]></content:encoded>
					
					<wfw:commentRss>https://coolshell.cn/articles/19612.html/feed</wfw:commentRss>
			<slash:comments>70</slash:comments>
		
		
			</item>
		<item>
		<title>StackOverflow 2019 程序员调查</title>
		<link>https://coolshell.cn/articles/19307.html</link>
					<comments>https://coolshell.cn/articles/19307.html#comments</comments>
		
		<dc:creator><![CDATA[陈皓]]></dc:creator>
		<pubDate>Sun, 21 Apr 2019 04:29:13 +0000</pubDate>
				<category><![CDATA[业界新闻]]></category>
		<category><![CDATA[技术读物]]></category>
		<category><![CDATA[杂项资源]]></category>
		<category><![CDATA[编程语言]]></category>
		<category><![CDATA[Programmer]]></category>
		<category><![CDATA[程序员]]></category>
		<guid isPermaLink="false">https://coolshell.cn/?p=19307</guid>

					<description><![CDATA[<p>前些天，StackOverflow 发布了 2019年的年度程序员调查，这个调查报查有90000名程序员参与，这份调度报告平均花了20分钟，可见，这份报告有很多...</p>
<p class="read-more"><a class="btn btn-default" href="https://coolshell.cn/articles/19307.html"> Read More<span class="screen-reader-text">  Read More</span></a></p>
The post <a href="https://coolshell.cn/articles/19307.html">StackOverflow 2019 程序员调查</a> first appeared on <a href="https://coolshell.cn">酷 壳 - CoolShell</a>.]]></description>
										<content:encoded><![CDATA[<p><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3415450859608158"
     crossorigin="anonymous"></script><img decoding="async" class="alignright " src="https://coolshell.cn/wp-content/uploads/2019/04/2019-Dev-Survey-Blog-360x200.png" alt="" />前些天，StackOverflow 发布了 <a href="https://insights.stackoverflow.com/survey/2019" target="_blank" rel="noopener noreferrer">2019年的年度程序员调查</a>，这个调查报查有90000名程序员参与，这份调度报告平均花了20分钟，可见，这份报告有很多的问题，也是很详细的。这份报告有一些地方，让我有了一些思考。</p>
<p>首先，我们先来看一下之份报告的 Key Results：</p>
<ul>
<li>Python 成为了过去一年中成长最快的语言，把Java挤到了第二位，排在后面的是Rust语言。</li>
<li>有半数以上的被访者在是在16岁写下自己的第一行代码。</li>
<li><a href="https://stackoverflow.com/jobs/devops-jobs" target="_blank" rel="noopener noreferrer">DevOps Specialists</a> 和 Site Reliability Engineers 是程序员中最有经验，技术最牛，薪资最好的职位。（这对应于国内的——系统架构师）</li>
<li>在几个头部的程序员大国中，中国的程序员最乐观的，他们相信在今天出生的人会有比他们父母更好的人生。对于欧洲的程序员来说，比较法国和德国的程序员，他们对未来并不太乐观。</li>
<li>对于最影响程序员生产力的事，不同的程序员有不同的想法。</li>
</ul>
<p><span id="more-19307"></span></p>
<h4 id="toc_1">第一部分，Developer Profile</h4>
<p>在第一部分中，我们可以看到，中国程序员参与这个调查的并不多，程序员主要集中在美国、欧洲、印度这三个地方。所以，这份报告更偏国际上一些。这对于我们中国程序员也有很大的帮助，因为一方面可以看到世界发展的趋势，另一方面也可以了解我们和世界有什么不一样。</p>
<p>对于技术职业来说，整个世界的程序员开始趋于全栈和后端，有51.9%的人是全栈，50%的人是后端，32.8%的人是前端……在这些人中，很多程序员都选了多项，中位数是3项，最常见是前端、后端和全栈全选的。然后，接下来是选两项的，选两项目的包括：数据库管理员和系统管理员，DevOps Specialist 和 Site Reliablility Engineer， 学术研究者和科学家，设计师和前端工程师。<img decoding="async" loading="lazy" class="aligncenter wp-image-19308 " src="https://coolshell.cn/wp-content/uploads/2019/04/06-01.Developers.Rols_-1024x259.png" alt="" width="648" height="137" /></p>
<p>从这些数据中我们可以看见：<strong>前后端的界限越来越不明显，设计师和前端的界限也开始模糊。这应该说明，工具和框架的成熟，让后端程序员和设计师也可以进入到前端工程师的领域，或是前端工程师开始进入后端和设计的领域</strong>。总之，复合型人才越来越越成为主流，而前后端也趋于一个相互融合的态势。</p>
<p>在接下来的图表中，我们可以看到有80%以上的人是把编程当成自己的爱好（包括相关的女性）。<img decoding="async" loading="lazy" class="aligncenter " src="https://coolshell.cn/wp-content/uploads/2019/04/06-02.Coding.as_.a.Hobby_.png" alt="" width="410" height="71" /></p>
<p>真是应了那句话——“Programmers who don’t code in their spare time for fun will never become as good as those that do”，是的，如果你对编程没有感到一种快乐，没有在你空闲的时候去以一种的兴趣爱好方式去面对，那么，无论是编程，还是运动，还是去旅游，都不会有太多成效的。</p>
<p>在接下来的编程经验上，有两组如下的数据：</p>
<table>
<thead>
<tr>
<th>学习编程的年限</th>
<th>编程的年限</th>
</tr>
</thead>
<tbody>
<tr>
<td><img decoding="async" loading="lazy" class="aligncenter wp-image-19310 " src="https://coolshell.cn/wp-content/uploads/2019/04/06-03.Years_.Since_.Learning.to_.Code_.png" alt="" width="376" height="272" /></td>
<td><img decoding="async" loading="lazy" class="aligncenter wp-image-19311 " src="https://coolshell.cn/wp-content/uploads/2019/04/06-04.Years_.Coding.Professionally.png" alt="" width="372" height="242" /></td>
</tr>
</tbody>
</table>
<p>我们可以看到无论是学习还是编程，随着时间的拉长，其人数占比越来越少。</p>
<p>下面我们再来看一个年龄图：</p>
<p><img decoding="async" loading="lazy" class="aligncenter wp-image-19312 " src="https://coolshell.cn/wp-content/uploads/2019/04/06-05.Age_-1024x710.png" alt="" width="499" height="270" /></p>
<p>调查报告从20岁开始每隔5年划分一个年龄段，我们不难发现从25-29岁开始每个年龄段都比前一个年龄段人数急剧减少大约30-50%，比如25-29年龄段占总人数27.6%，而30-34则只有19.3%。以此类推，到60岁以上，就只剩1%。可以看出5年是大多数程序员的转型周期。这是合理的，因为5年时间足够一个人积累足够的经验技能为职业转型做准备。</p>
<p>我们也可以看到50岁以上的程序员只有4.2%，大约是参与调查人员的300多人，如果这些人20岁左右参加工作，那么说明他们在1990左右就开始写代码，事实上那个时间点别说是程序员了，连电脑用户都不多。<strong>电脑和互联网真正暴发的时间还是在1995年 &#8211; 2000年之间，不过，那个时间点程序员的总体人数也不多，而行业越来越火才会导致大量的人进入到这个行业中，这个转换过程基本上去需要3-5年，也就是从2000年后才开始有大量的人拥入程序员这个行业，程序员的人数在过去30年间也是呈增涨态势的，所以，我个人认为，所谓的“众多老程序员”的比例会被2005年以后大量拥入程序员行业的年青人所“稀释”。所以，上图的比例不能完全说明程序员是个青春饭</strong>。</p>
<p>但是，我们还是要正视老牌资深的程序员越来越少的这个事实，在这份报告第三部分中说了一些和程序员职业生涯相关的调查，如下：</p>
<ul>
<li><strong>在被问到有多少人对自己的职业满意的时</strong>。有40%的人觉得很满意，而有34.3%的人觉得一般满意，有10%的人说不清，还有15%的人是不满意的。可以看到有不少人是对这个职业生涯是有想法的。</li>
<li><strong>在被问到有多少人想转管理而可以挣得更多时</strong>。有30%的人是说想转的，有51%的人是明确不转的，还有20%的人是说不知道。可见，想转管理的人最多可能会有一半的人。</li>
<li><strong>在被问到有多少人想转管理时</strong>。有1/3的人是明确不想转的，而有1/4的人是明确是想转，而有36%的人则是不说，观望中。可见，的确是有很多想想转管理的。</li>
</ul>
<p><strong>我们可以看到，程序员中并不是所有的人都是可以坚持这么长时间的，这也挺正常的，对很大一部分人来说，对这个职业是有或多或少的不满意的，也有一部分人可能会随着技术的更新被淘汰，还有另外很大一部分人是想转管理的。所以，能够长时间地跟上形势长时间地喜欢写代码，并且对程序员这个的职业长期满意，不想转管理的，的确是为随时年龄的越大也越来越少</strong>。</p>
<p><strong>但我们完全可以看出来，程序员的主力军在20-40岁这个区间，而30岁左右的程序员是年富力强（经验和能力都很好）的黄金时间</strong>。</p>
<p>老程序员在国外似乎不会存在多大的问题，但在国内会有一些问题，所以，对于像我一样喜欢写代码、打算长久做程序员的兄弟，这里分享一些相关的经验。</p>
<ol>
<li><strong>持续高效地学习</strong>。软件行业的新技术层出不穷，旧的技术淘汰很快，所以我们更要多多学习基础技术和原理，那些都是很难改变的，并且基础扎实了后，学习新的技术也才会更快速。其间我们也不要乱学新技术，我们要关注那些有潜力的技术，也就看准了再学（参看酷壳的《<a href="https://coolshell.cn/articles/18190.html">Go语言、Docker和新技术</a>》）。注意，而是跟上大时代已经比较不容易，引领时代的人还是少数，所以，还是要更为高效地学习。</li>
<li><strong>积极面对他人的不解</strong>。 很多时候，总是会有人说：“到了你这个年纪怎么还在做程序员？”，这句话感觉就是对程序员这个职业的一种羞辱，社会的价值观感觉容不下大龄程序员。这个时候，我一般会跟他们解释到，我40来岁了，我觉得自己的状态还很好，工作完成没什么问题，偶尔加班到凌晨也行，新知识和技术我学起来不比年轻人慢，我在这个年纪有的经验比他们都多，而且，我这个年纪还在写代码，说明我真的喜欢这个事，<strong>像我这样的人能够长时间坚持做一个职业的人这个世界已经不多了，你们应该珍惜……</strong></li>
<li><strong>找到自己的定位</strong>。我们需要做好职业规划、财务和心理方面的准备。40岁的程序员，所能竞争的一定是自己的认识和经验，所以，40岁以后如果你还是很喜欢这一行业，你的社会阅历和经历以及对这个社会的理解，可以让你做一些有创新的事，除此之外，你还可以做一个教练、老师、咨询、专家……，用你的经验和能力帮助下一代和一些中小型的公司，这不但是他们的刚需，同时也会让重新焕发的。</li>
</ol>
<h4 id="toc_2">第二部分，技术</h4>
<p>首先，在这部分，主要是了解一些技术，这部分的技术可以给于程序员们一些指导。</p>
<table>
<thead>
<tr>
<th>最流行的语言</th>
<th>最热门的语言</th>
</tr>
</thead>
<tbody>
<tr>
<td><img decoding="async" loading="lazy" class="aligncenter wp-image-19313" src="https://coolshell.cn/wp-content/uploads/2019/04/06-06.Popular.Languages-669x1024.png" alt="" width="377" height="709" /></td>
<td><img decoding="async" loading="lazy" class="aligncenter wp-image-19314" src="https://coolshell.cn/wp-content/uploads/2019/04/06-07.Loved_.Languages-679x1024.png" alt="" width="367" height="743" /></td>
</tr>
</tbody>
</table>
<p>我们可以看到，</p>
<ul>
<li>Javascript/HTML/CSS是很多人都会用到的，后面的是SQL，这个也没什么问题，无论前后端的人，或多或少都会要用到的，这些技术感觉已经成为了基础必会的技术了，就像数中的加减乘除一样。</li>
<li>Python/Java/Shell 是后端开发主流语言的前三强，Python在今年超过了Java。这里让我比较好奇的是居然还有很多人用Shell，这估计跟运维有关，所以，Python的热可能也是通过运维和大数据相关。</li>
<li>流行语言后，第二梯队的是 C# / PHP / C++ / TypeScript / C ，接下来的是： Ruby / Go / Swift / Kotlin /WebAssembly / Rust&#8230; 。但在最被程序员喜欢的编程语言中：Rust / Python / TypeScript / Koltin / WebAssembly / Swift / Go&#8230; 都是排在前几名的。<strong>程序语言每隔一段时间就会整出一些新的语言来，我们一定要明白新出来的东西主要是为了解决什么样的问题，不然很容易迷失。</strong></li>
<li>在后面还有一个编程语言的薪资图，我们可以看到，在上面被提过的这些个编程语言中，<strong>Go语言的薪资是最高的（这可能是因为Go语言写关键的系统级的中件间——因为Go语言正在成为云计算的第一编程语言）</strong>，然后是Scala、Ruby、WebAssembly、Rust、Erlang、Shell、Python、Typescript……</li>
</ul>
<p><strong>通过这些个信息，我们可以看出主流技术、有潜力的技术，传统过气技术，以及相关薪资，对我们在选择编程语言上有一定的启示。</strong></p>
<p>在后面，我们可以看到:</p>
<ul>
<li>在 Web 开发框架上，主流使用还是 jQuery, React.js，Angular.js 为最前面的三个前端开发框架。而被程序员所喜欢的则是 React.js，Vue.js，Express, Spring，程序员非常不喜欢 Drupal，jQuery，Ruby on Rails 和Angular.js……</li>
<li>在其它开发框架/库/工具上，主流是Node.js、.NET、Pandas、Unity 3D、Tensorflow、Ansible、Cordova、Xamarin……而程序员比较喜欢的是.NET、Torch/PyTorch、Flutter、Pandas、Tensorflow、Node.js &#8230;</li>
<li>在操作系统上，主流使用Linux、Windows、Docker、Android、AWS……，而程序员最喜欢的是Linux、Docker、Kubernetes、Raspberry Pi、AWS、MacOS、iOS……</li>
<li>在数据库上，MySQL、PostgreSQL、MSSQL、SQLite、MongoDB、Redis、Elasticsearch是比较主流的，而程序员非常喜欢的是，Redis、PostgreSQL、Elasticsearch、Firebase、MongoDB……，程序员比较讨厌的是 Couchbase、Oracle、Cassandra、MySQL。</li>
</ul>
<p><strong>从这些个图表中，我们可以看到主流和有潜力的技术是什么，我们可以看到 Windows 的技术并没有过时，感觉似乎都有可能会卷土重来，但是，开源的技术来势凶凶，正在吞食整个软件业，不容小觑，Docker/Kubernetes无论是在主流应用上还是被程序员的喜好上都是非常猛的，而云平台的AWS开始成为标准平台技术……</strong></p>
<p>接下来的开发工具中，我们可以看到：</p>
<ul>
<li>Visual Studio Code 成为了最流行的开发工具。让我没有想到的是跟在后面的是 Notepad++（好久没用这个工具了，我得找回来用用了），而IntelliJ、Vim、Sublime Text排以后面。 Eclipse 和 Atom 动力不足，Emacs 开始变得小众了。</li>
<li>程序员主要的开发平台还是Windows占了近1/2， MacOS和Linux随后，各占1/4。</li>
<li>有38%的人使用容器技术做开发，30%的人使用容器做测试，在生产线上使用容器的有26%</li>
</ul>
<p><strong>看样子编程开发工具还是Visual Studio 和 IntelliJ的天下，MacOS/Linux正在抢Windows的开发市场</strong></p>
<p>接下来，StackOverflow给了一个技术圈的图</p>
<p><img decoding="async" loading="lazy" class="aligncenter" src="https://coolshell.cn/wp-content/uploads/2019/04/06-08.Technology.Circle-1024x1024.png" alt="" width="640" height="640" /></p>
<p>从上面这个图中，我们可以看以技术的几圈子：</p>
<ul>
<li><strong>Microsoft圈</strong> &#8211; Windows、.NET、ASP.NET、C#、Azure、SQL Server</li>
<li><strong>Java圈</strong> &#8211; Java、Spring</li>
<li><strong>手机圈</strong> &#8211; Android、 iOS、Kotlin、Swift、Firebase</li>
<li><strong>前端圈</strong> &#8211; Javascript、React.js、Angular.js、PHP</li>
<li><strong>大数据圈</strong> &#8211; Python、TensorFlow、Torch/PyTorch</li>
<li><strong>基础平台圈</strong> &#8211; Linux、Shell、Vim、Docker、Kubernetes、Elasticsearch、Redis……</li>
<li><strong>其它圈子</strong> &#8211; C/C++/汇编圈子、Ruby圈子、Hadoop/Spark圈子、……</li>
</ul>
<p><strong>看到谁的圈子大了吧，圈子大的并不代表技术实力强或是有前途，不过可以代表在那个圈子相关的关联技术，一方面，可以给你一些相关的参考，另一方面，整体可以让你看到全部的目前比较主流的技术。</strong></p>
<h4 id="toc_3">第三部份 工作</h4>
<p>在第三部份工作中，我们可以看到如下的一些数据：</p>
<ul>
<li>有3/4的程序员是全职的，10%左右的程序员是自由职业，6%左右的程序员是失业的，这个比例在北美、印度和欧洲都差不多。</li>
<li>有1/3的人在过去一年内换过工作，1/4的人在过去1-2年间换过工作，1/3的人在2-4年换过工作。</li>
<li>程序员找工作时，影响程序员的几个主要因素是：技术（编程语言、框架和使用的技术）、办公环境和公司文化、灵活的时间和安排、更专业的机会、远程工作……</li>
<li>影响程序员工作的几大因素是：有干扰的工作环境、开会、要干一些和开发无关的事、人手不够、管理不够、工具不够、通勤时间……</li>
<li>对于工程质量，有近70%的人有Code Review，而30%的则没有；有60%多的人有Unit Test，而不到40%的没有……</li>
</ul>
<p><strong>从工作中我们可以看到，程序员还是比较关心技术和公司文化的，换工作也是这个职业很正常的特性，他们并不喜欢被打扰，希望有足够的时间，而对于工程质量还是很有追求的。</strong></p>
<p>最后用一张程序员的“<strong>每周工作时间</strong>” 来结束本文！</p>
<p><img decoding="async" loading="lazy" class="aligncenter " src="https://coolshell.cn/wp-content/uploads/2019/04/07-09.Hours_.Worked.Per_.Week_-1024x640.png" alt="" width="498" height="280" /></p>
<p>祝大家快乐！</p>
<p>（全文完）<!--



<p align="center"><a href= target=_blank><img decoding="async" src=""></a></p>





<p align="center"><img decoding="async" src="https://coolshell.cn/wp-content/uploads/2020/03/coolshell.weixin.jpg"> <img decoding="async" loading="lazy" src="https://coolshell.cn/wp-content/uploads/2020/03/coolshell.mini_.jpg" width="300" height="300"> <br />关注CoolShell微信公众账号和微信小程序</p>

 

--></p>
<div style="margin-top: 15px; font-size: 16px;color: #cc0000;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 &#8211; CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>

<div class="wp_rp_wrap  wp_rp_vertical_m" ><div class="wp_rp_content"><h3 class="related_post_title">相关文章</h3><ul class="related_post wp_rp"><li ><a href="https://coolshell.cn/articles/22298.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2022/10/communication-150x150.png" alt="聊聊团队协同和协同工具" width="150" height="150" /></a><a href="https://coolshell.cn/articles/22298.html" class="wp_rp_title">聊聊团队协同和协同工具</a></li><li ><a href="https://coolshell.cn/articles/22173.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2022/02/http_method-150x150.png" alt="“一把梭：REST API 全用 POST”" width="150" height="150" /></a><a href="https://coolshell.cn/articles/22173.html" class="wp_rp_title">“一把梭：REST API 全用 POST”</a></li><li ><a href="https://coolshell.cn/articles/22157.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2022/02/monitoring-150x150.jpeg" alt="谈谈公司对员工的监控" width="150" height="150" /></a><a href="https://coolshell.cn/articles/22157.html" class="wp_rp_title">谈谈公司对员工的监控</a></li><li ><a href="https://coolshell.cn/articles/21589.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2021/07/knowledge_sharing-300x169-1-150x150.jpeg" alt="如何做一个有质量的技术分享" width="150" height="150" /></a><a href="https://coolshell.cn/articles/21589.html" class="wp_rp_title">如何做一个有质量的技术分享</a></li><li ><a href="https://coolshell.cn/articles/20977.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2020/08/programmer.01-e1596792460687-150x150.png" alt="程序员如何把控自己的职业" width="150" height="150" /></a><a href="https://coolshell.cn/articles/20977.html" class="wp_rp_title">程序员如何把控自己的职业</a></li><li ><a href="https://coolshell.cn/articles/20765.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2020/01/remote-150x150.jpg" alt="MegaEase的远程工作文化" width="150" height="150" /></a><a href="https://coolshell.cn/articles/20765.html" class="wp_rp_title">MegaEase的远程工作文化</a></li></ul></div></div>The post <a href="https://coolshell.cn/articles/19307.html">StackOverflow 2019 程序员调查</a> first appeared on <a href="https://coolshell.cn">酷 壳 - CoolShell</a>.]]></content:encoded>
					
					<wfw:commentRss>https://coolshell.cn/articles/19307.html/feed</wfw:commentRss>
			<slash:comments>19</slash:comments>
		
		
			</item>
		<item>
		<title>程序员练级攻略（2018)  与我的专栏</title>
		<link>https://coolshell.cn/articles/18360.html</link>
					<comments>https://coolshell.cn/articles/18360.html#comments</comments>
		
		<dc:creator><![CDATA[陈皓]]></dc:creator>
		<pubDate>Tue, 29 May 2018 04:38:23 +0000</pubDate>
				<category><![CDATA[技术读物]]></category>
		<category><![CDATA[杂项资源]]></category>
		<category><![CDATA[C++]]></category>
		<category><![CDATA[Java]]></category>
		<category><![CDATA[Javascript]]></category>
		<category><![CDATA[Linux]]></category>
		<category><![CDATA[Programmer]]></category>
		<category><![CDATA[Python]]></category>
		<category><![CDATA[React]]></category>
		<category><![CDATA[Unix]]></category>
		<category><![CDATA[Web]]></category>
		<category><![CDATA[分布式]]></category>
		<category><![CDATA[程序员]]></category>
		<guid isPermaLink="false">https://coolshell.cn/?p=18360</guid>

					<description><![CDATA[<p>写极客时间8个月了，我的专栏现在有一定的积累了，今天想自己推荐一下。因为最新的系列《程序员练级攻略（2018）版》正在连载中，而且文章积累量到了我也有比较足的自...</p>
<p class="read-more"><a class="btn btn-default" href="https://coolshell.cn/articles/18360.html"> Read More<span class="screen-reader-text">  Read More</span></a></p>
The post <a href="https://coolshell.cn/articles/18360.html">程序员练级攻略（2018)  与我的专栏</a> first appeared on <a href="https://coolshell.cn">酷 壳 - CoolShell</a>.]]></description>
										<content:encoded><![CDATA[<p><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3415450859608158"
     crossorigin="anonymous"></script><img decoding="async" loading="lazy" class="alignright size-medium" src="https://coolshell.cn/wp-content/uploads/2018/05/专栏-300x262.jpg" alt="" width="300" height="262" />写极客时间8个月了，我的专栏现在有一定的积累了，今天想自己推荐一下。因为最新的系列《程序员练级攻略（2018）版》正在连载中，而且文章积累量到了我也有比较足的自信向大家推荐我的这个专栏了。推荐就从最新的这一系统的文章开始。</p>
<p>2011年，我在 <a href="https://coolshell.cn/">CoolShell</a> 上发表了 《<a href="https://coolshell.cn/articles/4990.html">程序员技术练级攻略</a>》一文，得到了很多人的好评（转载的不算，在我的网站上都有近1000W的访问量了）。并且陆续收到了一些人的反馈，说跟着这篇文章找到了不错的工作。几年过去，也收到了好些邮件和私信，希望我把这篇文章更新一下，因为他们觉得有点落伍了。是的，<strong>老实说，抛开这几年技术的更新迭代不说，那篇文章写得也不算特别系统，同时标准也有点低，当时是给一个想要入门的朋友写的，所以，非常有必要从头更新一下《程序员练级攻略》这一主题</strong>。</p>
<p>目前，我在我极客时间的专栏上更新《程序员练级攻略（2018版）》。升级版的《程序员练级攻略》会比Coolshell上的内容更多，也更专业。这篇文章有【入门篇】、【修养篇】、【专业基础篇】、【软件设计篇】、【高手成长篇】五大篇章，它们会帮助你从零开始，一步步地，系统地，从陌生到熟悉，到理解掌握，从编码到设计再到架构，从码农到程序员再到工程师再到架构师的一步一步进阶，完成从普通到精通到卓越的完美转身……</p>
<p>这篇文章是我写得最累也是最痛苦的文章，原因如下：</p>
<ul>
<li> <strong>学习路径的梳理</strong>。这是一份计算编程相关知识地图，也是一份成长和学习路径。所以有太多的推敲了，知识的路径，体，地图……这让我费了很多工夫，感觉像在编写一本教材一样，即不能太高大上，也不能误人子弟。</li>
<li><strong>新旧知识的取舍。</strong>另外，因为我的成长经历中很多技术都成了过去时，所以对于新时代的程序员应该学习新的技术，然后，很多基础技术在今天依然管用，所以，在这点上，哪些要那些不要，也花了我很多的工夫。</li>
<li><strong>文章书籍的推荐</strong>。为了推荐最好的学习资料和资源，老实说，我几乎翻遍了整个互联网，进行了大量的阅读和比较。这个过程让我也受益非浅。一开始，这篇文章的大小居然在500K左右，太多的信息就是没有信息，所以在信息的筛选上我花费了很多的工夫，删掉了60%的内容。但是，依然很宠大。</li>
</ul>
<p><strong>总之，你一定会被这篇文章的内容所吓到的，是的，我就是故意这样做的，因为，这本来就没有什么捷径，也不可能速成，很多知识都是硬骨头，你只能一口一口的啃，我故意这样做就是为了让你不要有“速成”的幻想，也可以轻而一举的吓退那些不想用功不想努力的人</strong>。</p>
<p>但是，我们也要知道《易经》有云：“<strong>取法其上，得乎其中，取法其中，得乎其下，取法其下，法不得也</strong>”。所以，我这里会给你立个比较高标准，你要努力达到，相信我，就算是达不到，也会比你一开始期望的要高很多……</p>
<p>下面是这份练级攻略的目录，目前只在极客时间上发布，你需要付费阅读（在本文最后有相关的二维码）。</p>
<p><span id="more-18360"></span></p>
<p><img decoding="async" loading="lazy" class="alignnone size-full aligncenter" src="https://coolshell.cn/wp-content/uploads/2018/05/程序员练级攻略.png" alt="" width="290" height="1937" /></p>
<p>&nbsp;</p>
<p>那么，除程序员练级攻略外，我还写了哪些内容？下面是迄今为止我所有的文章的目录。你可以在下面看一下相关的目录。这也算是我开收费专栏来8个月给大家的一份答卷吧。我也没有想到，我居然写了这么多的文章，而且对很多人都很有用。</p>
<p>首先是个人成长和经验之谈的东西，在这里的文章还没有完全更新完，未来要更新什么我也不清楚，但是可以呈现出来的内容和方向如下所示，供你参考。对于个人成长中的内容，都是我多年来的心得和体会，从读者的反馈来看是非常不错的，你一定要要阅读的。</p>
<p><img decoding="async" loading="lazy" class="alignnone size-large aligncenter" src="https://coolshell.cn/wp-content/uploads/2018/05/个人成长和经验之谈-319x1024.png" alt="" width="319" height="1024" /></p>
<p>分布式系统架构，我一共出了两个系列，一个是分布式系统架构的本质，另一个是设计模式。前者偏概念，后者偏技术。这里旨在让你看到整个分布式系统设计的一个非常系统的蓝图，但是因为在手机端上，不可能写得非常细，所以，会缺失一些细节，这些细节我是故意缺失的，主要是有几方面的原因，</p>
<ul>
<li>一方面，这是为了阅读的效果，手机上的文章不过长，所以，不能有太多的细节。</li>
<li>另一方面，也是是想留给大家自行学习，而不是一定要我把饭喂到你的嘴里，你才能吃得着。<strong>学习不只是为要答案，而是学方法</strong></li>
<li>最后是我的私心，因为我也在创业，所以，技术细节上东西正是我在做的产品，所以，如果你想了解得更细，你需要和我有更商业合作。</li>
</ul>
<p><img decoding="async" loading="lazy" class="alignnone size-full aligncenter" src="https://coolshell.cn/wp-content/uploads/2018/05/分布式架构的本质.png" alt="" width="321" height="689" /></p>
<p>&nbsp;</p>
<p><img decoding="async" loading="lazy" class="alignnone  size-full aligncenter" src="https://coolshell.cn/wp-content/uploads/2018/05/分布式架构设计模式-弹力篇.png" alt="" width="331" height="1065" /></p>
<p><img decoding="async" loading="lazy" class="alignnone  size-full aligncenter" src="https://coolshell.cn/wp-content/uploads/2018/05/分布式架构设计模式-管理篇.png" alt="" width="353" height="669" /></p>
<p><img decoding="async" loading="lazy" class="alignnone  size-full aligncenter" src="https://coolshell.cn/wp-content/uploads/2018/05/分布式架构设计模式-性能篇.png" alt="" width="328" height="592" /></p>
<p>区块链的技术专栏本来不在我的写作计划中的，但是因为来问我这方面的技术人太多了，所以，就被问了一系列的文章，这里的文章除了一些技术上的科普，同样有有很多我的观点，你不但可以学到技术，还可以了解一些金融知识和相关的逻辑，我个人觉得这篇文章是让你有独立思考的文章。</p>
<p><img decoding="async" loading="lazy" class=" size-full alignnone aligncenter" src="https://coolshell.cn/wp-content/uploads/2018/05/区块链技术.png" alt="" width="304" height="771" /></p>
<p>我的专栏还在继续，接下来还有一个系列的文章——《从技术到管理》，欢迎关注，也欢迎扫码订阅。</p>
<p><strong>最后友情提示一下：在手机上学习并不是最好的学习方式，也不要在我的专栏上进行学习，把我的专栏当成一个你的助手，当成一个向导，当成一个跳板，真正的学习还是要在线下，专心的，系统地、有讨论地、不断实践地学习，这点希望大家切记！</strong></p>
<p>&nbsp;</p>
<p><img decoding="async" loading="lazy" class="aligncenter size-full " src="https://coolshell.cn/wp-content/uploads/2018/05/专栏.jpg" alt="" width="665" height="580" /></p>
<p>（全文完）<!--



<p align="center"><a href= target=_blank><img decoding="async" src=""></a></p>





<p align="center"><img decoding="async" src="https://coolshell.cn/wp-content/uploads/2020/03/coolshell.weixin.jpg"> <img decoding="async" loading="lazy" src="https://coolshell.cn/wp-content/uploads/2020/03/coolshell.mini_.jpg" width="300" height="300"> <br />关注CoolShell微信公众账号和微信小程序</p>

 

--></p>
<div style="margin-top: 15px; font-size: 16px;color: #cc0000;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 &#8211; CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>

<div class="wp_rp_wrap  wp_rp_vertical_m" ><div class="wp_rp_content"><h3 class="related_post_title">相关文章</h3><ul class="related_post wp_rp"><li ><a href="https://coolshell.cn/articles/4990.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2011/07/programmer-150x150.png" alt="程序员技术练级攻略" width="150" height="150" /></a><a href="https://coolshell.cn/articles/4990.html" class="wp_rp_title">程序员技术练级攻略</a></li><li ><a href="https://coolshell.cn/articles/8088.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/plugins/wordpress-23-related-posts-plugin/static/thumbs/7.jpg" alt="对技术的态度" width="150" height="150" /></a><a href="https://coolshell.cn/articles/8088.html" class="wp_rp_title">对技术的态度</a></li><li ><a href="https://coolshell.cn/articles/4102.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/plugins/wordpress-23-related-posts-plugin/static/thumbs/25.jpg" alt="如何学好C语言" width="150" height="150" /></a><a href="https://coolshell.cn/articles/4102.html" class="wp_rp_title">如何学好C语言</a></li><li ><a href="https://coolshell.cn/articles/4758.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/plugins/wordpress-23-related-posts-plugin/static/thumbs/30.jpg" alt="如何写出无法维护的代码" width="150" height="150" /></a><a href="https://coolshell.cn/articles/4758.html" class="wp_rp_title">如何写出无法维护的代码</a></li><li ><a href="https://coolshell.cn/articles/1992.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2009/12/language-fanboys-150x150.jpg" alt="程序员眼中的编程语言" width="150" height="150" /></a><a href="https://coolshell.cn/articles/1992.html" class="wp_rp_title">程序员眼中的编程语言</a></li><li ><a href="https://coolshell.cn/articles/19219.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2019/03/linux.ninja_-150x150.png" alt="打造高效的工作环境 &#8211; Shell 篇" width="150" height="150" /></a><a href="https://coolshell.cn/articles/19219.html" class="wp_rp_title">打造高效的工作环境 &#8211; Shell 篇</a></li></ul></div></div>The post <a href="https://coolshell.cn/articles/18360.html">程序员练级攻略（2018)  与我的专栏</a> first appeared on <a href="https://coolshell.cn">酷 壳 - CoolShell</a>.]]></content:encoded>
					
					<wfw:commentRss>https://coolshell.cn/articles/18360.html/feed</wfw:commentRss>
			<slash:comments>62</slash:comments>
		
		
			</item>
		<item>
		<title>关于我”极客时间“的专栏</title>
		<link>https://coolshell.cn/articles/18246.html</link>
					<comments>https://coolshell.cn/articles/18246.html#comments</comments>
		
		<dc:creator><![CDATA[陈皓]]></dc:creator>
		<pubDate>Tue, 02 Jan 2018 08:56:11 +0000</pubDate>
				<category><![CDATA[技术读物]]></category>
		<category><![CDATA[杂项资源]]></category>
		<guid isPermaLink="false">https://coolshell.cn/?p=18246</guid>

					<description><![CDATA[<p>不少朋友都知道我在“极客时间”上开了一个收费专栏，这个专栏会开设大约一年的时间，一共会发布104篇文章。现在，我在上面以每周两篇文章的频率已发布了27篇文章了，...</p>
<p class="read-more"><a class="btn btn-default" href="https://coolshell.cn/articles/18246.html"> Read More<span class="screen-reader-text">  Read More</span></a></p>
The post <a href="https://coolshell.cn/articles/18246.html">关于我”极客时间“的专栏</a> first appeared on <a href="https://coolshell.cn">酷 壳 - CoolShell</a>.]]></description>
										<content:encoded><![CDATA[<p><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3415450859608158"
     crossorigin="anonymous"></script><img decoding="async" loading="lazy" class="alignright size-medium" src="https://coolshell.cn/wp-content/uploads/2018/01/geekbang-300x300.jpg" alt="" width="300" height="300" />不少朋友都知道我在“<a href="https://time.geekbang.org/" target="_blank" rel="noopener noreferrer">极客时间</a>”上开了一个收费专栏，这个专栏会开设大约一年的时间，一共会发布104篇文章。现在，我在上面以每周两篇文章的频率已发布了27篇文章了，也就是差不多两个半月的时间。新的一年开始了，写专栏这个事对我来说是第一次，在这个过程中有一些感想，所以，我想在这里说一下这些感受和一些相关的故事，算是一个记录，也算是对我专栏的正式介绍，还希望能得到、大家的喜欢和指点。（当然，CoolShell这边还是会持续更新的）</p>
<h4>为什么要开设一个收费专栏</h4>
<p>首先，说一下，为什么要开这个收费专栏。</p>
<p>老实说，我一开始根本就不想开收费专栏的，是的，完全不想！主要是有两个原因，一方面是我在创业中，我自然是没有太多的时间，另一方面是，我以前在《<a href="https://coolshell.cn/articles/17391.html" target="_blank" rel="noopener noreferrer">为什么我不在微信公众号上写文章</a>》也说过，我觉得知识最好的方式是被检索、讨论、引用、整理、补充和更新。所以，收费这种模式，我感觉并不利于很好的传播。但是，我为什么还干了这么一件事？这事还得从2017年6月份开始说起。</p>
<p>这个月，一共有三家技术社区来找我，都是希望我能去他们那边开收费专栏，其中一家就是“极客邦科技”。对于这三家来说，从一开始我就是以婉拒的姿态回应的。而“极客邦科技”来找我的时候和我说，一周写五篇，写一年，一共260篇。我当时心想，“去你的，当我啥呢，你们真以为技术文章好写啊&#8221;？然后，他们问我可以写多少，我说，我现在也就一个月一篇的节奏……</p>
<p><span id="more-18246"></span></p>
<p>然后，就开始了时间漫长的拉锯战。极客邦这边一直从6月份和我谈到9月份，完全就是不达目的不罢休的玩法，其间，每当我说一个问题，他们就会想出一个解，我这边不断地制造不能写下去的问题，他们就不断的给出相应的解。我其实是想让他们知难而退，另外，我也不确定这帮人对于这个事有多上心，因为写技术文章是需要非常认真的态度的，所以，我提出了很多比较苛刻的条件，甚至也很直白的直接拒绝，但是他们完全就跟没有听见似的，不断的想新的方法来让我&#8221;上床&#8221;（对！就是上床，不是上船）。</p>
<ul>
<li>我说，我最多一个月写2-3篇。他们和我说，我们看过了，你写的都是长文，都在5000字左右，一篇可以拆成上下篇，这样就有6篇左右了，然后，你每个月再来两篇文章，一篇是推荐一些资料或资源，一篇是回答读者的问题。这样就有8篇了，一周就可以发2篇了。</li>
</ul>
<ul>
<li>我说，就算是这样，我也没有时间写，我现在创业中，事多得去了，完全没精力投入。然后，他们说，不用你写，我们来帮你写。你去客户那边，叫上我们，你到大会上做分享，叫上我们，你和别人分享，也叫让我们，我们全程录音，然后帮你你整理。然后每周末的时候来找你，和你聊上2个小时。我们把内容做出来，你再精编一下就好了。而且，我们也会帮你分担创业的精力的，我们极客邦/QCon/ArchSummit会帮你的产品做推广、做市场和BD客户……</li>
</ul>
<ul>
<li>我说，就算是这样，我也没时间。他们说，我们还会给你配个编辑，一个不够就配两个，他们会帮你上网查资料，他们都是计算机专业的，一定是懂技术的。不会让你一个人写的。专栏这种事一定是会需要一个小的编辑团队的。</li>
</ul>
<p>他们还甚至在晚上10点左右跑到我家门口来和我谈。这还没完，我继续刁难他们……</p>
<ul>
<li>我说，技术文章相当专业，你们来试试看，于是，我给了一篇极其难读的英文论文，还有一篇技术细节非常晦涩的英文文章，我让他们不要翻译，而是读懂后理解完用自己的话，能够让一般人读懂的话写一下。这两篇文章，就算是对于有多年经验的程序员来说，也是很难读的。结果他们一周后，就搞好了，我读了一下，不算特别好，但是对于他们来说，已经很不错了。</li>
</ul>
<ul>
<li>我又说，我的文章中会有好些代码，有数学公式，在手机上怎么排版？阅读体验不行吧。你们还要做音频，我的文章中如果有代码，有图片，有数据公式，你让音频时怎么读？这不行吧。他们说，数学公式可以用LaTeX搞，代码排版会努力排好，同时也提供网页端的浏览。音频会这样搞，会让编辑把代码、数学公式、图片理解完后用别外的话说出来。也就是说，文章要有两个版本，一个是阅读的版本，一个是给音频师的版本。</li>
</ul>
<p>就这样，这几个月的过程中，我心里面有了一些不一样的感觉。</p>
<ul>
<li>一方面，我觉得这种“不达目的不罢休”的做法让我欣赏。因为我也在创业，创业的过程中有很多难题，也会遇到很多困难和艰辛。而极客邦他们这样的作法我是非常认可，也是非常佩服的，因为，要是换作我，我可能早放弃去寻找其它人了。但是他们没有，他们一直不断地在穷尽一切方法来说服我写专栏。能这样做的人，我觉得这个社会上少之又少，绝大多数人都是畏难和容易退缩的，所以，感觉可以深入交往和合作。</li>
</ul>
<ul>
<li>另外一方面，在整个过程中，我问他们，为什么你们要把这个事做得这么“重”？为什么不做得“轻”一点呢？还要录音频，音频对于技术型的文章里面有一堆坑啊，对于技术文章还有很多无法翻译的英文单词，在计算机的世界里，好多英文单词都是造出来的，音频师怎么读？(后来的确也是这样，我的音频师就把J2EE读成了“J二EE”)，他们的编辑也不知道怎么读，就上Youtube上找相关视频看老外是怎么发音的，然后标注好。而且，我的文章有时候写得太快，经常会有一些小错误，文字好改，但是还要改语音。对于这些，我都觉得好重啊，结果他们说，就是要做个“重的”，就是要做一个别人达不到的标杆，让竞争对手望而却步！</li>
</ul>
<p>对于这两点，是让我很赞的。这样的做事精神和态度让我很佩服，是啊，在Amazon里也常说，要不断地提高标准。而且这让我深入思考了一下，一个事如果想要做好，做到极致，就算再简单的事，也会变成复杂，<strong>这个世界上可能并不存在“轻模式”，只要你想做好，再“轻”的事都会变“重”</strong>。他们的这些做法，让我有了一种同道中人的感觉，人总是会向比自己强的人或是跟自己比较像的人靠近的。我感觉我在创业路上，就是要和这样的人在一起，面对再难的事，都要想尽一切办法解决之，面对再轻的事，都要花心思用重的模式去做好。</p>
<p>而其它两个来找我做同样的事的公司，却没有让我看到他们有这样把事做成的不服输的决心和态度，真是形成了强烈的反差和对比。</p>
<p>于是，我就这样“从”了！这里要点名一下极客邦的两个人——我叫他们作“双蕾”：<strong>司巧蕾</strong> 和 <strong>郭蕾</strong>。（池大大也为极客时间付出了好多，因为大家都认识他了，我就弱化他一下了，嘿嘿）</p>
<h4>这个专栏主要会写什么样的内容</h4>
<p>这是一个收费专栏，一旦收费了，我的压力也大了，因为你要写的内容就一定要能达到可以收费的价值了，不以再像个人博客一样，想写什么就什么。好在我从2003年开始我就在给好多企业做一些商业化的讲座和培训，也给一些公司做过一些商业的咨询和技术方案，包括在过去两年内帮助过一些公司打单。另外，在过去的10年内，我也在技术、职业和成长上帮助过很多年轻人。这些内容，我都没有完整或是具体地写在CoolShell中，所以，我觉得这些内容是可以放在这个收费专栏的。</p>
<p>此外，我在CoolShell上的文章都是不系统的，是碎片式的，还有一些只是知识，还不是认识。而我过去成长的20年，我的经验和知识已经在某些方面形成了比较完整的体系，而且有一些技术也能看到本质上的东西。所以，我觉得这些东西是可以呈现在这个专栏内的，都是非常有商业价值的，一定是可以帮助到大家的。当然，其中的一些东西，不是初级入门的程序员能够看懂的，需要有一定的工作经验和基础知识。</p>
<p>而在我入行的这20年来，我觉得对于一个企业，一个团队，一个个体的程序员来说，有三件事是密不可分，也是相辅相成的，这三件事就是：技术、发展和管理。每个人，每个团队，每个企业，都需要认真地面对技术，不断地挑战新的技术，并且还要非常认真地发展个人和团队，而这些都需要对自我的管理或是对团队和公司的管理才能更高效的达成。</p>
<p>所以，我的专栏会由这三部份构成:</p>
<ul>
<li><strong>技术</strong>。对于技术方面，我不会写太多关于知识点的东西，因为这些知识点大家可以自行Google可以RTFM。我要写就一定是以体系化的，而且要能直达技术的本质。我入行这20年来，我最擅长的是针对各种大规模的系统，所以，我会有2-3个和分布式系统相关的系列文章，然后，我学过也用过好多编程语言，所以，我也会有一系列的关于编程本质的文章，而我对一些基础知识研究的也比较多，所以，还会有一系列的和基础知识相关的文章。当然，其中还会穿插一些其它的技术文章，比如一些热点事件，还有一些经验之谈，包括，我会把我的《<a href="https://coolshell.cn/articles/4990.html" target="_blank" rel="noopener noreferrer">程序员技术练级攻略</a>》在这个专栏里重新再写一遍。这些东西一定会让大家有醍醐灌顶的感觉。</li>
</ul>
<ul>
<li><strong>成长</strong>。在过去这20年中，我感觉得到，很多人都会非常在意自己的成长。所以，我会分享一堆我亲身经历的，也是我自己实验的一定和个人发展相关的文章。比如，像技术变现啊、如何面试、如何选择新的技术、如何学习、如何管理自己的时间、如何管理自己的老板和工作、如何成为一个Leader……这些东西一定会对大家有用。但是，我这里一定不会有速成的东西。一切都是要花时间和精力的。如果你想要速成，你不应该来订阅我的专栏。</li>
</ul>
<ul>
<li><strong>管理</strong>。这20年，我觉得做好技术工作，得做好技术的管理工作，只有管理好了软件工程和技术团队，技术才能发挥出最大的潜力。大多数的技术都是管理上的问题。所以，我会写上一系列的和管理相关的文章，管理三个要素，团队、项目和管理者自己。所以，我会从这三个方面写一系列包括，人员招聘、绩效考核、提升士气、解决冲突、面对变化、沟通说服、项目管理、任何排期、会议、远程管理……等等一系列的文章。这些东西都是我在外企时，接受到的世界顶级管理培训机构培训内容，我会把我的实践写出来分享给大家。这其中一定少不了亚马逊相关的各种实践。这些东西，我和很多公司和大佬都讲过，到目前为止还没有人不赞的。</li>
</ul>
<p>现在，我这个专栏写了快三个月了，第一部分和第二部分已经有一些呈现了。我周末和假期的时间也完全都搭进去了 ;-)。后面的文章还在和我的编辑一起在整理和书写中，我感觉这个专栏只收199一年简直是太便宜了，我有点想涨价的冲动了。哈哈。</p>
<h4>幕后团队</h4>
<p>最后说一下我的专栏编辑——她叫杨爽！以前是CSDN的程序员杂志的编辑，后来去了七牛，现在和我一起做我的这个专栏。她对我的这个专栏上的投入非常大，除了帮助我编辑文章，还要帮音频师标注语气，英文发音，以及音频版的文章，还要深度参与写作，<strong>有的文章我只给了一个大纲，甚至只是一个方向，或是一系列的素材，然后都是她来操刀的，比如“推荐阅读”的文章、还有技术领导力的下篇，基本上是由杨爽来出第一版，然后我再上面再做修改和补充</strong>。她说，写技术文章真是太累了，尤其是帮你编辑你的分布式系列的文章，我基本都把这些技术都看了个大概了。我调侃到，如果你完全搞懂了，你就不用做编辑了，你可以做技术去了，嗯，而且，可以变成架构师了。</p>
<p>另外，她会深度的编辑我的文章，尤其是每篇文章最后的一些总结或是一些问题都是她写的。在我的一篇答疑的文章中，她自己加入了一个观点——“很多事情能做到什么程度，其实在思想的源头就被决定了，因为它会绝大程度地受到思考问题出发点、思维方式、格局观、价值观等因素的影响”，这个观点被读者当成是我的观点，其实，这是杨爽的观点，当然我也很同意。</p>
<p>所以，我的这个专栏离不开杨爽的付出，我和她一般都是在晚上或是周末沟通，因为平时我的时候都被创业的事给占据了。所以，她也只能适配我的时间，但她真的很努力，我能感觉得到她想把文章的质量不断提高的迫切。</p>
<p>关于专栏的音频师，他叫柴巍，是天津广播电台的主持人，一个89年的小伙子，网上他的<a href="http://www.radiotj.com/zcrdd/system/2014/04/16/000472670.shtml" target="_blank" rel="noopener noreferrer">个人信息在这里</a>。他跨界来读这些技术文章的确对他来说非常不容易，因为一方面这文章里讲的这些东西他都看不懂，另外，他也不认识我，我脾气和性格他不知道，所以，他读我的文章里，并不能完全准确地把握相关的语气。这就需要杨爽来帮他标注和调整，有些地方，不断地修改，不断地录，大家知道，录音和写文章不一样，文章要修改很简单，语音要修改就非常麻烦，得把上下文全都一并重新再读一篇，这个过程的确难，杨爽在其中也花费了大量的时间和这个小伙子沟通和调整。</p>
<p>在一开始，有播音腔，也被读者吐槽了，他自己后来一直在调整，目前越来越符合咱们的要求。这个小哥是非常努力和有挑战精神的，他在这个过程中，也是非常信守承诺的。去年12月6日，录分布式系统冰与火那篇文章时，他上午有自己的工作，下午要开会，晚上又有单位活动，他还是活动的主持人，他实在是没有时间了。我也和我的编辑说，算了，先发文章，后面再补音频。但是他还是挤时间把音频录出来了，期间，我还不知情地又修改了一下文章，他又配合修改，直到完全改好。打车去参加活动，还好提前20分钟赶到，没有耽误主持活动。</p>
<p>唠唠叨叨写这么多，也没什么干货！算是一份记录吧。也希望大家能够从我的专栏中看到这个团队的确是在用心做事的，是的，能认识这些人，还能一起合作，在我的人生经历上是非常有价值的事了。</p>
<p>希望大家在新的一年里也能遇到这样的人。我们一起加油！</p>
<p><img decoding="async" loading="lazy" class="aligncenter" src="https://coolshell.cn/wp-content/uploads/2017/12/ride_or_die.jpg" alt="" width="600" height="304" /></p>
<p style="text-align: center;">图片来自：电影《速度与激情》——Ride or Die</p>
<p>&nbsp;</p>
<p>（全文完）</p>
<p>&nbsp;<!--



<p align="center"><a href= target=_blank><img decoding="async" src=""></a></p>





<p align="center"><img decoding="async" src="https://coolshell.cn/wp-content/uploads/2020/03/coolshell.weixin.jpg"> <img decoding="async" loading="lazy" src="https://coolshell.cn/wp-content/uploads/2020/03/coolshell.mini_.jpg" width="300" height="300"> <br />关注CoolShell微信公众账号和微信小程序</p>

 

--></p>
<div style="margin-top: 15px; font-size: 16px;color: #cc0000;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 &#8211; CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>

<div class="wp_rp_wrap  wp_rp_vertical_m" ><div class="wp_rp_content"><h3 class="related_post_title">相关文章</h3><ul class="related_post wp_rp"><li ><a href="https://coolshell.cn/articles/336.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/plugins/wordpress-23-related-posts-plugin/static/thumbs/17.jpg" alt="超过100本的linux免费书籍" width="150" height="150" /></a><a href="https://coolshell.cn/articles/336.html" class="wp_rp_title">超过100本的linux免费书籍</a></li><li ><a href="https://coolshell.cn/articles/6639.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2012/02/programming-language-150x150.jpg" alt="千万别惹程序员 " width="150" height="150" /></a><a href="https://coolshell.cn/articles/6639.html" class="wp_rp_title">千万别惹程序员 </a></li><li ><a href="https://coolshell.cn/articles/4811.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/plugins/wordpress-23-related-posts-plugin/static/thumbs/0.jpg" alt="软件真的好难做啊" width="150" height="150" /></a><a href="https://coolshell.cn/articles/4811.html" class="wp_rp_title">软件真的好难做啊</a></li><li ><a href="https://coolshell.cn/articles/528.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2009/04/home-150x150.jpg" alt="NUI一个跨平台的C++库" width="150" height="150" /></a><a href="https://coolshell.cn/articles/528.html" class="wp_rp_title">NUI一个跨平台的C++库</a></li><li ><a href="https://coolshell.cn/articles/1103.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2009/06/programmer-life-150x150.jpg" alt="漫画：程序员的一生" width="150" height="150" /></a><a href="https://coolshell.cn/articles/1103.html" class="wp_rp_title">漫画：程序员的一生</a></li><li ><a href="https://coolshell.cn/articles/325.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2009/04/overall-150x150.jpg" alt="2009年脚本语言排名" width="150" height="150" /></a><a href="https://coolshell.cn/articles/325.html" class="wp_rp_title">2009年脚本语言排名</a></li></ul></div></div>The post <a href="https://coolshell.cn/articles/18246.html">关于我”极客时间“的专栏</a> first appeared on <a href="https://coolshell.cn">酷 壳 - CoolShell</a>.]]></content:encoded>
					
					<wfw:commentRss>https://coolshell.cn/articles/18246.html/feed</wfw:commentRss>
			<slash:comments>74</slash:comments>
		
		
			</item>
		<item>
		<title>API设计原则 &#8211; Qt官网的设计实践总结</title>
		<link>https://coolshell.cn/articles/18024.html</link>
					<comments>https://coolshell.cn/articles/18024.html#comments</comments>
		
		<dc:creator><![CDATA[李 鼎]]></dc:creator>
		<pubDate>Tue, 25 Jul 2017 06:16:30 +0000</pubDate>
				<category><![CDATA[C/C++语言]]></category>
		<category><![CDATA[技术读物]]></category>
		<category><![CDATA[程序设计]]></category>
		<category><![CDATA[系统架构]]></category>
		<category><![CDATA[API]]></category>
		<category><![CDATA[api-design]]></category>
		<category><![CDATA[API设计]]></category>
		<category><![CDATA[C++]]></category>
		<category><![CDATA[Coding]]></category>
		<category><![CDATA[Design]]></category>
		<category><![CDATA[Programmer]]></category>
		<category><![CDATA[qt]]></category>
		<category><![CDATA[程序员]]></category>
		<guid isPermaLink="false">http://coolshell.cn/?p=18024</guid>

					<description><![CDATA[<p>（感谢好友 @李鼎 翻译此文） 原文链接：API Design Principles &#8211; Qt Wiki 基于Gary的影响力上 Gary Gao ...</p>
<p class="read-more"><a class="btn btn-default" href="https://coolshell.cn/articles/18024.html"> Read More<span class="screen-reader-text">  Read More</span></a></p>
The post <a href="https://coolshell.cn/articles/18024.html">API设计原则 – Qt官网的设计实践总结</a> first appeared on <a href="https://coolshell.cn">酷 壳 - CoolShell</a>.]]></description>
										<content:encoded><![CDATA[<p><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3415450859608158"
     crossorigin="anonymous"></script><span style="color: #993300;"><strong>（感谢好友 <a href="http://www.weibo.com/oldratlee" target="_blank"  rel="noopener noreferrer">@李鼎</a> 翻译此文）</strong></span></p>
<p>原文链接：<a href="http://qt-project.org/wiki/API-Design-Principles">API Design Principles</a> &#8211; <a href="http://wiki.qt.io/">Qt Wiki</a><br />
基于<a href="http://blog.csdn.net/gaoyingju">Gary的影响力</a>上 <em>Gary Gao</em> 的译文稿：<a href="http://blog.csdn.net/gaoyingju/article/details/8245108">C++的API设计指导</a></p>
<h2>译序</h2>
<p><img decoding="async" loading="lazy" class="alignright size-medium" src="https://coolshell.cn/wp-content/uploads/2017/07/api-design-300x278.jpg" alt="" width="300" height="278" /></p>
<p>Qt的设计水准在业界很有口碑，一致、易于掌握和强大的API是Qt最著名的优点之一。此文既是Qt官网上的API设计指导准则，也是Qt在API设计上的实践总结。虽然Qt用的是C++，但其中设计原则和思考是具有普适性的（如果你对C++还不精通，可以忽略与C++强相关或是过于细节的部分，仍然可以学习或梳理关于API设计最有价值的内容）。整个篇幅中有很多示例，是关于API设计一篇难得的好文章。</p>
<p>需要注意的是，这篇Wiki有一些内容并不完整，所以，可能会有一些阅读上的问题，我们对此做了一些相关的注释。</p>
<p>PS：翻译中肯定会有不足和不对之处，欢迎评论&amp;交流；另译文源码在<a href="https://github.com/oldratlee/translations/tree/master/api-design-principles-from-qt">GitHub的这个仓库</a>中，可以<a href="https://github.com/oldratlee/translations/issues">提交Issue</a>/<a href="https://github.com/oldratlee/translations/fork">Fork后提交代码</a>来建议/指正。</p>
<h1>API设计原则</h1>
<p>一致、易于掌握和强大的API是Qt最著名的优点之一。此文总结了我们在设计Qt风格API的过程中所积累的诀窍（know-how）。其中许多是通用准则；而其他的则更偏向于约定，遵循这些约定主要是为了与已有的API保持一致。</p>
<p>虽然这些准则主要用于对外的API（public API），但在设计对内的API（private API）时也推荐遵循相同的技巧（techniques），作为开发者之间协作的礼仪（courtesy）。</p>
<p><span id="more-18024"></span></p>
<p>如有兴趣也可以读一下 <em>Jasmin Blanchette</em> 的<a href="http://www4.in.tum.de/~blanchet/api-design.pdf">Little Manual of API Design (PDF)</a> 或是本文的前身 <em>Matthias Ettrich</em> 的<a href="https://doc.qt.io/archives/qq/qq13-apis.html">Designing Qt-Style C++ APIs</a>。</p>
<h1>1. 好API的6个特质</h1>
<p>API之于程序员就如同图形界面之于普通用户（end-user）。API中的『P』实际上指的是『程序员』（Programmer），而不是『程序』（Program），强调的是API是给程序员使用的这一事实。</p>
<p>在第13期<a href="http://doc.qt.io/archives/qq/">Qt季刊</a>，<em>Matthias</em> 的<a href="https://doc.qt.io/archives/qq/qq13-apis.html">关于API设计的文章</a>中提出了观点：API应该极简（minimal）且完备（complete）、语义清晰简单（have clear and simple semantics）、符合直觉（be intuitive）、易于记忆（be easy to memorize）和引导API使用者写出可读代码（lead to readable code）。</p>
<h2>1.1 极简</h2>
<p>极简的API是指每个class的public成员尽可能少，public的class也尽可能少。这样的API更易理解、记忆、调试和变更。</p>
<h2>1.2 完备</h2>
<p>完备的API是指期望有的功能都包含了。这点会和保持API极简有些冲突。如果一个成员函数放在错误的类中，那么这个函数的潜在用户就会找不到，这也是违反完备性的。</p>
<h2>1.3 语义清晰简单</h2>
<p>就像其他的设计一样，我们应该遵守最少意外原则（the principle of least surprise）。好的API应该可以让常见的事完成的更简单，并有可以完成不常见的事的可能性，但是却不会关注于那些不常见的事。解决的是具体问题；当没有需求时不要过度通用化解决方案。（举个例子，在Qt 3中，<code>QMimeSourceFactory</code>不应命名成<code>QImageLoader</code>并有不一样的API。）</p>
<h2>1.4 符合直觉</h2>
<p>就像计算机里的其他事物一样，API应该符合直觉。对于什么是符合直觉的什么不符合，不同经验和背景的人会有不同的看法。API符合直觉的测试方法：经验不很丰富的用户不用阅读API文档就能搞懂API，而且程序员不用了解API就能看明白使用API的代码。</p>
<h2>1.5 易于记忆</h2>
<p>为使API易于记忆，API的命名约定应该具有一致性和精确性。使用易于识别的模式和概念，并且避免用缩写。</p>
<h2>1.6 引导API使用者写出可读代码</h2>
<p>代码只写一次，却要多次的阅读（还有调试和修改）。写出可读性好的代码有时候要花费更多的时间，但对于产品的整个生命周期来说是节省了时间的。</p>
<p>最后，要记住的是，不同的用户会使用API的不同部分。尽管简单使用单个Qt类的实例应该符合直觉，但如果是要继承一个类，让用户事先看好文档是个合理的要求。</p>
<h1>2. 静态多态</h1>
<p>相似的类应该有相似的API。在继承（inheritance）合适时可以用继承达到这个效果，即运行时多态。然而多态也发生在设计阶段。例如，如果你用<code>QProgressBar</code>替换<code>QSlider</code>，或是用<code>QString</code>替换<code>QByteArray</code>，你会发现API的相似性使的替换很容易。这即是所谓的『静态多态』（static polymorphism）。</p>
<p>静态多态也使记忆API和编程模式更加容易。因此，一组相关的类有相似的API有时候比每个类都有各自的一套API更好。</p>
<p>一般来说，在Qt中，如果没有足够的理由要使用继承，我们更倾向于用静态多态。这样可以减少Qt public类的个数，也使刚学习Qt的用户在翻看文档时更有方向感。</p>
<h2>2.1 好的案例</h2>
<p><code>QDialogButtonBox</code>与<code>QMessageBox</code>，在处理按钮（<code>addButton()</code>、<code>setStandardButtons()</code>等等）上有相似的API，不需要继承某个<code>QAbstractButtonBox</code>类。</p>
<h2>2.2 差的案例</h2>
<p><code>QTcpSocket</code>与<code>QUdpSocket</code>都继承了<code>QAbstractSocket</code>，这两个类的交互行为的模式（mode of interaction）非常不同。似乎没有什么人以通用和有意义的方式用过<code>QAbstractSocket</code>指针（或者 <strong><em>能</em></strong> 以通用和有意义的方式使用<code>QAbstractSocket</code>指针）。</p>
<h2>2.3 值得斟酌的案例</h2>
<p><code>QBoxLayout</code>是<code>QHBoxLayout</code>与<code>QVBoxLayout</code>的父类。好处：可以在工具栏上使用<code>QBoxLayout</code>，调用<code>setOrientation()</code>使其变为水平/垂直。坏处：要多一个类，并且有可能导致用户写出这样没什么意义的代码，<code>((QBoxLayout *)hbox)-&gt;setOrientation(Qt::Vertical)</code>。</p>
<h1>3. 基于属性的API</h1>
<p>新的Qt类倾向于用『基于属性（property）的API』，例如：</p>
<p>[code language=&#8221;cpp&#8221;]<br />
QTimer timer;<br />
timer.setInterval(1000);<br />
timer.setSingleShot(true);<br />
timer.start();<br />
[/code]</p>
<p>这里的 <strong><em>属性</em></strong> 是指任何的概念特征（conceptual attribute），是对象状态的一部分 —— 无论它是不是<code>Q_PROPERTY</code>。在说得通的情况下，用户应该可以以任何顺序设置属性，也就是说，属性之间应该是正交的（orthogonal）。例如，上面的代码可以写成：</p>
<p>[code language=&#8221;cpp&#8221;]<br />
QTimer timer;<br />
timer.setSingleShot(true);<br />
timer.setInterval(1000);<br />
timer.start();<br />
[/code]</p>
<blockquote><p>【译注】：正交性是指改变某个特性而不会影响到其他的特性。<a href="https://book.douban.com/subject/5387402/">《程序员修炼之道》</a>中讲了关于正交性的一个直升飞机坠毁的例子，讲得深入浅出很有画面感。</p></blockquote>
<p>为了方便，也写成：</p>
<p>[code language=&#8221;cpp&#8221;]<br />
timer.start(1000)；<br />
[/code]</p>
<p>类似地，对于<code>QRegExp</code>会是这样的代码：</p>
<p>[code language=&#8221;cpp&#8221;]<br />
QRegExp regExp;<br />
regExp.setCaseSensitive(Qt::CaseInsensitive);<br />
regExp.setPattern(&quot;.&quot;);<br />
regExp.setPatternSyntax(Qt::WildcardSyntax);<br />
[/code]</p>
<p>为实现这种类型的API，需要借助底层对象的懒创建。例如，对于<code>QRegExp</code>的例子，在不知道模式语法（pattern syntax）的情况下，在<code>setPattern()</code>中去解释<code>"."</code>就为时过早了。</p>
<p>属性之间常常有关联的；在这种情况下，我们必须小心处理。思考下面的问题：当前的风格（style）提供了『默认的图标尺寸』属性 vs. <code>QToolButton</code>的『<code>iconSize</code>』属性：</p>
<p>[code language=&#8221;cpp&#8221;]<br />
toolButton-&gt;setStyle(otherStyle);<br />
toolButton-&gt;iconSize();    // returns the default for otherStyle<br />
toolButton-&gt;setIconSize(QSize(52, 52));<br />
toolButton-&gt;iconSize();    // returns (52, 52)<br />
toolButton-&gt;setStyle(yetAnotherStyle);<br />
toolButton-&gt;iconSize();    // returns (52, 52)<br />
[/code]</p>
<p>提醒一下，一旦设置了<code>iconSize</code>，设置就会一直保持，即使改变当前的风格。这 <strong><em>很好</em></strong>。但有的时候需要能重置属性。有两种方法：</p>
<ol>
<li>传入一个特殊值（如<code>QSize()</code>、<code>-1</code>或者<code>Qt::Alignment(0)</code>）来表示『重置』</li>
<li>提供一个明确的重置方法，如<code>resetFoo()</code>和<code>unsetFoo()</code></li>
</ol>
<p>对于<code>iconSize</code>，使用<code>QSize()</code>（比如 <code>QSize(–1, -1)</code>）来表示『重置』就够用了。</p>
<p>在某些情况下，getter方法返回的结果与所设置的值不同。例如，虽然调用了<code>widget-&gt;setEnabled(true)</code>，但如果它的父widget处于disabled状态，那么<code>widget-&gt;isEnabled()</code>仍然返回的是<code>false</code>。这样是OK的，因为一般来说就是我们想要的检查结果（父widget处于disabled状态，里面的子widget也应该变为灰的不响应用户操作，就好像子widget自身处于disabled状态一样；与此同时，因为子widget记得在自己的内心深处是enabled状态的，只是一直等待着它的父widget变为enabled）。当然诸如这些都必须在文档中妥善地说明清楚。</p>
<h1>4. C++相关</h1>
<h2>4.1 值 vs. 对象</h2>
<h3>4.1.1 指针 vs. 引用</h3>
<p>指针（pointer）还是引用（reference）哪个是最好的输出参数（out-parameters）？</p>
<p>[code language=&#8221;cpp&#8221;]<br />
void getHsv(int *h, int *s, int *v) const;<br />
void getHsv(int &amp;h, int &amp;s, int &amp;v) const;<br />
[/code]</p>
<p>大多数C++书籍推荐尽可能使用引用，基于一个普遍的观点：引用比指针『更加安全和优雅』。与此相反，我们在开发Qt时倾向于指针，因为指针让用户代码可读性更好。比较下面例子：</p>
<p>[code language=&#8221;cpp&#8221;]<br />
color.getHsv(&amp;h, &amp;s, &amp;v);<br />
color.getHsv(h, s, v);<br />
[/code]</p>
<p>只有第一行代码清楚表达出<code>h</code>、<code>s</code>、<code>v</code>参数在函数调用中非常有可能会被修改。</p>
<p>这也就是说，编译器并不喜欢『出参』，所你应该在新的API中避免使用『出参』，而是返回一个结构体，如下所示：</p>
<p>[code language=&#8221;cpp&#8221;]<br />
struct Hsv { int hue, saturation, value };<br />
Hsv getHsv() const;<br />
[/code]</p>
<blockquote><p>【译注】：函数的『入参』和『出参』的混用会导致 API 接口语义的混乱，所以，使用指针，在调用的时候，实参需要加上“&amp;”，这样在代码阅读的时候，可以看到是一个『出参』，有利于代码阅读。（但是这样做，在函数内就需要判断指针是否为空的情况，因为引用是不需要判断的，所以，这是一种 trade-off）</p>
<p>另外，如果这样的参数过多的话，最好使用一个结构体来把数据打包，一方面，为一组返回值取个名字，另一方面，这样有利用接口的简单。</p></blockquote>
<h3>4.1.2 按常量引用传参 vs. 按值传参</h3>
<p>如果类型大于16字节，按常量引用传参。</p>
<p>如果类型有重型的（non-trivial）拷贝构造函数（copy-constructor）或是重型的析构函数（destructor），按常量引用传参以避免执行这些函数。</p>
<p>对于其它的类型通常应该按值传参。</p>
<p>示例：</p>
<p>[code language=&#8221;cpp&#8221;]<br />
void setAge(int age);<br />
void setCategory(QChar cat);<br />
void setName(QLatin1String name);</p>
<p>// const-ref is much faster than running copy-constructor and destructor<br />
void setAlarm(const QSharedPointer&lt;Alarm&gt; &amp;alarm);</p>
<p>// QDate, QTime, QPoint, QPointF, QSize, QSizeF, QRect<br />
// are good examples of other classes you should pass by value.<br />
[/code]</p>
<blockquote><p>【译注】：这是传引用和传值的差别了，因为传值会有对像拷贝，传引用则不会。所以，如果对像的构造比较重的话（换句话说，就是对像里的成员变量需要的内存比较大），这就会影响很多性能。所以，为了提高性能，最好是传引用。但是如果传入引用的话，会导致这个对象可能会被改变。所以传入const reference。</p></blockquote>
<h2>4.2 虚函数</h2>
<p>在C++中，当类的成员函数声明为virtual，主要是为了通过在子类重载此函数能够定制函数的行为。将函数声明为virtual的目的是为了让对这个函数已有的调用变成执行实际实例的代码路径。对于没有在类外部调用的函数声明成virtual，你应该事先非常慎重地思考过。</p>
<p>[code language=&#8221;cpp&#8221;]<br />
// QTextEdit in Qt 3: member functions that have no reason for being virtual<br />
virtual void resetFormat();<br />
virtual void setUndoDepth( int d );<br />
virtual void setFormat( QTextFormat *f, int flags );<br />
virtual void ensureCursorVisible();<br />
virtual void placeCursor( const QPoint &amp;pos;, QTextCursor **c = 0 );<br />
virtual void moveCursor( CursorAction action, bool select );<br />
virtual void doKeyboardAction( KeyboardAction action );<br />
virtual void removeSelectedText( int selNum = 0 );<br />
virtual void removeSelection( int selNum = 0 );<br />
virtual void setCurrentFont( const QFont &amp;f );<br />
virtual void setOverwriteMode( bool b ) { overWrite = b; }<br />
[/code]</p>
<p><code>QTextEdit</code>从Qt 3移植到Qt 4的时候，几乎所有的虚函数都被移除了。有趣的是（但在预料之中），并没有人对此有大的抱怨，为什么？因为Qt 3没用到<code>QTextEdit</code>的多态行为 —— 只有你会；简单地说，没有理由去继承<code>QTextEdit</code>并重写这些函数，除非你自己调用了这些方法。如果在Qt在外部你的应用程序你需要多态，你可以自己添加多态。</p>
<blockquote><p>【译注】：『多态』的目的只不过是为了实践 —— 『依赖于接口而不是实现』，也就是说，接口是代码抽像的一个非常重要的方式（在Java/Go中都有专门的接口声明语法）。所以，如果没有接口抽像，使用『多态』的意义也就不大了，因为也就没有必要使用『虚函数』了。</p></blockquote>
<h3>4.2.1 避免虚函数</h3>
<p>在Qt中，我们有很多理由尽量减少虚函数的数量。每一次对虚函数的调用会在函数调用链路中插入一个未掌控的节点（某种程度上使结果更无法预测），使得bug修复变得更复杂。用户在重写的虚函数中可以做很多疯狂的事：</p>
<ul>
<li>发送事件</li>
<li>发送信号</li>
<li>重新进入事件循环（例如，通过打开一个模态文件对话框）</li>
<li>删除对象（即触发『<code>delete this</code>』）</li>
</ul>
<p>还有其他很多原因要避免过度使用虚函数：</p>
<ul>
<li>添加、移动或是删除虚函数都带来二进制兼容问题（binary compatibility/BC）</li>
<li>重载虚函数并不容易</li>
<li>编译器几乎不能优化或内联（inline）对虚函数的调用</li>
<li>虚函数调用需要查找虚函数表（v-table），这比普通函数调用慢了2到3倍</li>
<li>虚函数使得类很难按值拷贝（尽管也可以按值拷贝，但是非常混乱并且不建议这样做）</li>
</ul>
<p>经验告诉我们，没有虚函数的类一般bug更少、维护成本也更低。</p>
<p>一般的经验法则是，除非我们以这个类作为工具集提供而且有很多用户来调用某个类的虚函数，否则这个函数九成不应该设计成虚函数。</p>
<blockquote><p>【译注】：</p>
<ol>
<li>使用虚函数时，你需要对编译器的内部行为非常清楚，否则，你会在使用虚函数时，觉得有好些『古怪』的问题发生。比如在创建数组对象的时候。</li>
<li>在C++中，会有一个基础类，这个基础类中已经实现好了很多功能，然后把其中的一些函数放给子类去修改和实现。这种方法在父类和子类都是一组开发人员维护时没有什么问题，但是如果这是两组开发人员，这就会带来很多问题了，就像Qt这样，子类完全无法控制，全世界的开发人员想干什么就干什么。所以，子类的代码和父类的代码在兼容上就会出现很多很多问题。所以，还是上面所说，其实，虚函数应该声明在接口的语义里（这就是设计模式的两个宗旨——依赖于接口，而不是实现；钟爱于组合，而不是继承。也是为什么Java和Go语言使用interface关键字的原因，C++在多态的语义上非常容易滥用）</li>
</ol>
</blockquote>
<h3>4.2.2 虚函数 vs. 拷贝</h3>
<p>多态对象（polymorphic objects）和值类型的类（value-type classes）两者很难协作好。</p>
<p>包含虚函数的类必须把析构函数声明为虚函数，以防止父类析构时没有清理子类的数据，导致内存泄漏。</p>
<p>如果要使一个类能够拷贝、赋值或按值比较，往往需要拷贝构造函数、赋值操作符（<code>operator =</code>）和相等操作符（<code>operator ==</code>）。</p>
<p>[code language=&#8221;cpp&#8221;]<br />
class CopyClass {<br />
public:<br />
    CopyClass();<br />
    CopyClass(const CopyClass &amp;other);<br />
    ~CopyClass();<br />
    CopyClass &amp;operator =(const CopyClass &amp;other);<br />
    bool operator ==(const CopyClass &amp;other) const;<br />
    bool operator !=(const CopyClass &amp;other) const;</p>
<p>    virtual void setValue(int v);<br />
};<br />
[/code]</p>
<p>如果继承<code>CopyClass</code>这个类，预料之外的事就已经在代码时酝酿了。一般情况下，如果没有虚成员函数和虚析构函数，就不能创建出可以多态的子类。然而，如果存在虚成员函数和虚析构函数，这突然变成了要有子类去继承的理由，而且开始变得复杂了。<strong><em>起初认为只要简单声明上虚操作符重载函数（virtual operators）。</em></strong> 但其实是走上了一条混乱和毁灭之路（破坏了代码的可读性）。看看下面的这个例子：</p>
<p>[code language=&#8221;cpp&#8221;]<br />
class OtherClass {<br />
public:<br />
    const CopyClass &amp;instance() const; // 这个方法返回的是什么？可以赋值什么？<br />
};<br />
[/code]</p>
<p>（这部份还未完成）</p>
<blockquote><p>【译注】：因为原文上说，这部份并没有完成，所以，我也没有搞懂原文具体也是想表达什么。不过，就标题而言，原文是想说，在多态的情况下拷贝对象所带来的问题？？</p></blockquote>
<h2>4.3 关于const</h2>
<p><strong><em>C++的关键词const表明了内容不会改变或是没有副作用。可以应用于简单的值、指针及指针所指的内容，也可以作为一个特别的属性应用于类的成员函数上，表示成员函数不能修改对象的状态。</em></strong></p>
<p>然而，const本身并没有提供太大的价值 —— 很多编程语言甚至没有类似const的关键词，但是却并没有因此产生问题。实际上，如果你不用函数重载，并在C++源代码用搜索并删除所有的const，几乎总能编译通过并且正常运行。尽量让使用的const保持实用有效，这点很重要。</p>
<p>让我们看一下在Qt的API设计中与const相关的场景。</p>
<h3>4.3.1 输入参数：const指针</h3>
<p>有输入指针参数的const成员函数，几乎总是const指针参数。</p>
<p>如果函数声明为const，意味着既没有副作用，也不会改变对象的可见状态。那为什么它需要一个没有const限定的输入参数呢？记住const类型的函数通常被其他const类型的函数调用，接收到的一般都是const指针（只要不主动const_cast，我们推荐尽量避免使用const_cast）</p>
<p>以前：</p>
<p>[code language=&#8221;cpp&#8221;]<br />
bool QWidget::isVisibleTo(QWidget *ancestor) const;<br />
bool QWidget::isEnabledTo(QWidget *ancestor) const;<br />
QPoint QWidget::mapFrom(QWidget *ancestor, const QPoint &amp;pos) const;<br />
[/code]</p>
<p><code>QWidget</code>声明了许多非const指针输入参数的const成员函数。注意，这些函数可以修改传入的参数，不能修改对象自己。使用这样的函数常常要借助const_cast转换。如果是const指针输入参数，就可以避免这样的转换了。</p>
<p>之后：</p>
<p>[code language=&#8221;cpp&#8221;]<br />
bool QWidget::isVisibleTo(const QWidget *ancestor) const;<br />
bool QWidget::isEnabledTo(const QWidget *ancestor) const;<br />
QPoint QWidget::mapFrom(const QWidget *ancestor, const QPoint &amp;pos) const;<br />
[/code]</p>
<p>注意，我们在<code>QGraphicsItem</code>中对此做了修正，但是<code>QWidget</code>要等到Qt 5:</p>
<p>[code language=&#8221;cpp&#8221;]<br />
bool isVisibleTo(const QGraphicsItem *parent) const;<br />
QPointF mapFromItem (const QGraphicsItem *item, const QPointF &amp;point) const;<br />
[/code]</p>
<h3>4.3.2 返回值：const值</h3>
<p>调用函数返回的非引用类型的结果，称之为右值（R-value）。</p>
<p>非类（non-class）的右值总是无cv限定类型（cv-unqualified type）。虽然从语法上讲，加上const也可以，但是没什么意义，因为鉴于访问权限这些值是不能改变的。多数现代编译器在编译这样的代码时会提示警告信息。</p>
<blockquote><p>【译注】：cv-qualified的类型（与cv-unqualified相反）是由const或者volatile或者volatile const限定的类型。详见<a href="http://en.cppreference.com/w/cpp/language/cv">cv (const and volatile) type qualifiers &#8211; C++语言参考</a></p></blockquote>
<p>当在类类型（class type）右值上添加const关键字，则禁止访问非const成员函数以及对成员的直接操作。</p>
<p>不加const则没有以上的限制，但几乎没有必要加上const，因为右值对象生存时间（life time）的结束一般在C++清理的时候（通俗的说，下一个分号地方），而对右值对象的修改随着右值对象的生存时间也一起结束了（也就是本条语句的执行完成的时候）。</p>
<p>示例：</p>
<p>[code language=&#8221;cpp&#8221;]<br />
struct Foo {<br />
    void setValue(int v) { value = v; }<br />
    int value;<br />
};</p>
<p>Foo foo() {<br />
    return Foo();<br />
}</p>
<p>const Foo cfoo() {<br />
    return Foo();<br />
}</p>
<p>int main() {<br />
    // The following does compile, foo() is non-const R-value which<br />
    // can&#8217;t be assigned to (this generally requires an L-value)<br />
    // but member access leads to a L-value:<br />
    foo().value = 1; // Ok, but temporary will be thrown away at the end of the full-expression.</p>
<p>    // The following does compile, foo() is non-const R-value which<br />
    // can&#8217;t be assigned to, but calling (even non-const) member<br />
    // function is fine:<br />
    foo().setValue(1); // Ok, but temporary will be thrown away at the end of the full-expression.</p>
<p>    // The following does _not_compile, foo() is &#8221;const&#8221; R-value<br />
    // with const member which member access can&#8217;t be assigned to:<br />
    cfoo().value = 1; // Not ok.</p>
<p>    // The following does _not_compile, foo() is &#8221;const&#8221; R-value,<br />
    // one cannot call non-const member functions:<br />
    cfoo().setValue(1); // Not ok<br />
}<br />
[/code]</p>
<blockquote><p>【译注】：上述的代码说明，如果返回值不是const的，代码可以顺利编译通过，然而并没有什么卵用，因为那个临时对像马上就被抛弃了。所以，这样的无用的代码最好还是在编译时报个错，以免当时头脑发热想错了，写了一段没用但还以为有用的代码。</p></blockquote>
<h3>4.3.3 返回值：非const的指针还是有const的指针</h3>
<p>谈到const函数应该返回非const的指针还是const指针这个话题时，多数人发现在C++中关于『const正确性』（const correctness）在概念上产生了分歧。 <em>问题起源是：<strong>const函数本身不能修改对象自身的状态，却可以返回成员的非const指针</strong>。返回指针这个简单动作本身既不会影响整个对象的可见状态，当然也不会改变这个函数职责范围内涉及的状态。但是，这却使得程序员可以间接访问并修改对象的状态。</em></p>
<p>下面的例子演示了通过返回非const指针的const函数绕开const约定（constness）的诸多方式中的一种：</p>
<p>[code language=&#8221;cpp&#8221;]<br />
QVariant CustomWidget::inputMethodQuery(Qt::InputMethodQuery query) const {<br />
    moveBy(10, 10); // doesn&#8217;t compile!<br />
    window()-&gt;childAt(mapTo(window(), rect().center()))-&gt;moveBy(10, 10); // compiles!<br />
}<br />
[/code]</p>
<p>返回const指针的函数正是保护以避免这些（可能是不期望的/没有预料到的）副作用，至少是在一定程度上。但哪个函数你会觉得更想返回const指针，或是不止一个函数？</p>
<p>若采用const正确（const-correct）的方法，每个返回某个成员的指针（或多个指向成员的指针）的const函数必须返回const指针。在实践中，很不幸这样的做法将导致无法使用的API：</p>
<p>[code language=&#8221;cpp&#8221;]<br />
QGraphicsScene scene;<br />
// … populate scene</p>
<p>foreach (const QGraphicsItem *item, scene.items()) {<br />
    item-&gt;setPos(qrand() % 500, qrand() % 500); // doesn&#8217;t compile! item is a const pointer<br />
}<br />
[/code]</p>
<p><code>QGraphicsScene::items()</code>是一个const函数，顺着思考看起来这个函数只应该返回const指针。</p>
<p>在Qt中，我们几乎只有非const的使用模式。我们选择的是实用路子： 相比滥用非const指针返回类型带来的问题，返回const指针更可能招致过分使用const_cast的问题。</p>
<h3>4.3.4 返回值：按值返回 还是 按const引用返回？</h3>
<p>若返回的是对象的拷贝，那么返回const引用是更直接的方案； 然而，这样的做法限制了后面想要对这个类的重构（refactor）。 （以<code>d-point</code>的典型做法（idiom）为例，我们可以在任何时候改变Qt类在内存表示（memory representation）；但却不能在不破坏二进制兼容性的情况下把改变函数的签名，返回值从<code>const QFoo &amp;</code>变为<code>QFoo</code>。） 基于这个原因，除去对运行速度敏感（speed is critical）而重构不是问题的个别情形（例如，<code>QList::at()</code>），我们一般返回<code>QFoo</code>而不是<code>const QFoo &amp;</code>。</p>
<blockquote><p>【译注】：参看《Effective C++》中条款23：Don&#8217;t try to return a reference when you must return an object</p></blockquote>
<h3>4.4.5 const vs. 对象的状态</h3>
<p>const正确性（Const correctness）的问题就像C圈子中vi与emacs的讨论，因为这个话题在很多地方都存在分歧（比如基于指针的函数）。</p>
<p>但通用准则是const函数不能改变类的可见状态。『状态』的意思是『自身以及涉及的职责』。这并不是指非const函数能够改变自身的私有成员，也不是指const函数改变不了。而是指函数是活跃的并存在可见的副作用（visible side effects）。const函数一般没有任何可见的副作用，比如：</p>
<p>[code language=&#8221;cpp&#8221;]<br />
QSize size = widget-&gt;sizeHint(); // const<br />
widget-&gt;move(10, 10); // not const<br />
[/code]</p>
<p>代理（delegate）负责在其它对象上绘制内容。 它的状态包括它的职责，因此包括在哪个对象做绘制这样的状态。 调用它的绘画行为必然会有副作用； 它改变了它绘制所在设备的外观（及其所关联的状态）。鉴于这些，<code>paint()</code>作为const函数并不合理。 进一步说，任何<code>paint()</code>或<code>QIcon</code>的<code>paint()</code>的视图函数是const函数也不合理。 没有人会从内部的const函数去调用<code>QIcon::paint()</code>，除非他想显式地绕开const这个特性。 如果是这种情况，使用const_cast会更好。</p>
<p>[code language=&#8221;cpp&#8221;]<br />
// QAbstractItemDelegate::paint is const<br />
void QAbstractItemDelegate::paint(QPainter **painter, const QStyleOptionViewItem &amp;option, const QModelIndex &amp;index) const</p>
<p>// QGraphicsItem::paint is not const<br />
void QGraphicsItem::paint(QPainter *painter, const QStyleOptionGraphicsItem option, QWidget *widget)<br />
[/code]</p>
<p>const关键字并不能按你期望的样子起作用。应该考虑将其移除而不是去重载const/非const函数。</p>
<h1>5. API的语义和文档</h1>
<p>当传值为<code>-1</code>的参数给函数，函数会是什么行为？有很多类似的问题……</p>
<p>是警告、致命错误还是其它？</p>
<p>API需要的是质量保证。API第一个版本一定是不对的；必须对其进行测试。 以阅读使用API的代码的方式编写用例，且验证这样代码是可读的。</p>
<p>还有其他的验证方法，比如</p>
<ul>
<li>让别人使用API（看了文档或是先不看文档都可以）</li>
<li>给类写文档（包含类的概述和每个函数）</li>
</ul>
<h1>6. 命名的艺术</h1>
<p>命名很可能是API设计中最重要的一个问题。类应该叫什么名字？成员函数应该叫什么名字？</p>
<h2>6.1 通用的命名规则</h2>
<p>有几个规则对于所有类型的命名都等同适用。第一个，之前已经提到过，不要使用缩写。即使是明显的缩写，比如把<code>previous</code>缩写成<code>prev</code>，从长远来看是回报是负的，因为用户必须要记住缩写词的含义。</p>
<p>如果API本身没有一致性，之后事情自然就会越来越糟；例如，Qt 3 中同时存在<code>activatePreviousWindow()</code>与<code>fetchPrev()</code>。恪守『不缩写』规则更容易地创建一致性的API。</p>
<p>另一个时重要但更微妙的准则是在设计类时应该保持子类名称空间的干净。在Qt 3中，此项准则并没有一直遵循。以<code>QToolButton</code>为例对此进行说明。如果调用<code>QToolButton</code>的 <code>name()</code>、<code>caption()</code>、<code>text()</code>或者<code>textLabel()</code>，你觉得会返回什么？用Qt设计器在<code>QToolButton</code>上自己先试试吧：</p>
<ul>
<li><code>name</code>属性是继承自<code>QObject</code>，返回内部的对象名称，用于调试和测试。</li>
<li><code>caption</code>属性继承自<code>QWidget</code>，返回窗口标题，对<code>QToolButton</code>来说毫无意义，因为它在创建的时候parent就存在了。</li>
<li><code>text</code>函数继承自<code>QButton</code>，一般用于按钮。当<code>useTextLabel</code>不为<code>true</code>，才用这个属性。</li>
<li><code>textLabel</code>属性在<code>QToolButton</code>内声明，当<code>useTextLabel</code>为<code>true</code>时显示在按钮上。</li>
</ul>
<p>为了可读性，在Qt 4中<code>QToolButton</code>的<code>name</code>属性改成了<code>objectName</code>，<code>caption</code>改成了<code>windowTitle</code>，删除了<code>textLabel</code>属性因为和<code>text</code>属性相同。</p>
<p>当你找不到好的命名时，写文档也是个很好方法：要做的就是尝试为各个条目（item）（如类、方法、枚举值等等）写文档，并用写下的第一句话作为启发。如果找不到一个确切的命名，往往说明这个条目是不该有的。如果所有尝试都失败了，并且你坚信这个概念是合理的，那么就发明一个新名字。像widget、event、focus和buddy这些命名就是在这一步诞生的。</p>
<blockquote><p>【译注】：写文档是一个非常好的习惯。写文档的过程其实就是在帮你梳理你的编程思路。很多时候，文档写着写着你就会发现要去改代码去了。除了上述的好处多，写文档还有更多的好处。比如，在写文档的过程中，你发现文字描述过于复杂了，这表明着你的代码或逻辑是复杂的，这就倒逼你去重构你的代码。所以 —— <strong>写文档其实就是写代码</strong>。</p></blockquote>
<h2>6.2 类的命名</h2>
<p>识别出类所在的分组，而不是为每个类都去找个完美的命名。例如，所有Qt 4的能感知模型（model-aware）的item view，类后缀都是<code>View</code>（<code>QListView</code>、<code>QTableView</code>、<code>QTreeView</code>），而相应的基于item（item-based）的类后缀是<code>Widget</code>（<code>QListWidget</code>、<code>QTableWidget</code>、<code>QTreeWidget</code>）。</p>
<h2>6.3 枚举类型及其值的命名</h2>
<p>声明枚举类型时，需要记住在C++中枚举值在使用时不会带上类型（与Java、C#不同）。下面的例子演示了枚举值命名得过于通用的危害：</p>
<p>[code language=&#8221;cpp&#8221;]<br />
namespace Qt<br />
{<br />
    enum Corner { TopLeft, BottomRight, &#8230; };<br />
    enum CaseSensitivity { Insensitive, Sensitive };<br />
    &#8230;<br />
};</p>
<p>tabWidget-&gt;setCornerWidget(widget, Qt::TopLeft);<br />
str.indexOf(&quot;$(QTDIR)&quot;, Qt::Insensitive);<br />
[/code]</p>
<p>在最后一行，<code>Insensitive</code>是什么意思？命名枚举类型的一个准则是在枚举值中至少重复此枚举类型名中的一个元素：</p>
<p>[code language=&#8221;cpp&#8221;]<br />
namespace Qt<br />
{<br />
    enum Corner { TopLeftCorner, BottomRightCorner, &#8230; };<br />
    enum CaseSensitivity { CaseInsensitive, CaseSensitive };<br />
    &#8230;<br />
};</p>
<p>tabWidget-&gt;setCornerWidget(widget, Qt::TopLeftCorner);<br />
str.indexOf(&quot;$(QTDIR)&quot;, Qt::CaseInsensitive);<br />
[/code]</p>
<p>当对枚举值进行或运算并作为某种标志（flag）时，传统的做法是把或运算的结果保存在int型的值中，但这不是类型安全的。Qt 4提供了一个模板类<code>QFlags</code>，其中的<code>T</code>是枚举类型。为了方便使用，Qt用<code>typedef</code>重新定义了<code>QFlag</code>类型，所以可以用<code>Qt::Alignment</code>代替<code>QFlags</code>。</p>
<p>习惯上，枚举类型命名用单数形式（因为它一次只能『持有』一个flag），而持有多个『flag』的类型用复数形式，例如：</p>
<p>[code language=&#8221;cpp&#8221;]<br />
enum RectangleEdge { LeftEdge, RightEdge, &#8230; };<br />
typedef QFlags&lt;RectangleEdge&gt; RectangleEdges;<br />
[/code]</p>
<p>在某些情形下，持有多个『flag』的类型命名用单数形式。对于这种情况，持有的枚举类型名称要求是以<code>Flag</code>为后缀：</p>
<p>[code language=&#8221;cpp&#8221;]<br />
enum AlignmentFlag { AlignLeft, AlignTop, &#8230; };<br />
typedef QFlags&lt;AlignmentFlag&gt; Alignment;<br />
[/code]</p>
<h2>6.4 函数和参数的命名</h2>
<p>函数命名的第一准则是可以从函数名看出来此函数是否有副作用。在Qt 3中，const函数<code>QString::simplifyWhiteSpace()</code>违反了此准则，因为它返回了一个<code>QString</code>而不是按名称暗示的那样，改变调用它的<code>QString</code>对象。在Qt 4中，此函数重命名为<code>QString::simplified()</code>。</p>
<p>虽然参数名不会出现在使用API的代码中，但是它们给程序员提供了重要信息。因为现代的IDE都会在写代码时显示参数名称，所以值得在头文件中给参数起一个恰当的名字并在文档中使用相同的名字。</p>
<h2>6.5 布尔类型的getter与setter方法的命名</h2>
<p>为<code>bool</code>属性的getter和setter方法命名总是很痛苦。getter应该叫做<code>checked()</code>还是<code>isChecked()</code>？<code>scrollBarsEnabled()</code>还是<code>areScrollBarEnabled()</code>？</p>
<p>Qt 4中，我们套用以下准则为getter命名：</p>
<ul>
<li>形容词以<code>is</code>为前缀，例子：
<ul>
<li><code>isChecked()</code></li>
<li><code>isDown()</code></li>
<li><code>isEmpty()</code></li>
<li><code>isMovingEnabled()</code></li>
</ul>
</li>
<li>然而，修饰名词的形容词没有前缀：
<ul>
<li><code>scrollBarsEnabled()</code>，而不是<code>areScrollBarsEnabled()</code></li>
</ul>
</li>
<li>动词没有前缀，也不使用第三人称(<code>-s</code>)：
<ul>
<li><code>acceptDrops()</code>，而不是<code>acceptsDrops()</code></li>
<li><code>allColumnsShowFocus()</code></li>
</ul>
</li>
<li>名词一般没有前缀：
<ul>
<li><code>autoCompletion()</code>，而不是<code>isAutoCompletion()</code></li>
<li><code>boundaryChecking()</code></li>
</ul>
</li>
<li>有的时候，没有前缀容易产生误导，这种情况下会加上<code>is</code>前缀：
<ul>
<li><code>isOpenGLAvailable()</code>，而不是<code>openGL()</code></li>
<li><code>isDialog()</code>，而不是<code>dialog()</code><br />
（一个叫做<code>dialog()</code>的函数，一般会被认为是返回<code>QDialog</code>。）</li>
</ul>
</li>
</ul>
<p>setter的名字由getter衍生，去掉了前缀后在前面加上了<code>set</code>；例如，<code>setDown()</code>与<code>setScrollBarsEnabled()</code>。</p>
<h1>7. 避免常见陷阱</h1>
<h2>7.1 简化的陷阱</h2>
<p>一个常见的误解是：实现需要写的代码越少，API就设计得越好。应该记住：代码只会写上几次，却要被反复阅读并理解。例如：</p>
<p>[code language=&#8221;cpp&#8221;]<br />
QSlider *slider = new QSlider(12, 18, 3, 13, Qt::Vertical, 0, &quot;volume&quot;);<br />
[/code]</p>
<p>这段代码比下面的读起来要难得多（甚至写起来也更难）：</p>
<p>[code language=&#8221;cpp&#8221;]<br />
QSlider *slider = new QSlider(Qt::Vertical);<br />
slider-&gt;setRange(12, 18);<br />
slider-&gt;setPageStep(3);<br />
slider-&gt;setValue(13);<br />
slider-&gt;setObjectName(&quot;volume&quot;);<br />
[/code]</p>
<blockquote><p>【译注】：在有IDE的自动提示的支持下，后者写起来非常方便，而前者还需要看相应的文档。</p></blockquote>
<h2>7.2 布尔参数的陷阱</h2>
<p>布尔类型的参数总是带来无法阅读的代码。给现有的函数增加一个<code>bool</code>型的参数几乎永远是一种错误的行为。仍以Qt为例，<code>repaint()</code>有一个<code>bool</code>类型的可选参数用于指定背景是否被擦除。可以写出这样的代码：</p>
<p>[code language=&#8221;cpp&#8221;]<br />
widget-&gt;repaint(false);<br />
[/code]</p>
<p>初学者很可能是这样理解的，『不要重新绘制！』，能有多少Qt用户真心知道下面3行是什么意思：</p>
<p>[code language=&#8221;cpp&#8221;]<br />
widget-&gt;repaint();<br />
widget-&gt;repaint(true);<br />
widget-&gt;repaint(false);<br />
[/code]</p>
<p>更好的API设计应该是这样的：</p>
<p>[code language=&#8221;cpp&#8221;]<br />
widget-&gt;repaint();<br />
widget-&gt;repaintWithoutErasing();<br />
[/code]</p>
<p>在Qt 4中，我们通过移除了重新绘制（repaint）而不擦除widget的能力来解决了此问题。Qt 4的双缓冲使这种特性被废弃。</p>
<p>还有更多的例子：</p>
<p>[code language=&#8221;cpp&#8221;]<br />
widget-&gt;setSizePolicy(QSizePolicy::Fixed, QSizePolicy::Expanding, true);<br />
textEdit-&gt;insert(&quot;Where&#8217;s Waldo?&quot;, true, true, false);<br />
QRegExp rx(&quot;moc_***.c??&quot;, false, true);<br />
[/code]</p>
<p>一个明显的解决方案是<code>bool</code>类型改成枚举类型。我们在Qt 4的<code>QString</code>中就是这么做的。对比效果如下：</p>
<p>[code language=&#8221;cpp&#8221;]<br />
str.replace(&quot;%USER%&quot;, user, false);               // Qt 3<br />
str.replace(&quot;%USER%&quot;, user, Qt::CaseInsensitive); // Qt 4<br />
[/code]</p>
<blockquote><p>【译注】：关于这个条目可以看看 CoolShell 这篇文章一些展开的讨论： <a href="https://coolshell.cn/articles/5444.html" rel="nofollow">千万不要把 BOOL 设计成函数参数</a>。</p></blockquote>
<h1>8. 案例研究</h1>
<h2>8.1 <code>QProgressBar</code></h2>
<p>为了展示上文各种准则的实际应用。我们来研究一下Qt 3中<code>QProgressBar</code>的API，并与Qt 4中对应的API作比较。在Qt 3中：</p>
<p>[code language=&#8221;cpp&#8221;]<br />
class QProgressBar : public QWidget<br />
{<br />
    &#8230;<br />
public:<br />
    int totalSteps() const;<br />
    int progress() const;</p>
<p>    const QString &amp;progressString() const;<br />
    bool percentageVisible() const;<br />
    void setPercentageVisible(bool);</p>
<p>    void setCenterIndicator(bool on);<br />
    bool centerIndicator() const;</p>
<p>    void setIndicatorFollowsStyle(bool);<br />
    bool indicatorFollowsStyle() const;</p>
<p>public slots:<br />
    void reset();<br />
    virtual void setTotalSteps(int totalSteps);<br />
    virtual void setProgress(int progress);<br />
    void setProgress(int progress, int totalSteps);</p>
<p>protected:<br />
    virtual bool setIndicator(QString &amp;progressStr,<br />
                              int progress,<br />
                              int totalSteps);<br />
    &#8230;<br />
};<br />
[/code]</p>
<p>该API相当的复杂和不一致；例如，<code>reset()</code>、<code>setTotalSteps()</code>、<code>setProgress()</code>是紧密联系的，但方法的命名并没明确地表达出来。</p>
<p>改善此API的关键是抓住<code>QProgressBar</code>与Qt 4的<code>QAbstractSpinBox</code>及其子类<code>QSpinBox</code>、<code>QSlider</code>、<code>QDail</code>之间的相似性。怎么做？把<code>progress</code>、<code>totalSteps</code>替换为<code>minimum</code>、<code>maximum</code>和<code>value</code>。增加一个<code>valueChanged()</code>消息，再增加一个<code>setRange()</code>函数。</p>
<p>进一步可以观察到<code>progressString</code>、<code>percentage</code>与<code>indicator</code>其实是一回事，即是显示在进度条上的文本。通常这个文本是个百分比，但是可通过<code>setIndicator()</code>设置为任何内容。以下是新的API：</p>
<p>[code language=&#8221;cpp&#8221;]<br />
virtual QString text() const;<br />
void setTextVisible(bool visible);<br />
bool isTextVisible() const;<br />
[/code]</p>
<p>默认情况下，显示文本是百分比指示器（percentage indicator），通过重写<code>text()</code>方法来定制行为。</p>
<p>Qt 3的<code>setCenterIndicator()</code>与<code>setIndicatorFollowsStyle()</code>是两个影响对齐方式的函数。他们可被一个<code>setAlignment()</code>函数代替：</p>
<p>[code language=&#8221;cpp&#8221;]<br />
void setAlignment(Qt::Alignment alignment);<br />
[/code]</p>
<p>如果开发者未调用<code>setAlignment()</code>，那么对齐方式由风格决定。对于基于<code>Motif</code>的风格，文字内容在中间显示；对于其他风格，在右侧显示。</p>
<p>下面是改善后的<code>QProgressBar API</code>:</p>
<p>[code language=&#8221;cpp&#8221;]<br />
class QProgressBar : public QWidget<br />
{<br />
    &#8230;<br />
public:<br />
    void setMinimum(int minimum);<br />
    int minimum() const;<br />
    void setMaximum(int maximum);<br />
    int maximum() const;<br />
    void setRange(int minimum, int maximum);<br />
    int value() const;</p>
<p>    virtual QString text() const;<br />
    void setTextVisible(bool visible);<br />
    bool isTextVisible() const;<br />
    Qt::Alignment alignment() const;<br />
    void setAlignment(Qt::Alignment alignment);</p>
<p>public slots:<br />
    void reset();<br />
    void setValue(int value);</p>
<p>signals:<br />
    void valueChanged(int value);<br />
    &#8230;<br />
};<br />
[/code]</p>
<h2>8.2 <code>QAbstractPrintDialog</code> &amp; <code>QAbstractPageSizeDialog</code></h2>
<p>Qt 4.0有2个幽灵类<code>QAbstractPrintDialog</code>和<code>QAbstractPageSizeDialog</code>，作为 <code>QPrintDialog</code>和<code>QPageSizeDialog</code>类的父类。这2个类完全没有用，因为Qt的API没有是<code>QAbstractPrint-</code>或是<code>-PageSizeDialog</code>指针作为参数并执行操作。通过篡改qdoc（Qt文档），我们虽然把这2个类隐藏起来了，却成了无用抽象类的典型案例。</p>
<p>这不是说，<strong><em>好</em></strong> 的抽象是错的，<code>QPrintDialog</code>应该是需要有个工厂或是其它改变的机制 —— 证据就是它声明中的<code>#ifdef QTOPIA_PRINTDIALOG</code>。</p>
<h2>8.3 <code>QAbstractItemModel</code></h2>
<p>关于模型/视图（model/view）问题的细节在相应的文档中已经说明得很好了，但作为一个重要的总结这里还需要强调一下：抽象类不应该仅是所有可能子类的并集（union）。这样『合并所有』的父类几乎不可能是一个好的方案。<code>QAbstractItemModel</code>就犯了这个错误 —— 它实际上就是个<code>QTreeOfTablesModel</code>，结果导致了错综复杂（complicated）的API，而这样的API要让 <strong><em>所有本来设计还不错的子类</em></strong> 去继承。</p>
<p>仅仅增加抽象是不会自动就把API变得更好的。</p>
<h2>8.4 <code>QLayoutIterator</code> &amp; <code>QGLayoutIterator</code></h2>
<p>在Qt 3，创建自定义的布局类需要同时继承<code>QLayout</code>和<code>QGLayoutIterator</code>（命名中的<code>G</code>是指Generic（通用））。<code>QGLayoutIterator</code>子类的实例指针会包装成<code>QLayoutIterator</code>，这样用户可以像和其它的迭代器（iterator）类一样的方式来使用。通过<code>QLayoutIterator</code>可以写出下面这样的代码：</p>
<p>[code language=&#8221;cpp&#8221;]<br />
QLayoutIterator it = layout()-&gt;iterator();<br />
QLayoutItem **child;<br />
while ((child = it.current()) != 0) {<br />
    if (child-&gt;widget() == myWidget) {<br />
        it.takeCurrent();<br />
        return;<br />
    }<br />
    ++it;<br />
}<br />
[/code]</p>
<p>在Qt 4，我们干掉了<code>QGLayoutIterator</code>类（以及用于盒子布局和格子布局的内部子类），转而是让<code>QLayout</code>的子类重写<code>itemAt()</code>、<code>takeAt()</code>和<code>count()</code>。</p>
<h2>8.5 <code>QImageSink</code></h2>
<p>Qt 3有一整套类用来把完成增量加载的图片传递给一个动画 —— <code>QImageSource</code>/<code>Sink</code>/<code>QASyncIO</code>/<code>QASyncImageIO</code>。由于这些类之前只是用于启用动画的<code>QLabel</code>，完全过度设计了（overkill）。</p>
<p>从中得到的教训就是：对于那些未来可能的还不明朗的需求，不要过早地增加抽象设计。当需求真的出现时，比起一个复杂的系统，在简单的系统新增需求要容易得多。<!--



<p align="center"><a href= target=_blank><img decoding="async" src=""></a></p>





<p align="center"><img decoding="async" src="https://coolshell.cn/wp-content/uploads/2020/03/coolshell.weixin.jpg"> <img decoding="async" loading="lazy" src="https://coolshell.cn/wp-content/uploads/2020/03/coolshell.mini_.jpg" width="300" height="300"> <br />关注CoolShell微信公众账号和微信小程序</p>

 

--></p>
<div style="margin-top: 15px; font-size: 16px;color: #cc0000;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 &#8211; CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>

<div class="wp_rp_wrap  wp_rp_vertical_m" ><div class="wp_rp_content"><h3 class="related_post_title">相关文章</h3><ul class="related_post wp_rp"><li ><a href="https://coolshell.cn/articles/5444.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/plugins/wordpress-23-related-posts-plugin/static/thumbs/14.jpg" alt="千万不要把 bool 设计成函数参数" width="150" height="150" /></a><a href="https://coolshell.cn/articles/5444.html" class="wp_rp_title">千万不要把 bool 设计成函数参数</a></li><li ><a href="https://coolshell.cn/articles/4758.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/plugins/wordpress-23-related-posts-plugin/static/thumbs/30.jpg" alt="如何写出无法维护的代码" width="150" height="150" /></a><a href="https://coolshell.cn/articles/4758.html" class="wp_rp_title">如何写出无法维护的代码</a></li><li ><a href="https://coolshell.cn/articles/18360.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2018/05/300x262-150x150.jpg" alt="程序员练级攻略（2018)  与我的专栏" width="150" height="150" /></a><a href="https://coolshell.cn/articles/18360.html" class="wp_rp_title">程序员练级攻略（2018)  与我的专栏</a></li><li ><a href="https://coolshell.cn/articles/17680.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2017/02/gitlab-600-150x150.jpg" alt="从Gitlab误删除数据库想到的" width="150" height="150" /></a><a href="https://coolshell.cn/articles/17680.html" class="wp_rp_title">从Gitlab误删除数据库想到的</a></li><li ><a href="https://coolshell.cn/articles/17459.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2016/08/HighAvailability-BK-150x150.png" alt="关于高可用的系统" width="150" height="150" /></a><a href="https://coolshell.cn/articles/17459.html" class="wp_rp_title">关于高可用的系统</a></li><li ><a href="https://coolshell.cn/articles/12052.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/plugins/wordpress-23-related-posts-plugin/static/thumbs/29.jpg" alt="Leetcode 编程训练" width="150" height="150" /></a><a href="https://coolshell.cn/articles/12052.html" class="wp_rp_title">Leetcode 编程训练</a></li></ul></div></div>The post <a href="https://coolshell.cn/articles/18024.html">API设计原则 – Qt官网的设计实践总结</a> first appeared on <a href="https://coolshell.cn">酷 壳 - CoolShell</a>.]]></content:encoded>
					
					<wfw:commentRss>https://coolshell.cn/articles/18024.html/feed</wfw:commentRss>
			<slash:comments>26</slash:comments>
		
		
			</item>
		<item>
		<title>DHH 谈混合移动应用开发</title>
		<link>https://coolshell.cn/articles/12225.html</link>
					<comments>https://coolshell.cn/articles/12225.html#comments</comments>
		
		<dc:creator><![CDATA[jnj]]></dc:creator>
		<pubDate>Mon, 15 Dec 2014 02:57:20 +0000</pubDate>
				<category><![CDATA[技术读物]]></category>
		<category><![CDATA[杂项资源]]></category>
		<category><![CDATA[Android]]></category>
		<category><![CDATA[Hybrid]]></category>
		<category><![CDATA[iOS]]></category>
		<category><![CDATA[Web]]></category>
		<category><![CDATA[WebView]]></category>
		<category><![CDATA[移动开发]]></category>
		<guid isPermaLink="false">http://coolshell.cn/?p=12225</guid>

					<description><![CDATA[<p>&#160; David，Ruby on Rails 作者，37signals 合伙人 畅销书作家、演说家、赛车手、业余摄影师、顾家好男人 &#160; 37s...</p>
<p class="read-more"><a class="btn btn-default" href="https://coolshell.cn/articles/12225.html"> Read More<span class="screen-reader-text">  Read More</span></a></p>
The post <a href="https://coolshell.cn/articles/12225.html">DHH 谈混合移动应用开发</a> first appeared on <a href="https://coolshell.cn">酷 壳 - CoolShell</a>.]]></description>
										<content:encoded><![CDATA[<p><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3415450859608158"
     crossorigin="anonymous"></script>&nbsp;</p>
<p style="text-align: right;"><img decoding="async" loading="lazy" class="paddging: 10px; 20px; alignright wp-image-16861" src="https://coolshell.cn/wp-content/uploads/2014/12/1053-DHH-150x150.jpg" alt="1053-DHH" width="80" height="80" srcset="https://coolshell.cn/wp-content/uploads/2014/12/1053-DHH-150x150.jpg 150w, https://coolshell.cn/wp-content/uploads/2014/12/1053-DHH-300x300.jpg 300w, https://coolshell.cn/wp-content/uploads/2014/12/1053-DHH-200x200.jpg 200w, https://coolshell.cn/wp-content/uploads/2014/12/1053-DHH-270x270.jpg 270w, https://coolshell.cn/wp-content/uploads/2014/12/1053-DHH.jpg 451w" sizes="(max-width: 80px) 100vw, 80px" />David，Ruby on Rails 作者，37signals 合伙人</p>
<p style="text-align: right;">畅销书作家、演说家、赛车手、业余摄影师、顾家好男人</p>
<p>&nbsp;</p>
<p><a href="http://37signals.com/" target="_blank">37signals</a> 在2013年2月发布了 Basecamp 的 iPhone app，在此之前我们就使用原生开发（native）还是混合开发（hybrid）做了许多尝试。在2012年项目启动的时候，大多数人都倾向于原生开发。</p>
<p>Facebook 在2012年发布了他们新的 iOS app，为了获得更好的用户体验，他们放弃了原来的 HTML5 混合开发方式。考虑到2010～2011年的时候，HTML 在移动端的性能确实不尽如人意，这个决定在当时看来也在情理之中。2010年的时候我们觉得 iPhone 3G/3GS 够眩够快，但按照现在的标准来看它们就太慢了。因此在为移动应用开发做架构设计时，我们需要考虑新的移动设备的计算能力，而不是那些老的过时的设备。</p>
<h4>移动开发架构设计不需要过多考虑设备的性能</h4>
<p>我们从一些测试中得出的一个结论是：现在的移动设备计算能力都很强，运行原生应用和 HTML 应用的效果差别不大，而 HTML 开发的成本则要比原生开发小得多。</p>
<p>当然这个结论在某些领域并不太适用。如果你要开发一个 3D 游戏，原生开发方式能够带来更好的游戏体验。但如果你的移动应用象 Basecamp 一样侧重信息处理，为了降低开发成本，你就可以考虑混合开发方式。我们就是如此，下面是我们三代移动产品的发展轨迹：</p>
<p><span id="more-12225"></span></p>
<h4>第一代产品：原生外壳(native shell)＋嵌套WebView</h4>
<p><img decoding="async" loading="lazy" class="alignright wp-image-16868 size-medium" src="https://coolshell.cn/wp-content/uploads/2014/12/1159-basecamp-app-phones-300x242.jpg" alt="1159-basecamp-app-phones" width="300" height="242" srcset="https://coolshell.cn/wp-content/uploads/2014/12/1159-basecamp-app-phones-300x242.jpg 300w, https://coolshell.cn/wp-content/uploads/2014/12/1159-basecamp-app-phones.jpg 660w" sizes="(max-width: 300px) 100vw, 300px" /></p>
<p>这个版本就是一个简单的原生外壳负责界面导航，嵌套一个 WebView 来显示 Basecamp Rail application，显示的基本上都是我们移动网站页面，再加上一些特殊的样式。</p>
<p>在移动网站的页面上嵌套一个原生的壳，听起来还是 Web 页面，但实际带给用户的体验确是非常不同。用户可以在 Apple App Store 找到我们的 app，他们一旦登录 app 后可以再也不用重新登录（移动版本的 Safari 似乎会经常清空 cookie，让你不得不重新登录）。我们的 app 大受欢迎，用户评分在4和5之间。</p>
<p>整个 app 由一名程序员和一名设计师开发，成本不高，因为我们可以在已有的移动网站的基础上开发。</p>
<p>如果我们当初开发完全原生的 app，用10个人的团队1年半的时间也未必能完成。</p>
<p>&nbsp;</p>
<h4>第二代产品：原生外壳＋原生导航界面</h4>
<p><img decoding="async" loading="lazy" class="alignright wp-image-16869 size-medium" src="https://coolshell.cn/wp-content/uploads/2014/12/1543-unnamed-187x300.png" alt="1543-unnamed" width="187" height="300" srcset="https://coolshell.cn/wp-content/uploads/2014/12/1543-unnamed-187x300.png 187w, https://coolshell.cn/wp-content/uploads/2014/12/1543-unnamed.png 562w" sizes="(max-width: 187px) 100vw, 187px" /></p>
<p>几个月前发布的 Basecamp Android app 是我们的第二代产品，我们在其中做了大量的改进。</p>
<p>从第一代 iPhone app 中我们感受到了原生导航界面的威力，所以在 Android 版本中，我们由 HTML 页面导航转向了原生导航界面。我们从 HTML 页面生成原生导航界面，用户体验更加流畅，原生界面和 HTML 页面的体验差别越来越小，甚至很难区分哪些是原生部分，哪些是 HTML 。</p>
<p>Android 版本是由一两个程序员和一个设计师开发（50%投入）完成的。我们重用了移动站点和 iPhone app 中使用的所有 webview，大大提高了开发效率，同时用户也很买账，超过1000名用户打了4.5~5的高分。</p>
<p>很多公司在抱怨他们的 iOS 移动项目进展缓慢，Android 项目似乎更是如此。或许他们已经习惯了 iOS 项目的开发流程，也许是因为 Android 的屏幕碎片化问题，但是这些对我们来说那都不是事。我们推出的 Android app 表现良好，重用了95%的代码，开发团队也一直保持在小规模。</p>
<p>&nbsp;</p>
<h4>因地制宜地运用原生开发方式</h4>
<p>目前我们正在开发第三代产品，发布的平台暂时保密，不过你应该也不难猜到。在前两代产品中，我们增加了原生导航界面的使用，同时进一步确定了以 webview 为核心的整体架构。在第三代产品中，我们将因地制宜地选择需要使用原生开发的功能，好钢要用在刀刃上。</p>
<p>从之前的100% HTML，到现在的90% HTML +10%原生，我们会选择最值得做原生开发的那10%的部分，最终目的是让 app 原生部分和 HTML 部分的体验没有太大区别。</p>
<p>&nbsp;</p>
<h4>混合开发模式使用的技术</h4>
<p>混合开发模式在技术很简单，主要是处理 webview 的集成、Web 页面的加载，以及原生内容和 HTML 内容之间的交叉链接，其实可能比你想像的还要简单得多。</p>
<p>HTML 方面，我们的 Rails Web 应用支持 Web 和移动两大平台，其中 <a href="http://edgeguides.rubyonrails.org/4_1_release_notes.html#action-pack-variants" target="_blank">Rails 4.1 feature of variants</a> 起了很大的作用。</p>
<p>这也很大程度上有助于我们发布新功能。设想一下如果我们每次需要更新这么多平台：Rails desktop app, a Rails API app, a client-side MVC app, a mobile web wrapper app, an Android app, and an iPhone app，像我们这样只有10个程序员和7个设计师的公司根本无力承担如此巨大的工作量。</p>
<p>除了工作量的减轻，bug 修复效率也提高了，因为大部分的代码逻辑是在 Web 服务器端，我们可以随时修改代码并发布，不用通过 Apple App Store 的审批流程。所以我们的移动 app 和 Web 应用一样，也是持续部署。</p>
<p>就如我之前提到的，混合模式开发并不适用于所有情况。在2010年以前，那时手机的处理能力都不强，所以 HTML/JS 的体验并不好，用户也不喜欢。但是时过境迁，现在手机的处理能力大大提高了，HTML/JS 的性能也不再是一个问题。</p>
<p>&nbsp;</p>
<h4>混合开发模式对原生开发模式的挑战</h4>
<p>混合开发模式在降低开发复杂度方面有它的优势，如果你的产品是以显示和处理信息为主，我认为都可以不同程度地采用这个模式。</p>
<p>对于小型团队和公司而言，并不一定需要采用 iOS 原生 app 先行的模式。使用混合模式，不需要你重头开发一个 app，这样可以降低维护成本，将来扩展到其他平台也更为方便。</p>
<p>当然我知道会有很多人质疑这个模式，或许因为他们的 app 中有很多地方需要原生开发（也许仅仅是他们自己这样认为罢了）。又或许他们已经花了很多时间让 app 里的 UITableView 看起来非常漂亮，以致如果其他地方不这样的话显得不是太完美。再或许大公司就是喜欢耗时耗力的原生开发，有钱就是这么任性。</p>
<p>无论怎样，混合开发当下应该能够成为我们移动开发策略的一个选择。如果你认为这是一个好的选择，那么恭喜你，尽情愉快地玩耍吧！</p>
<p>&nbsp;</p>
<p><em>原文链接：<a href="https://signalvnoise.com/posts/3743?utm_campaign=iOS_Dev_Weekly_Issue_175&amp;utm_medium=email&amp;utm_source=iOS%2BDev%2BWeekly" target="_blank">Hybrid sweet spot: Native navigation, web content</a></em></p>
<p>&nbsp;</p>
<p>下面补充一些 David 答读者问：</p>
<p>&nbsp;</p>
<p>Mike Waite @ 2014-05-08：我很好奇你是如何决定哪些功能要用原生开发？<br />
David @ 2014-05-08：主要靠感觉，这毕竟不是一门科学。如果你感觉你app的某一部分如果用原生开发会更好些，可以尝试做快速原型（spike）。很多时候我们通过这种方式证明我们的想法其实是错的。当然如果你需要使用到手机上的功能如：摄像和其他设备时，HTML目前还不太适用，不过永远也不要把话说死。</p>
<p>&nbsp;</p>
<p>Mike Parsons @ 2014-05-08：好文。很好奇你们是否使用 PhoneGap 或者 Cordova 这样的框架，或者你们自己开发了一个？<br />
David @ 2014-05-08：我们没有使用任何框架。（此处省去xxx字）</p>
<p>&nbsp;</p>
<p>Derick @ 2014-05-08：你怎样解决 Android 浏览器渲染速度慢的问题？这也是 Android 平台上更多人倾向开发原生app得原因。<br />
David @ 2014-05-08：不知道你这个结论是近期的还是以前的？Basecamp 的 Android app 在我的 Nexus 5 和 HTC One 上面运行得非常流畅。<br />
Derick @ 2014-05-08：就是最近。我猜测可能和你使用JavaScript的多少有关系。因为以我个人的经验，Android 上 JavaScript 的运行速度非常慢。如果你感兴趣可以看看下面的文章：<a href="https://www.timroes.de/2013/11/23/old-webview-vs-chromium-webview/" target="_blank">https://www.timroes.de/2013/11/23/old-webview-vs-chromium-webview/</a><br />
David @ 2014-05-08：我们使用了很多JavaScript，当然没有 Web MVC 客户端用得那样多。另外我们使用了 Turbolinks ：）</p>
<p>&nbsp;<!--



<p align="center"><a href= target=_blank><img decoding="async" src=""></a></p>





<p align="center"><img decoding="async" src="https://coolshell.cn/wp-content/uploads/2020/03/coolshell.weixin.jpg"> <img decoding="async" loading="lazy" src="https://coolshell.cn/wp-content/uploads/2020/03/coolshell.mini_.jpg" width="300" height="300"> <br />关注CoolShell微信公众账号和微信小程序</p>

 

--></p>
<div style="margin-top: 15px; font-size: 16px;color: #cc0000;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 &#8211; CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>

<div class="wp_rp_wrap  wp_rp_vertical_m" ><div class="wp_rp_content"><h3 class="related_post_title">相关文章</h3><ul class="related_post wp_rp"><li ><a href="https://coolshell.cn/articles/12136.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2014/11/inbox2-640x264-150x150.jpg" alt="Google Inbox如何跨平台重用代码？" width="150" height="150" /></a><a href="https://coolshell.cn/articles/12136.html" class="wp_rp_title">Google Inbox如何跨平台重用代码？</a></li><li ><a href="https://coolshell.cn/articles/17066.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2015/04/phishing-1-150x150.jpg" alt="关于移动端的钓鱼式攻击" width="150" height="150" /></a><a href="https://coolshell.cn/articles/17066.html" class="wp_rp_title">关于移动端的钓鱼式攻击</a></li><li ><a href="https://coolshell.cn/articles/18360.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2018/05/300x262-150x150.jpg" alt="程序员练级攻略（2018)  与我的专栏" width="150" height="150" /></a><a href="https://coolshell.cn/articles/18360.html" class="wp_rp_title">程序员练级攻略（2018)  与我的专栏</a></li><li ><a href="https://coolshell.cn/articles/18094.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2017/08/enable-https-banner-150x150.png" alt="如何免费的让网站启用HTTPS" width="150" height="150" /></a><a href="https://coolshell.cn/articles/18094.html" class="wp_rp_title">如何免费的让网站启用HTTPS</a></li><li ><a href="https://coolshell.cn/articles/12206.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2014/12/html6-150x150.jpeg" alt="HTML6 展望" width="150" height="150" /></a><a href="https://coolshell.cn/articles/12206.html" class="wp_rp_title">HTML6 展望</a></li><li ><a href="https://coolshell.cn/articles/12012.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2014/10/edsm-150x150.gif" alt="State Threads 回调终结者" width="150" height="150" /></a><a href="https://coolshell.cn/articles/12012.html" class="wp_rp_title">State Threads 回调终结者</a></li></ul></div></div>The post <a href="https://coolshell.cn/articles/12225.html">DHH 谈混合移动应用开发</a> first appeared on <a href="https://coolshell.cn">酷 壳 - CoolShell</a>.]]></content:encoded>
					
					<wfw:commentRss>https://coolshell.cn/articles/12225.html/feed</wfw:commentRss>
			<slash:comments>27</slash:comments>
		
		
			</item>
		<item>
		<title>HTML6 展望</title>
		<link>https://coolshell.cn/articles/12206.html</link>
					<comments>https://coolshell.cn/articles/12206.html#comments</comments>
		
		<dc:creator><![CDATA[jnj]]></dc:creator>
		<pubDate>Sat, 06 Dec 2014 04:41:34 +0000</pubDate>
				<category><![CDATA[Web开发]]></category>
		<category><![CDATA[技术读物]]></category>
		<category><![CDATA[HTML]]></category>
		<category><![CDATA[HTML5]]></category>
		<category><![CDATA[HTML6]]></category>
		<category><![CDATA[Web]]></category>
		<guid isPermaLink="false">http://coolshell.cn/?p=12206</guid>

					<description><![CDATA[<p>HTML5 概述 HTML5 是 HTML 语言最受欢迎的版本之一，它支持音频和视频、离线存储、移动端、和标签属性等等。还提供了&#60;article&#62;,...</p>
<p class="read-more"><a class="btn btn-default" href="https://coolshell.cn/articles/12206.html"> Read More<span class="screen-reader-text">  Read More</span></a></p>
The post <a href="https://coolshell.cn/articles/12206.html">HTML6 展望</a> first appeared on <a href="https://coolshell.cn">酷 壳 - CoolShell</a>.]]></description>
										<content:encoded><![CDATA[<p><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3415450859608158"
     crossorigin="anonymous"></script></p>
<h3><img decoding="async" loading="lazy" class="size-full wp-image-12211 alignright" src="https://coolshell.cn/wp-content/uploads/2014/12/html6.jpeg" alt="html6" width="225" height="225" srcset="https://coolshell.cn/wp-content/uploads/2014/12/html6.jpeg 225w, https://coolshell.cn/wp-content/uploads/2014/12/html6-150x150.jpeg 150w, https://coolshell.cn/wp-content/uploads/2014/12/html6-200x200.jpeg 200w" sizes="(max-width: 225px) 100vw, 225px" /></h3>
<h3>HTML5 概述</h3>
<p>HTML5 是 HTML 语言最受欢迎的版本之一，它支持音频和视频、离线存储、移动端、和标签属性等等。还提供了&lt;article&gt;, &lt;section&gt;, &lt;header&gt;这样的标签来帮助开发者更好地组织页面内容。然而 HTML5 规范仍然没有最后定稿，并且它并不是一个真正意义上的语义标记语言。</p>
<h3>HTML6 展望</h3>
<p>你有没有曾经希望能在 HTML 中使用自定义标签？比如：使用&lt;logo&gt;来显示你的网站logo，还有使用&lt;toolbar&gt;来显示工具栏等等。我们经常使用&lt;div id=&#8221;container&#8221;&gt;和&lt;div id=&#8221;wrapper&#8221;&gt;来组织页面，在 HTML6 里我们希望可以直接使用象&lt;container&gt;和&lt;wrapper&gt;这样的自定义标签。</p>
<p>和 XML 一样，HTML6 应该支持 namespace（命名空间），如：xmlns:xhtml=&#8221;http://www.w3.org/1999/xhtml&#8221;</p>
<p>HTML6 代码样例：</p>
<p><span id="more-12206"></span></p>
<pre>&lt;!DOCTYPE html&gt;
 &lt;html:html&gt;
 &lt;html:head&gt;
 &lt;html:title&gt;A Look Into HTML6&lt;/html:title&gt;
 &lt;html:meta type="title" value="Page Title"&gt;
 &lt;html:meta type="description" value="HTML example with namespaces"&gt;
 &lt;html:link src="css/mainfile.css" title="Styles" type="text/css"&gt;
 &lt;html:link src="js/mainfile.js" title="Script" type="text/javascript"&gt;
 &lt;/html:head&gt;
 &lt;html:body&gt;
 &lt;header&gt;
 &lt;logo&gt;
 &lt;html:media type="image" src="images/xyz.png"&gt;
 &lt;/logo&gt;
 &lt;nav&gt;
 &lt;html:a href="/img1"&gt;a1&lt;/a&gt;
 &lt;html:a href="/img2"&gt;a2&lt;/a&gt;
 &lt;/nav&gt;
 &lt;/header&gt;
 &lt;content&gt;
 &lt;article&gt;
 &lt;h1&gt;Heading of main article&lt;/h1&gt;
 &lt;h2&gt;Sub-heading of main article&lt;/h2&gt;
 &lt;p&gt;[...]&lt;/p&gt;
 &lt;p&gt;[...]&lt;/p&gt;
 &lt;/article&gt;
 &lt;article&gt;
 &lt;h1&gt;The concept of HTML6&lt;/h1&gt;
 &lt;h2&gt;Understanding the basics&lt;/h2&gt;
 &lt;p&gt;[...]&lt;/p&gt;
 &lt;/article&gt;
 &lt;/content&gt;
 &lt;footer&gt;
 &lt;copyright&gt;This site is © to Anonymous 2014&lt;/copyright&gt;
 &lt;/footer&gt;
 &lt;/html:body&gt;
 &lt;/html:html&gt;</pre>
<p>在上面的代码中，你也许注意到了一些奇怪的&lt;html:x&gt;标签，它们是 W3C 和 HTML6 规范中在命名空间里定义的标签。例如：&lt;html:title&gt;负责设定你浏览器的标题栏文字，&lt;html:media&gt;负责显示图片等等。用户可以自己定义标签以便 JavaScript 和 CSS 识别和处理，这样页面代码会更易读，语义更清晰。</p>
<h3>HTML6 APIs</h3>
<p>HTML6 的标签前带有命名空间，如：&lt;html:html&gt;, &lt;html:head&gt;等等。</p>
<p>1. &lt;html:html&gt;</p>
<pre>&lt;!DOCTYPE html&gt;
 &lt;html:html&gt;// this is equivalent to &lt;html&gt; tag written in previous HTML versions
 &lt;!-- sample of HTML document --&gt;
 &lt;/html:html&gt;</pre>
<p>2. &lt;html:head&gt; 和 &lt;head&gt; 标签一样。</p>
<pre>&lt;!DOCTYPE html&gt;
 &lt;html:html&gt;
 &lt;html:head&gt;
 &lt;!-- Main content would come here, like the &lt;html:title&gt; tag --&gt;
 &lt;/html:head&gt;
 &lt;/html:html&gt;</pre>
<p>3. &lt;html:title&gt; 和 &lt;title&gt; 标签类似。</p>
<pre>&lt;!DOCTYPE html&gt;
 &lt;html:html&gt;
 &lt;html:head&gt;
 &lt;html:title&gt;A Look Into HTML6&lt;/html:title&gt;
 &lt;/html:head&gt;
 &lt;/html:html&gt;</pre>
<p>4. &lt;html:meta&gt; 和 &lt;meta&gt; 标签类似，不同之处在于，在 HTML5 中你只能使用标准的元数据类型，如：&#8221;keywords&#8221;, &#8220;description&#8221;, &#8220;author&#8221;等，而在 HTML6 中你可以使用任何元数据类型。</p>
<pre>&lt;!DOCTYPE html&gt;
 &lt;html:html&gt;
 &lt;html:head&gt;
 &lt;html:title&gt;A Look Into HTML6&lt;/html:title&gt;
 &lt;html:meta type="description" value="HTML example with namespaces"&gt;
 &lt;/html:head&gt;
 &lt;/html:html&gt;</pre>
<p>5. &lt;html:link&gt; 和 HTML6 之前版本的 &lt;link&gt; 标签类似。</p>
<pre>&lt;!DOCTYPE html&gt;
 &lt;html:html&gt;
 &lt;html:head&gt;
 &lt;html:title&gt;A Look Into HTML6&lt;/html:title&gt;
 &lt;html:link src="js/mainfile.js" title="Script" type="text/javascript"&gt;
 &lt;/html:head&gt;
 &lt;/html:html&gt;</pre>
<p>6. &lt;html:body&gt; 和 &lt;body&gt; 标签一样。</p>
<pre>&lt;!DOCTYPE html&gt;
 &lt;html:html&gt;
 &lt;html:head&gt;
 &lt;html:title&gt;A Look Into HTML6&lt;/html:title&gt;
 &lt;/html:head&gt;
 &lt;html:body&gt;
 &lt;!-- This is where your website content is placed --&gt;
 &lt;/html:body&gt;
 &lt;/html:html&gt;</pre>
<p>7. &lt;html:a&gt; 和 &lt;a&gt; 标签类似，区别是 &lt;html:a&gt; 只有 &#8220;href&#8221; 一个属性。</p>
<pre>&lt;!DOCTYPE html&gt;
 &lt;html:html&gt;
 &lt;html:head&gt;
 &lt;html:title&gt;A Look Into HTML6&lt;/html:title&gt;
 &lt;/html:head&gt;
 &lt;html:body&gt;
 &lt;html:a href="http://siteurl"&gt;Go to siteurl.com!&lt;/html:a&gt;
 &lt;/html:body&gt;
 &lt;/html:html&gt;</pre>
<p>8. &lt;html：button&gt; 和 &lt;button&gt; 及 &lt;input type=&#8221;button&#8221;&gt; 一样。</p>
<pre>&lt;!DOCTYPE html&gt;
 &lt;html:html&gt;
 &lt;html:head&gt;
 &lt;html:title&gt;A Look Into HTML6&lt;/html:title&gt;
 &lt;/html:head&gt;
 &lt;html:body&gt;
 &lt;html:button&gt;Click Here&lt;/html:button&gt;
 &lt;/html:body&gt;
 &lt;/html:html&gt;</pre>
<p>9. &lt;html:media&gt; 涵盖 &lt;img&gt;, &lt;video&gt;, &lt;embed&gt; 等标签的所有功能。&lt;html:media&gt; 的好处是你不用根据不同的媒体文件类型使用不同的标签，媒体的类型由浏览器从文件内容（类型属性，扩展名，和MIME type）中来判断。</p>
<pre>&lt;!DOCTYPE html&gt;
 &lt;html:html&gt;
 &lt;html:head&gt;
 &lt;html:title&gt;A Look Into HTML6&lt;/html:title&gt;
 &lt;/html:head&gt;
 &lt;html:body&gt;
 &lt;!-- Image would come here --&gt;
 &lt;html:media src="img1/logo.jpg" type="image"&gt;
 &lt;!-- Video doesn't need a type --&gt;
 &lt;html:media src="videos/slide.mov"&gt;
 &lt;/html:body&gt;
 &lt;/html:html&gt;</pre>
<h3>标签类型(Tag types)概述</h3>
<p>和 HTML5 一样， HTML6 也有两种标签类型：单标签（single tag) 和双标签（double tag）</p>
<pre>&lt;html:meta type="author" content="single tag"&gt;
 &lt;html:meta type="author" content="double tag" /&gt;</pre>
<p>单标签不需要结束符&#8217;/&#8217;</p>
<h3>结语</h3>
<p>HTML6 规范还未发布，本文原作者 <a href="http://html6spec.com/">Oscar Godson</a> 只是为我们提供了一个对 HTML6 规范的展望，或者说他希望 HTML6 能够支持的一些新特性。</p>
<p>原文链接：<a href="http://java.dzone.com/articles/look-html6-what-it-and-what">A Look Into HTML6 &#8211; What Is It, and What Does it Have to Offer?</a><!--



<p align="center"><a href= target=_blank><img decoding="async" src=""></a></p>





<p align="center"><img decoding="async" src="https://coolshell.cn/wp-content/uploads/2020/03/coolshell.weixin.jpg"> <img decoding="async" loading="lazy" src="https://coolshell.cn/wp-content/uploads/2020/03/coolshell.mini_.jpg" width="300" height="300"> <br />关注CoolShell微信公众账号和微信小程序</p>

 

--></p>
<div style="margin-top: 15px; font-size: 16px;color: #cc0000;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 &#8211; CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>

<div class="wp_rp_wrap  wp_rp_vertical_m" ><div class="wp_rp_content"><h3 class="related_post_title">相关文章</h3><ul class="related_post wp_rp"><li ><a href="https://coolshell.cn/articles/9666.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2013/05/Render-Process-150x150.jpg" alt="浏览器的渲染原理简介" width="150" height="150" /></a><a href="https://coolshell.cn/articles/9666.html" class="wp_rp_title">浏览器的渲染原理简介</a></li><li ><a href="https://coolshell.cn/articles/6840.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2012/03/css-layouts-150x150.gif" alt="CSS 布局:40个教程、技巧、例子和最佳实践" width="150" height="150" /></a><a href="https://coolshell.cn/articles/6840.html" class="wp_rp_title">CSS 布局:40个教程、技巧、例子和最佳实践</a></li><li ><a href="https://coolshell.cn/articles/5537.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2011/11/stackparts.com_-150x150.png" alt="一些文章资源和趣闻" width="150" height="150" /></a><a href="https://coolshell.cn/articles/5537.html" class="wp_rp_title">一些文章资源和趣闻</a></li><li ><a href="https://coolshell.cn/articles/5224.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2011/09/image008-150x150.jpg" alt="一些文章和各种资源" width="150" height="150" /></a><a href="https://coolshell.cn/articles/5224.html" class="wp_rp_title">一些文章和各种资源</a></li><li ><a href="https://coolshell.cn/articles/4795.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/plugins/wordpress-23-related-posts-plugin/static/thumbs/7.jpg" alt="开源中最好的Web开发的资源" width="150" height="150" /></a><a href="https://coolshell.cn/articles/4795.html" class="wp_rp_title">开源中最好的Web开发的资源</a></li><li ><a href="https://coolshell.cn/articles/3903.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/plugins/wordpress-23-related-posts-plugin/static/thumbs/14.jpg" alt="一些有意思的贴子和工具" width="150" height="150" /></a><a href="https://coolshell.cn/articles/3903.html" class="wp_rp_title">一些有意思的贴子和工具</a></li></ul></div></div>The post <a href="https://coolshell.cn/articles/12206.html">HTML6 展望</a> first appeared on <a href="https://coolshell.cn">酷 壳 - CoolShell</a>.]]></content:encoded>
					
					<wfw:commentRss>https://coolshell.cn/articles/12206.html/feed</wfw:commentRss>
			<slash:comments>39</slash:comments>
		
		
			</item>
		<item>
		<title>Google Inbox如何跨平台重用代码？</title>
		<link>https://coolshell.cn/articles/12136.html</link>
					<comments>https://coolshell.cn/articles/12136.html#comments</comments>
		
		<dc:creator><![CDATA[jnj]]></dc:creator>
		<pubDate>Wed, 26 Nov 2014 00:03:17 +0000</pubDate>
				<category><![CDATA[技术读物]]></category>
		<category><![CDATA[编程工具]]></category>
		<category><![CDATA[Android]]></category>
		<category><![CDATA[Google]]></category>
		<category><![CDATA[iOS]]></category>
		<category><![CDATA[Web]]></category>
		<category><![CDATA[移动应用]]></category>
		<guid isPermaLink="false">http://coolshell.cn/?p=12136</guid>

					<description><![CDATA[<p>原文链接《How Google Inbox shares 70% of its code across Android, iOS, and the Web》 开...</p>
<p class="read-more"><a class="btn btn-default" href="https://coolshell.cn/articles/12136.html"> Read More<span class="screen-reader-text">  Read More</span></a></p>
The post <a href="https://coolshell.cn/articles/12136.html">Google Inbox如何跨平台重用代码？</a> first appeared on <a href="https://coolshell.cn">酷 壳 - CoolShell</a>.]]></description>
										<content:encoded><![CDATA[<p><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3415450859608158"
     crossorigin="anonymous"></script>原文链接《<a href="http://arstechnica.com/information-technology/2014/11/how-google-inbox-shares-70-of-its-code-across-android-ios-and-the-web" target="_blank">How Google Inbox shares 70% of its code across Android, iOS, and the Web</a>》</p>
<p><a href="https://coolshell.cn/wp-content/uploads/2014/11/inbox2-640x264.jpg"><img decoding="async" loading="lazy" class="size-medium wp-image-12137 alignright" src="https://coolshell.cn/wp-content/uploads/2014/11/inbox2-640x264-300x123.jpg" alt="inbox2-640x264" width="300" height="123" /></a></p>
<p>开发一个移动应用在当下并不是一件容易的事情。如果想要获得最多的用户，你的应用通常需要覆盖 iOS, Android, 和 Web 三大平台。这就意味着同一个应用需要开发三个版本，使用 Objective-C 或者 Swift 开发 iOS 版本，使用 Java 开发 Android 版本，使用 JavaScript/CSS/HTML5 开发 Web 版本。工作量增大的同时也意味着有更多的 bug 需要修复。</p>
<p>这个问题也是 Google 在开发 Google Inbox 时致力要解决的。在最近发布的这款应用中，Google 使用了一些工具实现了70%的代码跨平台复用。</p>
<p>Google Inbox 覆盖 iOS, Android, Web 三个平台，它们使用的是同一个后台代码逻辑，只是前端的用户体验和平台相关特性的实现有所不同。Google 自主开发了一套辅助工具将 Android 版本的 Java 代码逻辑编译为 Objective-C (针对 iOS 平台) 和 JavaScript (针对 Web 浏览器)。 Java 到 JavaScript 的编译由 Google Web Toolkit SDK 完成，Java 到 Objective-C 的编译则由 J2ObjC （<a href="j2objc.org">j2objc.org</a>）来完成。</p>
<p>J2ObjC 是一个开源项目，由 Google 在2013年发布。Google Sheets (Google Docs 中的电子表格部分) 也使用了 J2ObjC，而 Google Inbox 则是目前使用 J2Objc 最多的 Google 项目。</p>
<p>Google Inbox 复用的代码逻辑包括：对话 (conversations)，提醒 (reminders)，联系人 (contacts)。还有网络相关功能和离线同步。这些代码逻辑的复用节省了大量的时间和成本。</p>
<p>在产品设计时，Google 将这些可复用功能划分为抽象的逻辑概念，比如：提醒的逻辑放在 &#8220;reminder.java&#8221; 中，可以被 Android UI 调用。对 iOS 版本而言，J2ObjC 将 &#8220;reminder.java&#8221; 编译成 Objective-C 代码，再由 iOS UI 调用。</p>
<p>Google 没有跨平台编译 UI 部分的代码，因为不同平台的UI特性各有不同，盲目统一会导致非常糟糕的用户体验。代码复用只是针对可以共享的后台逻辑，前端的UI实现是完全原生 (native) 的。这与 Xamarin (一个基于 Microsoft C# 的跨平台移动开发工具) 提出的概念类似。</p>
<p>跨平台代码复用通常会带来一些性能上的问题。Garrick Toubassi，Engineering Director 和 Google Inbox 项目组成员，对此表示： “性能上的影响如果有的话，也可以说是微不足道的。我们做过大量的性能测试。因为没有加入额外的中间层来处理跨平台兼容性，所有代码最后都是平台原生代码。J2ObjC 编译生成的目标代码和 Java 源代码拥有大致相同的对象数量和对象图谱复杂度 (object graph complexity) ”。</p>
<p>Google 使用的整套方法解决了跨平台移动开发中的一个很重要的问题，同时也推进了安卓先行 (Android-first) 的移动开发策略。</p>
<p>更多 Google Inbox 文章请猛戳 <a href="http://gmailblog.blogspot.com.au/2014/11/going-under-hood-of-inbox.html">Gmail 官方博客</a>。<!--



<p align="center"><a href= target=_blank><img decoding="async" src=""></a></p>





<p align="center"><img decoding="async" src="https://coolshell.cn/wp-content/uploads/2020/03/coolshell.weixin.jpg"> <img decoding="async" loading="lazy" src="https://coolshell.cn/wp-content/uploads/2020/03/coolshell.mini_.jpg" width="300" height="300"> <br />关注CoolShell微信公众账号和微信小程序</p>

 

--></p>
<div style="margin-top: 15px; font-size: 16px;color: #cc0000;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 &#8211; CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>

<div class="wp_rp_wrap  wp_rp_vertical_m" ><div class="wp_rp_content"><h3 class="related_post_title">相关文章</h3><ul class="related_post wp_rp"><li ><a href="https://coolshell.cn/articles/12225.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2014/12/1053-DHH-150x150.jpg" alt="DHH 谈混合移动应用开发" width="150" height="150" /></a><a href="https://coolshell.cn/articles/12225.html" class="wp_rp_title">DHH 谈混合移动应用开发</a></li><li ><a href="https://coolshell.cn/articles/17066.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2015/04/phishing-1-150x150.jpg" alt="关于移动端的钓鱼式攻击" width="150" height="150" /></a><a href="https://coolshell.cn/articles/17066.html" class="wp_rp_title">关于移动端的钓鱼式攻击</a></li><li ><a href="https://coolshell.cn/articles/5815.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/plugins/wordpress-23-related-posts-plugin/static/thumbs/2.jpg" alt="来信， 创业 和 移动互联网" width="150" height="150" /></a><a href="https://coolshell.cn/articles/5815.html" class="wp_rp_title">来信， 创业 和 移动互联网</a></li><li ><a href="https://coolshell.cn/articles/5224.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2011/09/image008-150x150.jpg" alt="一些文章和各种资源" width="150" height="150" /></a><a href="https://coolshell.cn/articles/5224.html" class="wp_rp_title">一些文章和各种资源</a></li><li ><a href="https://coolshell.cn/articles/3549.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/plugins/wordpress-23-related-posts-plugin/static/thumbs/28.jpg" alt="Android将允许纯C/C++开发应用" width="150" height="150" /></a><a href="https://coolshell.cn/articles/3549.html" class="wp_rp_title">Android将允许纯C/C++开发应用</a></li><li ><a href="https://coolshell.cn/articles/2608.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2010/07/androidappinventor-150x150.jpg" alt="Google App Inventor " width="150" height="150" /></a><a href="https://coolshell.cn/articles/2608.html" class="wp_rp_title">Google App Inventor </a></li></ul></div></div>The post <a href="https://coolshell.cn/articles/12136.html">Google Inbox如何跨平台重用代码？</a> first appeared on <a href="https://coolshell.cn">酷 壳 - CoolShell</a>.]]></content:encoded>
					
					<wfw:commentRss>https://coolshell.cn/articles/12136.html/feed</wfw:commentRss>
			<slash:comments>31</slash:comments>
		
		
			</item>
		<item>
		<title>PFIF网上寻人协议</title>
		<link>https://coolshell.cn/articles/9508.html</link>
					<comments>https://coolshell.cn/articles/9508.html#comments</comments>
		
		<dc:creator><![CDATA[陈皓]]></dc:creator>
		<pubDate>Sun, 21 Apr 2013 16:20:16 +0000</pubDate>
				<category><![CDATA[技术读物]]></category>
		<category><![CDATA[杂项资源]]></category>
		<category><![CDATA[Atom]]></category>
		<category><![CDATA[Google]]></category>
		<category><![CDATA[PFIF]]></category>
		<category><![CDATA[RSS]]></category>
		<category><![CDATA[XML]]></category>
		<guid isPermaLink="false">http://coolshell.cn/?p=9508</guid>

					<description><![CDATA[<p>本文的主要内容来自Wikipedia(http://en.wikipedia.org/wiki/People_Finder_Interchange_Format...</p>
<p class="read-more"><a class="btn btn-default" href="https://coolshell.cn/articles/9508.html"> Read More<span class="screen-reader-text">  Read More</span></a></p>
The post <a href="https://coolshell.cn/articles/9508.html">PFIF网上寻人协议</a> first appeared on <a href="https://coolshell.cn">酷 壳 - CoolShell</a>.]]></description>
										<content:encoded><![CDATA[<p><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3415450859608158"
     crossorigin="anonymous"></script>本文的主要内容来自Wikipedia(<a href="http://en.wikipedia.org/wiki/People_Finder_Interchange_Format" target="_blank">http://en.wikipedia.org/wiki/People_Finder_Interchange_Format</a>)</p>
<p>PFIF全称People Finder Interchange Format，是一个应用广泛的数据开源的标准协议，这个协议主要是设计用来在不同的政府、救援组织、或是其它的一些灾难中生存者和其亲人联系的网站间进行数据交换的一种协议。</p>
<p><img decoding="async" loading="lazy" class="aligncenter" alt="" src="https://coolshell.cn/wp-content/uploads/2013/04/Google-Person-Finder.png" width="492" height="249" /></p>
<p>这个协议基于XML，信息中包括人的身份标识，还有人目前的位置和状态等一些信息。PFIF可以通过Atom和RSS feed出去。PFIF可以允许不同的寻人站点进行数据交换和合并。每一条记录都有一个唯一的标识，这个标识说明了这是由哪个域名创建的。这样，当A站点获得B点的某个人的数据时，在A站点可以对这个人的增加的信息可以转到其它站点上再被增加相关的信息，因为有一个唯一的ID，所以信息可以在不同的站点上被附加。</p>
<p>从wikipedia上看，说起PFIF这个事，得回到2001年的911事件，那时人们一共使用了超过25个不同的在线论坛和网上寻人站来查找相关的亲人和朋友（注：寻人网站英文叫：Survivor Registry，生还者登记网站）。其中一个最大的网站是由伯克利大学的学生Ka-Ping Yee 和 Miriam Walker 开发运行在Millennium计算集群上的safe.millennium.berkeley.edu网站。那时，为了减少各种网站间的混乱，伯克利的寻人网站开始从其它几个比较大的寻人站点收集相关的数据，并人肉整合到一起。</p>
<p><span id="more-9508"></span></p>
<p>2005年，在<a title="Hurricane Katrina" href="http://en.wikipedia.org/wiki/Hurricane_Katrina">卡特里娜飓风</a> 灾难的时候，有数据百万人迁移。于是相关的寻人网站又出现了，而且比911的还要多。于是有很多的志愿者开发了一个叫 <a title="Katrina PeopleFinder Project" href="http://en.wikipedia.org/wiki/Katrina_PeopleFinder_Project">Katrina PeopleFinder Project（卡特里娜寻人项目）</a> 他们人肉地收集不同站点的数据，并统一格式放到一个由Salesfore.com提供一个数据库中。这个项目的组织者David Geilhufe 呼吁一个技术标准以便这些寻人网站间的数据可以自动地整合共享在一起。于是之前伯克利的那个 <a href="http://zesty.ca/" target="_blank">Ka-Ping Yee</a> 开始和志愿者 Kieran Lal，Jonathan Plax 和 <a title="CiviCRM" href="http://en.wikipedia.org/wiki/CiviCRM">CiviCRM</a> 团队一同工作，于是开始了草拟了第一版的PFIF协议，其于2005年9月4日发布，1.1版于第二天发布，其中修改了一些错误。随后，Salesfore.com的数据库开始支持这一标准，然后，Yahoo!和Google的寻人网站也加入这一协议。</p>
<p>接下来， <a title="2010 Haiti earthquake" href="http://en.wikipedia.org/wiki/2010_Haiti_earthquake">2010年的海地地震</a> 时，Google发布了自己的 <a title="Google Person Finder" href="http://en.wikipedia.org/wiki/Google_Person_Finder">Google Person Finder</a>，其基于PFIF协议和CNN，纽约时报，以及美国国家医学图书馆和其它的一些寻人网站进行数据交换。然而，PFIF1.1是基于美国的社会标准搞的，并不适用于海地。于是2010年1月26日，PFIF1.2发布，其增加了几个字段用于标记生还者的国家和国际区号，还有性别，年纪，生日，状态，还有相同人的关联。</p>
<p>PFIF 1.3 于2011年3月发布，其主要解决了个人隐私问题，其加入了一个字段指明该信息的一个有效时间，过期的数据会被删除。PFIF1.3同时移除了英式的first-name和last-name，取而代之的是full-name。</p>
<p>PFIF 1.4 于2012年5月发布，其加入了一个字段用于链接这个人在互联网上的个人资源链接，这样可以用于合并相同的人（比如：指向同一个微博网址），还支持了多个照片。</p>
<p style="text-align: center;"><strong>PFIF1.4的Spec链接：<a href="http://zesty.ca/pfif/1.4/" target="_blank">http://zesty.ca/pfif/1.4/ </a></strong></p>
<p>如下的网站有软件实现了PFIF：</p>
<ul>
<li><a title="Google Person Finder" href="http://en.wikipedia.org/wiki/Google_Person_Finder">Google Person Finder</a></li>
<li><a title="Sahana FOSS Disaster Management System" href="http://en.wikipedia.org/wiki/Sahana_FOSS_Disaster_Management_System">Sahana Eden</a></li>
<li><a href="http://pl.nlm.nih.gov/index.php" rel="nofollow">National Library of Medicine People Locator</a></li>
<li><a title="Ushahidi" href="http://en.wikipedia.org/wiki/Ushahidi#Ushahidi">Ushahidi</a></li>
<li><a href="http://code.google.com/p/pfifnet/" rel="nofollow">PFIF .NET Library</a></li>
<li><a href="http://erislabs.net/ianb/projects/pfif/" rel="nofollow">XML::PFIF Perl module</a></li>
</ul>
<p>本次四川地震，谷歌率先发布了他人寻人网站：<a href="https://google.org/personfinder/2013-sichuan-earthquake" target="_blank">https://google.org/personfinder/2013-sichuan-earthquake</a>。接下来，国内的百度，360，搜索，一淘，CSDN，高德……都发布了自己的寻人网站，微博上，大家都在说这些企业不应该搞这么多这样的网站，这样只会造成混乱。而且大家都在呼吁大家一起运作一个网站，共享数据，共享信息。晚上，我在微博上看到了这个PFIF协议，于是写下这篇文章。</p>
<p>关于Google 的寻人的数据可以通过Google PersonFinder API 下载和上传，这里是其API页面：</p>
<p style="text-align: center;"><strong><a href="http://code.google.com/p/googlepersonfinder/wiki/DataAPI" target="_blank">http://code.google.com/p/googlepersonfinder/wiki/DataAPI</a></strong></p>
<p><!--



<p align="center"><a href= target=_blank><img decoding="async" src=""></a></p>





<p align="center"><img decoding="async" src="https://coolshell.cn/wp-content/uploads/2020/03/coolshell.weixin.jpg"> <img decoding="async" loading="lazy" src="https://coolshell.cn/wp-content/uploads/2020/03/coolshell.mini_.jpg" width="300" height="300"> <br />关注CoolShell微信公众账号和微信小程序</p>

 

--></p>
<div style="margin-top: 15px; font-size: 16px;color: #cc0000;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 &#8211; CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>

<div class="wp_rp_wrap  wp_rp_vertical_m" ><div class="wp_rp_content"><h3 class="related_post_title">相关文章</h3><ul class="related_post wp_rp"><li ><a href="https://coolshell.cn/articles/22398.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2023/02/chatgpt-150x150.jpg" alt="我看ChatGPT: 为啥谷歌掉了千亿美金" width="150" height="150" /></a><a href="https://coolshell.cn/articles/22398.html" class="wp_rp_title">我看ChatGPT: 为啥谷歌掉了千亿美金</a></li><li ><a href="https://coolshell.cn/articles/12136.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2014/11/inbox2-640x264-150x150.jpg" alt="Google Inbox如何跨平台重用代码？" width="150" height="150" /></a><a href="https://coolshell.cn/articles/12136.html" class="wp_rp_title">Google Inbox如何跨平台重用代码？</a></li><li ><a href="https://coolshell.cn/articles/5815.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/plugins/wordpress-23-related-posts-plugin/static/thumbs/2.jpg" alt="来信， 创业 和 移动互联网" width="150" height="150" /></a><a href="https://coolshell.cn/articles/5815.html" class="wp_rp_title">来信， 创业 和 移动互联网</a></li><li ><a href="https://coolshell.cn/articles/5701.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/plugins/wordpress-23-related-posts-plugin/static/thumbs/24.jpg" alt="SteveY对Amazon和Google平台的吐槽" width="150" height="150" /></a><a href="https://coolshell.cn/articles/5701.html" class="wp_rp_title">SteveY对Amazon和Google平台的吐槽</a></li><li ><a href="https://coolshell.cn/articles/5224.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2011/09/image008-150x150.jpg" alt="一些文章和各种资源" width="150" height="150" /></a><a href="https://coolshell.cn/articles/5224.html" class="wp_rp_title">一些文章和各种资源</a></li><li ><a href="https://coolshell.cn/articles/4905.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/plugins/wordpress-23-related-posts-plugin/static/thumbs/3.jpg" alt="语言的数据亲和力" width="150" height="150" /></a><a href="https://coolshell.cn/articles/4905.html" class="wp_rp_title">语言的数据亲和力</a></li></ul></div></div>The post <a href="https://coolshell.cn/articles/9508.html">PFIF网上寻人协议</a> first appeared on <a href="https://coolshell.cn">酷 壳 - CoolShell</a>.]]></content:encoded>
					
					<wfw:commentRss>https://coolshell.cn/articles/9508.html/feed</wfw:commentRss>
			<slash:comments>24</slash:comments>
		
		
			</item>
		<item>
		<title>Why C++ ? 王者归来</title>
		<link>https://coolshell.cn/articles/6548.html</link>
					<comments>https://coolshell.cn/articles/6548.html#comments</comments>
		
		<dc:creator><![CDATA[陈皓]]></dc:creator>
		<pubDate>Thu, 02 Feb 2012 00:22:57 +0000</pubDate>
				<category><![CDATA[C/C++语言]]></category>
		<category><![CDATA[业界新闻]]></category>
		<category><![CDATA[技术读物]]></category>
		<category><![CDATA[编程语言]]></category>
		<category><![CDATA[C++]]></category>
		<category><![CDATA[Performance]]></category>
		<guid isPermaLink="false">http://coolshell.cn/?p=6548</guid>

					<description><![CDATA[<p>因为又有人邀请我去Quora的C2C网站去回答问题去了，这回是 关于 @laiyonghao 的这篇有点争议的博文《2012 不宜进入的三个技术点》Action...</p>
<p class="read-more"><a class="btn btn-default" href="https://coolshell.cn/articles/6548.html"> Read More<span class="screen-reader-text">  Read More</span></a></p>
The post <a href="https://coolshell.cn/articles/6548.html">Why C++ ? 王者归来</a> first appeared on <a href="https://coolshell.cn">酷 壳 - CoolShell</a>.]]></description>
										<content:encoded><![CDATA[<p><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3415450859608158"
     crossorigin="anonymous"></script>因为又有人邀请我去Quora的C2C网站去回答问题去了，这回是 关于 <a href="http://weibo.com/n/laiyonghao">@laiyonghao</a> 的这篇有点争议的博文《2012 不宜进入的三个技术点》ActionScript，Thread 和 C++，<a href="http://blog.csdn.net/lanphaday/article/details/7223385" target="_blank"> C++争议的争议最大</a>。（要我说，.NET比C++更需要慎重进入，呵）。我就在这里回复一下这个问题吧。</p>
<p>正好我一个月前看到一个视频，这个演讲视频还比较著名，这个演讲者是<em>Exceptional C++ </em>和 <em>C++ Coding Standards</em> 的作者，还是ISO C++ 委员会的Chair，C++/CLI首席架构师，还是Microsoft的软件架构师，他叫<a href="http://herbsutter.com/" target="_blank">Herb Sutter</a>，他的这个演讲视频是 <a href="http://cppandbeyond.com/" target="_blank">C++ and Beyond 2011</a>上的一次公开演讲，题目是——<a href="http://channel9.msdn.com/posts/C-and-Beyond-2011-Herb-Sutter-Why-C" target="_blank">Why C++</a>? （如果你觉得那里的视频比较慢，你可以看<a href="http://v.youku.com/v_show/id_XMzA5OTIwODIw.html" target="_blank">优酷上的视频</a>）（英文听力好的同学可以看一样，因为都没有中文字幕）</p>
<p>我觉得这篇文章就足够可以说明很多问题了，所以，我把Herb的演讲幻灯片截了几页放到这里，并做上一些注释，算是一个演讲内容摘要吧。</p>
<p>1） 为什么C++？因为 Performance per $，也就是说performance 就是钱，这个分成三个方面，</p>
<ul>
<li>耗电，芯片的耗电量，移动设备的耗电量，家用电脑的耗电量都和钱有关系。</li>
<li>资源，家用电脑和移动设备上的处理器资源有限，因为要让一般消费者买的起。</li>
<li>体验，在更小的设备上会有更好的体验，有更好的体验就可以挣更多的钱。</li>
</ul>
<p>移动设备上的耗电量相信用过智能手机的人都知道吧，Android手机的耗电量实在是太大了。就算是iPhone在开启Wifi和3G的情况下耗电量也很快。</p>
<p><img decoding="async" loading="lazy" class="aligncenter size-full wp-image-6550" title="" src="https://coolshell.cn/wp-content/uploads/2012/02/WhyCPP.01.jpg" alt="" width="566" height="319" /></p>
<p><span id="more-6548"></span></p>
<p>2）C++的进化分成三个时代：</p>
<ul>
<li>1979 &#8211; 1989：研究C的对象能力。主要是为C++做准备</li>
<li>1989 &#8211; 1999：C++成了主流。</li>
<li>1999 &#8211; 2009：Coffee-based语言（Java, .NET）出现了，极大的提高了开发生产力。</li>
</ul>
<p style="padding-left: 30px;">对于第三个时代，Herb说了很多，他说这个并没有什么错，因为这个时候我们非常关注开发的生产力，这个非常重要，这就是为什么C++一下就失去优势的地方。但是是否这些Coffee-Based的语言可以做任重要的事呢？不行，很多时候，这是一个Trade-Off的事，也就是生产力不是免费的是需要你用别的东西去交换的。</p>
<p><img decoding="async" loading="lazy" class="aligncenter size-full wp-image-6551" title="" src="https://coolshell.cn/wp-content/uploads/2012/02/WhyCPP.02.jpg" alt="" width="567" height="319" /></p>
<p>3）第四个时期。</p>
<p style="padding-left: 30px;">Herb认为，2009-2019是第四个时期，因为我们又喜欢Native Code了，C++从被驱逐后又被请回来了。因为网站的性能越来越是个问题，移动端的设备非常流行。但主要是因为Performance就是钱，因为前面的三个因素，性能影响的是dollar，不尊重性能的公司都会发现花钱的速度太快了。（比如去年大家热炒的京东促销和12306.cn的问题，12306给整个社会造成了巨大的金钱浪费）</p>
<p style="padding-left: 30px;">Herb把这个时期比做 The Return of the King。（指环王的第三部：王者归来）<strong> 性能为王！</strong></p>
<p style="padding-left: 30px;">这就好像我在“<a title="软件开发的“三重门”" href="https://coolshell.cn/articles/6526.html" target="_blank">软件开发的三重门</a>”里说的，开垦时代需要的是快和生产力，而开垦完后就得保证其稳定性。</p>
<p><img decoding="async" loading="lazy" class="aligncenter size-full wp-image-6552" title="" src="https://coolshell.cn/wp-content/uploads/2012/02/WhyCPP.03.jpg" alt="" width="567" height="318" /></p>
<p>4）Herb还给了一张幻灯片问，“The World is built on &#8230;.”，后面例出了多个语言。然后Herb说，世界是由C和C++构成的。</p>
<p style="text-align: center;"><img decoding="async" loading="lazy" class="aligncenter  wp-image-6562" title="WhyCPP.03.01" src="https://coolshell.cn/wp-content/uploads/2012/02/WhyCPP.03.01.jpg" alt="" width="397" height="224" /></p>
<p>5）Herb给了一张表格，这张表可相当形像。如果把我们的对编程语言的需求总结为四个：<strong>效率，灵活，抽象，生产率</strong>。那么，C语言玩的是前两个，而C++玩的是前三个，Java和C#玩的是后两个（抽象和生产率）</p>
<p>任保一种设计都不可能让你什么都要的，这就是Trade-Off——什么事都需要交换的。</p>
<p><img decoding="async" loading="lazy" class="aligncenter size-full wp-image-6553" title="" src="https://coolshell.cn/wp-content/uploads/2012/02/WhyCPP.04.jpg" alt="" width="567" height="318" /></p>
<p>6）Herb举了一个微软内的例子，用C++ 和 ATL 来开发IE工具条的报告，意思是你可以用脚本在IE的工具条上加按钮，但是作者建议使用C++，因为用.NET或是脚本有重大的limitation，尤其是性能上的问题。</p>
<p style="text-align: center;"><img decoding="async" loading="lazy" class="aligncenter  wp-image-6554" src="https://coolshell.cn/wp-content/uploads/2012/02/WhyCPP.05.jpg" alt="" width="600" height="339" /></p>
<p style="text-align: left;">7）接下来，我们来看看移动设备。</p>
<p style="text-align: left; padding-left: 30px;">下图中，第一个是iOS，第二个是Android，第三个是WinPhone。Herd说了几个事：</p>
<p style="text-align: left; padding-left: 30px;">a）比Web APP，人们更喜欢Native的APP，这个在用移动设备上可以得到验证。</p>
<p style="text-align: left; padding-left: 30px;">b）iOS也好，Android也好，WinPhone也好，他们不是在搞操作系统，而是在搞应用，为的是让智能手机更好。手机就是一个App。</p>
<p style="text-align: left; padding-left: 30px;">c）这三个手机在第一版出来时都不支持C++，而第二版出来时都支持C++了。因为他们要兼顾性能和一定程度上的开发效率。WinPhone还没有到第二版，让我们拭目以待。（我以前写过一篇<a title="Android将允许纯C/C++开发应用" href="https://coolshell.cn/articles/3549.html" target="_blank">调侃Android支持C++开发</a>的文章，这也只是一年前的事，说明C++全面回归了）</p>
<p><img decoding="async" loading="lazy" class="aligncenter size-full wp-image-6555" title="" src="https://coolshell.cn/wp-content/uploads/2012/02/WhyCPP.06.jpg" alt="" width="567" height="319" /></p>
<p>8）如果你还是不相信的话，我们可以看看为什么Apple和Google都在搞C++的编译器，因为他们觉得g++性能不行。所以，基于LLVM的编译器正在领导潮流，因为我们关注Natvie Code的性能优化。</p>
<p><img decoding="async" loading="lazy" class="aligncenter size-full wp-image-6556" title="" src="https://coolshell.cn/wp-content/uploads/2012/02/WhyCPP.07.jpg" alt="" width="539" height="615" /></p>
<p>9）接下来，Herb说了一下数据中心，你知道数据中心最花钱的是什么吗？三个事：</p>
<blockquote>
<ul>
<li>57% 花在了硬件上。</li>
<li>18% 花在了配电和降温上。</li>
<li>13% 花在了耗电上。</li>
</ul>
</blockquote>
<p style="padding-left: 30px;">88%的钱花在了硬件和电力上。这可是很大一笔费用啊。（还有人说硬件比软件便宜吗？）我记得我上一个公司的数据中心每年要花的电费就在百万美元以上。</p>
<p><img decoding="async" loading="lazy" class="aligncenter size-full wp-image-6557" title="" src="https://coolshell.cn/wp-content/uploads/2012/02/WhyCPP.08.jpg" alt="" width="566" height="319" /></p>
<p>10）昨天在<a href="http://weibo.com/1401880315/y3kshD9jf" target="_blank">微博上有个笑话</a>，说是某咨询师要求程序员把代码打印出来走查，程序员问是不是要用彩打？哈哈。我说，这至少不环保嘛。消耗太大了。是的，C++是可以省电的，以及于C++之父都在YouTube 说C++是可以减轻全球变暖的问题。哇，C++开始真正造福人类了。</p>
<p><img decoding="async" loading="lazy" class="aligncenter size-full wp-image-6558" title="" src="https://coolshell.cn/wp-content/uploads/2012/02/WhyCPP.09.jpg" alt="" width="516" height="397" /></p>
<p>11）我还需要重温一下老大的这句话——</p>
<blockquote><p><strong>My contribution to the fight against global warming is C++’s efficiency</strong>: Just think if Google had to have twice as many server farms! Each uses as much energy as a small town. And it’s not just a factor of two…<strong> Efficiency is not just running fast or running bigger programs, it’s also running using less resources</strong>.</p>
<p style="text-align: right;">Bjarne Stroustrup, June 2011</p>
</blockquote>
<p style="text-align: left; padding-left: 30px;">最后一句说的非常好！<strong>效率不仅仅只是跑得，跑得多，更是可以使用更少的资源</strong>。</p>
<p style="text-align: left;">12）下面让我们再来看一张表，一张把钱投到哪里的表格，这样我们可以看到一些趋势。</p>
<ul>
<li>70年代80年代，资源不够，主要是把钱投在性能上。</li>
<li>80年代到90代，主要是90年代开始有一半的投次到了抽象和生产率上。</li>
<li>00年代，完全都在抽象和生产率上。</li>
<li>10年代，80%的钱都要回头来解决性能问题。这就是C/C++的王者归来。</li>
</ul>
<p><img decoding="async" loading="lazy" class="aligncenter size-full wp-image-6559" title="" src="https://coolshell.cn/wp-content/uploads/2012/02/WhyCPP.10.jpg" alt="" width="567" height="319" /></p>
<p>13）当然，不是C++不注重 开发效率，看看C++0X的标准引入了多少东西我们就知道了。但是本质上，<strong>C++还是致力于性能和抽象的完全平衡</strong>。</p>
<p><img decoding="async" loading="lazy" class="aligncenter size-full wp-image-6560" title="" src="https://coolshell.cn/wp-content/uploads/2012/02/WhyCPP.11.jpg" alt="" width="567" height="319" /></p>
<p>那么，我们还会觉得C++要被淘汰了，不适合进入了吗？看完这个演讲，你应该有答案的。</p>
<p>后面讲了C++的文艺复兴，你可以在Google 搜索 “<a href="https://www.google.com/search?q=C%2B%2B+Renaissance" target="_blank">C++ Renaissance</a>”看看。另外，<strong>该视频的讲议可以在<a href="http://ecn.channel9.msdn.com/content/WhyCPPCB2011.pdf" target="_blank">这里下载</a></strong>。</p>
<p>（全文完）<!--



<p align="center"><a href= target=_blank><img decoding="async" src=""></a></p>





<p align="center"><img decoding="async" src="https://coolshell.cn/wp-content/uploads/2020/03/coolshell.weixin.jpg"> <img decoding="async" loading="lazy" src="https://coolshell.cn/wp-content/uploads/2020/03/coolshell.mini_.jpg" width="300" height="300"> <br />关注CoolShell微信公众账号和微信小程序</p>

 

--></p>
<div style="margin-top: 15px; font-size: 16px;color: #cc0000;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 &#8211; CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>

<div class="wp_rp_wrap  wp_rp_vertical_m" ><div class="wp_rp_content"><h3 class="related_post_title">相关文章</h3><ul class="related_post wp_rp"><li ><a href="https://coolshell.cn/articles/8239.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2012/09/lock_free_bicycle-150x150.jpg" alt="无锁队列的实现" width="150" height="150" /></a><a href="https://coolshell.cn/articles/8239.html" class="wp_rp_title">无锁队列的实现</a></li><li ><a href="https://coolshell.cn/articles/7886.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2012/07/muxnt-150x150.jpg" alt="代码执行的效率" width="150" height="150" /></a><a href="https://coolshell.cn/articles/7886.html" class="wp_rp_title">代码执行的效率</a></li><li ><a href="https://coolshell.cn/articles/22242.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2022/05/etcd-150x150.png" alt="ETCD的内存问题" width="150" height="150" /></a><a href="https://coolshell.cn/articles/22242.html" class="wp_rp_title">ETCD的内存问题</a></li><li ><a href="https://coolshell.cn/articles/20845.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2020/03/rust-social-wide-150x150.jpg" alt="Rust语言的编程范式" width="150" height="150" /></a><a href="https://coolshell.cn/articles/20845.html" class="wp_rp_title">Rust语言的编程范式</a></li><li ><a href="https://coolshell.cn/articles/18360.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2018/05/300x262-150x150.jpg" alt="程序员练级攻略（2018)  与我的专栏" width="150" height="150" /></a><a href="https://coolshell.cn/articles/18360.html" class="wp_rp_title">程序员练级攻略（2018)  与我的专栏</a></li><li ><a href="https://coolshell.cn/articles/18024.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2017/07/api-design-300x278-2-150x150.jpg" alt="API设计原则 &#8211; Qt官网的设计实践总结" width="150" height="150" /></a><a href="https://coolshell.cn/articles/18024.html" class="wp_rp_title">API设计原则 &#8211; Qt官网的设计实践总结</a></li></ul></div></div>The post <a href="https://coolshell.cn/articles/6548.html">Why C++ ? 王者归来</a> first appeared on <a href="https://coolshell.cn">酷 壳 - CoolShell</a>.]]></content:encoded>
					
					<wfw:commentRss>https://coolshell.cn/articles/6548.html/feed</wfw:commentRss>
			<slash:comments>145</slash:comments>
		
		
			</item>
		<item>
		<title>一些有意思的算法代码</title>
		<link>https://coolshell.cn/articles/6010.html</link>
					<comments>https://coolshell.cn/articles/6010.html#comments</comments>
		
		<dc:creator><![CDATA[陈皓]]></dc:creator>
		<pubDate>Tue, 29 Nov 2011 03:11:07 +0000</pubDate>
				<category><![CDATA[C/C++语言]]></category>
		<category><![CDATA[Java语言]]></category>
		<category><![CDATA[Python]]></category>
		<category><![CDATA[技术读物]]></category>
		<category><![CDATA[杂项资源]]></category>
		<category><![CDATA[编程语言]]></category>
		<category><![CDATA[Algorithm]]></category>
		<category><![CDATA[C++]]></category>
		<category><![CDATA[算法]]></category>
		<guid isPermaLink="false">http://coolshell.cn/?p=6010</guid>

					<description><![CDATA[<p>Keith Schwarz是一个斯坦福大学计算机科学系的讲师。他对编程充满了热情。他的主页上他自己正在实现各种各样的有意思的算法和数据结构，http://www...</p>
<p class="read-more"><a class="btn btn-default" href="https://coolshell.cn/articles/6010.html"> Read More<span class="screen-reader-text">  Read More</span></a></p>
The post <a href="https://coolshell.cn/articles/6010.html">一些有意思的算法代码</a> first appeared on <a href="https://coolshell.cn">酷 壳 - CoolShell</a>.]]></description>
										<content:encoded><![CDATA[<p><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3415450859608158"
     crossorigin="anonymous"></script>Keith Schwarz是一个斯坦福大学计算机科学系的讲师。他对编程充满了热情。他的主页上他自己正在实现各种各样的有意思的算法和数据结构，<a href="http://www.keithschwarz.com/interesting/">http://www.keithschwarz.com/interesting/</a>， 目前这个网页上有88个（见下面的列表），但这位大哥要干135个，你可以看看他的<a href="http://www.keithschwarz.com/interesting/" target="_blank">To-Do List</a>。</p>
<p>从这个列表上，我们可以看到，他从去年7月份就在自己实现这些东西了，我把他实现的这些算法转过来，</p>
<ul>
<li>一方面我们可以学习一下这些算法和代码，因为很多东西对我来说都比较新，我以前<a href="https://coolshell.cn/articles/2583.html" target="_blank">列举过一些经典的算法</a>，<a title="链接：算法和数据结构词典" href="https://coolshell.cn/articles/1499.html" rel="bookmark">算法和数据结构词典</a>，还有<a title="链接：可视化的数据结构和算法" href="https://coolshell.cn/articles/4671.html" rel="bookmark">可视化的数据结构和算法</a>， 不过感觉都没有这个全。</li>
</ul>
<ul>
<li>另一方面我希望这个事可以影响到一些正在学习编程的人。看看别人是怎么学习编程的，希望对你有借鉴作用。</li>
</ul>
<table width="100%" border="0" cellspacing="0" cellpadding="6">
<thead>
<tr>
<th>Name</th>
<th>Link</th>
<th>Date Added</th>
<th>Language</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Binomial Heap</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=binomial-heap">(link)</a></td>
<td>7‑24‑2010</td>
<td>C++</td>
<td>An implementation of a <a href="http://en.wikipedia.org/wiki/Binomial_heap">binomial heap</a> data structure for use as a priority queue.</td>
</tr>
<tr>
<td>Bounded Priority Queue</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=bounded-pqueue">(link)</a></td>
<td>7‑24‑2010</td>
<td>C++</td>
<td>An implementation of a <a href="http://en.wikipedia.org/wiki/Priority_queue">priority queue</a> with a fixed upper limit to its size..</td>
</tr>
<tr>
<td>Matrix</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=matrix">(link)</a></td>
<td>7‑24‑2010</td>
<td>C++</td>
<td>A collection of classes for manipulating <a href="http://en.wikipedia.org/wiki/Matrix_%28mathematics%29">matrices</a>.</td>
</tr>
<tr>
<td>VList</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=vlist">(link)</a></td>
<td>8‑16‑2010</td>
<td>Java</td>
<td>An implementation of the <tt>List</tt> abstraction backed by a <a href="http://en.wikipedia.org/wiki/VList">VList</a>.</td>
</tr>
<tr>
<td>Function Wrapper</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=function">(link)</a></td>
<td>8‑16‑2010</td>
<td>C++</td>
<td>A C++ wrapper class around unary functions.</td>
</tr>
<tr>
<td>String</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=string">(link)</a></td>
<td>8‑17‑2010</td>
<td>C++</td>
<td>An implementation of a <a href="http://en.wikipedia.org/wiki/String_(computer_science)">string</a> abstraction that uses the small string optimization.</td>
</tr>
</tbody>
</table>
<p><span id="more-6010"></span></p>
<table>
<tbody>
<tr>
<td>nstream</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=nstream">(link)</a></td>
<td>8‑31‑2010</td>
<td>C++</td>
<td>An stream class that sends and receives data over a network.</td>
</tr>
<tr>
<td>Snake</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=snake">(link)</a></td>
<td>8‑31‑2010</td>
<td>C++</td>
<td>An implementation of the game <a href="http://en.wikipedia.org/wiki/Snake_(video_game)"><em>Snake</em></a> with a rudimentary AI.</td>
</tr>
<tr>
<td>Mergesort</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=mergesort">(link)</a></td>
<td>9‑14‑2010</td>
<td>C++</td>
<td>An implementation of the <a href="http://en.wikipedia.org/wiki/Mergesort">mergesort</a> algorithm.</td>
</tr>
<tr>
<td>Next Permutation</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=next-permutation">(link)</a></td>
<td>10‑6‑2010</td>
<td>C++</td>
<td>An implementation of the <a href="http://www.cplusplus.com/reference/algorithm/next_permutation/"><tt>next_permutation</tt></a> STL algorithm.</td>
</tr>
<tr>
<td>Interval Heap</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=interval-heap">(link)</a></td>
<td>10‑17‑2010</td>
<td>Java</td>
<td>An implementation of a <a href="http://en.wikipedia.org/wiki/Double-ended_priority_queue">double-ended priority queue</a> using an <a href="http://www.mhhe.com/engcs/compsci/sahni/enrich/c9/interval.pdf">interval heap</a>.</td>
</tr>
<tr>
<td>Linear-Time Selection</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=median-of-medians">(link)</a></td>
<td>10‑18‑2010</td>
<td>C++</td>
<td>A deterministic, linear-time <a href="http://en.wikipedia.org/wiki/Selection_algorithm">selection algorithm</a> using the <a href="http://en.wikipedia.org/wiki/Selection_algorithm#Linear_general_selection_algorithm_-_Median_of_Medians_algorithm">median-of-medians</a> algorithm.</td>
</tr>
<tr>
<td>Heapsort</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=heapsort">(link)</a></td>
<td>10‑18‑2010</td>
<td>C++</td>
<td>An implementation of the <a href="http://en.wikipedia.org/wiki/Heapsort">heapsort</a> algorithm.</td>
</tr>
<tr>
<td>Union-Find</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=union-find">(link)</a></td>
<td>10‑19‑2010</td>
<td>Java</td>
<td>An implementation of a <a href="http://en.wikipedia.org/wiki/Disjoint-set_data_structure">disjoint-set data structure</a> using a disjoint set forest.</td>
</tr>
<tr>
<td>Radix Sort</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=radix-sort">(link)</a></td>
<td>10‑19‑2010</td>
<td>C++</td>
<td>An implementation of the <a href="http://en.wikipedia.org/wiki/Radix_sort">radix sort</a> algorithm.</td>
</tr>
<tr>
<td>Rational</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=rational">(link)</a></td>
<td>10‑23‑2010</td>
<td>C++</td>
<td>A data structure representing a <a href="http://en.wikipedia.org/wiki/Rational_number">rational number</a>.</td>
</tr>
<tr>
<td>DPLL</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=dpll">(link)</a></td>
<td>10‑23‑2010</td>
<td>Haskell</td>
<td>An implementation of the <a href="http://en.wikipedia.org/wiki/DPLL_algorithm">DPLL algorithm</a> for solving <a href="http://en.wikipedia.org/wiki/Boolean_satisfiability_problem">CNF-SAT</a>.</td>
</tr>
<tr>
<td>Smoothsort</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=smoothsort">(link)</a></td>
<td>10‑27‑2010</td>
<td>C++</td>
<td>An implementation of the <a href="http://www.keithschwarz.com/smoothsort/">smoothsort algorithm</a>, an adaptive heapsort variant.</td>
</tr>
<tr>
<td>Extendible Array</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=extendible-array">(link)</a></td>
<td>10‑28‑2010</td>
<td>Java</td>
<td>A <a href="http://en.wikipedia.org/wiki/Dynamic_array">dynamic array</a> class with O(1) worst-case runtime lookup and append.</td>
</tr>
<tr>
<td>In-Place Merge</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=inplace-merge">(link)</a></td>
<td>10‑29‑2010</td>
<td>C++</td>
<td>An implementation of a <a href="http://en.wikipedia.org/wiki/Merge_algorithm">merge algorithm</a> that runs <a href="http://en.wikipedia.org/wiki/In-place_algorithm">in-place</a>.</td>
</tr>
<tr>
<td>Random Shuffle</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=random-shuffle">(link)</a></td>
<td>10‑29‑2010</td>
<td>C++</td>
<td>An algorithm for generating a <a href="http://en.wikipedia.org/wiki/Random_permutation">random permutation</a> of a set of elements.</td>
</tr>
<tr>
<td>Random Sample</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=random-sample">(link)</a></td>
<td>10‑29‑2010</td>
<td>C++</td>
<td>An O(n) time, O(1) space algorithm for randomly choosing k elements out of a stream with uniform probability.</td>
</tr>
<tr>
<td>Natural Mergesort</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=natural-mergesort">(link)</a></td>
<td>10‑30‑2010</td>
<td>C++</td>
<td>An implementation of <a href="http://www.algorithmist.com/index.php/Merge_sort#Natural_mergesort">natural mergesort</a>, an <a href="http://en.wikipedia.org/wiki/Adaptive_sort">adaptive</a> variant of <a href="http://en.wikipedia.org/wiki/Merge_sort">mergesort</a>.</td>
</tr>
<tr>
<td>Interpolation Search</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=interpolation-search">(link)</a></td>
<td>10‑31‑2010</td>
<td>C++</td>
<td>An implementation of the <a href="http://en.wikipedia.org/wiki/Interpolation_search">interpolation search</a> algorithm.</td>
</tr>
<tr>
<td>Introsort</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=introsort">(link)</a></td>
<td>10‑31‑2010</td>
<td>C++</td>
<td>An implementation of the <a href="http://en.wikipedia.org/wiki/Introsort">introsort</a> algorithm, a fast hybrid of <a href="http://en.wikipedia.org/wiki/Quicksort">quicksort</a>, <a href="http://en.wikipedia.org/wiki/Heapsort">heapsort</a>, and<a href="http://en.wikipedia.org/wiki/Insertion_sort">insertion sort</a>.</td>
</tr>
<tr>
<td>Hashed Array Tree</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=hashed-array-tree">(link)</a></td>
<td>11‑3‑2010</td>
<td>Java</td>
<td>An implementation of a dynamic array backed by a <a href="http://en.wikipedia.org/wiki/Hashed_array_tree">hashed array tree</a>.</td>
</tr>
<tr>
<td>Recurrence Solver</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=recurrence">(link)</a></td>
<td>11‑13‑2010</td>
<td>C++</td>
<td>A fast algorithm for generating terms of a sequence defined by a <a href="http://en.wikipedia.org/wiki/Recurrence_relation#Linear_homogeneous_recurrence_relations_with_constant_coefficients">linear recurrence relation</a>.</td>
</tr>
<tr>
<td>Fibonacci Heap</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=fibonacci-heap">(link)</a></td>
<td>11‑15‑2010</td>
<td>Java</td>
<td>An implementation of a priority queue backed by a <a href="http://en.wikipedia.org/wiki/Fibonacci_heap">Fibonacci heap</a>.</td>
</tr>
<tr>
<td>Dijkstra&#8217;s Algorithm</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=dijkstra">(link)</a></td>
<td>11‑16‑2010</td>
<td>Java</td>
<td>An implementation of <a href="http://en.wikipedia.org/wiki/Dijkstra's_algorithm">Dijkstra&#8217;s algorithm</a> for single-source shortest paths.</td>
</tr>
<tr>
<td>Prim&#8217;s Algorithm</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=prim">(link)</a></td>
<td>11‑17‑2010</td>
<td>Java</td>
<td>An implementation of <a href="http://en.wikipedia.org/wiki/Prim's_algorithm">Prim&#8217;s algorithm</a> for computing <a href="http://en.wikipedia.org/wiki/Minimum_spanning_tree">minimum spanning trees</a>.</td>
</tr>
<tr>
<td>Kruskal&#8217;s Algorithm</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=kruskal">(link)</a></td>
<td>11‑17‑2010</td>
<td>Java</td>
<td>An implementation of <a href="http://en.wikipedia.org/wiki/Kruskal's_algorithm">Kruskal&#8217;s algorithm</a> for computing <a href="http://en.wikipedia.org/wiki/Minimum_spanning_tree">minimum spanning trees</a>.</td>
</tr>
<tr>
<td>Majority Element</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=majority-element">(link)</a></td>
<td>11‑17‑2010</td>
<td>C++</td>
<td>A fast, linear-time algorithm for finding the <a href="http://www.cs.utexas.edu/~moore/best-ideas/mjrty/">majority element</a> of a data set.</td>
</tr>
<tr>
<td>Haar Transform</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=haar">(link)</a></td>
<td>11‑17‑2010</td>
<td>C++</td>
<td>A set of functions to decompose a sequence of values into a sum of <a href="http://en.wikipedia.org/wiki/Haar_wavelet">Haar wavelets</a>.</td>
</tr>
<tr>
<td>Argmax</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=argmax">(link)</a></td>
<td>11‑19‑2010</td>
<td>C++</td>
<td>A pair of functions to compute the <a href="http://en.wikipedia.org/wiki/Arg_max">arg min or max</a> of a function on some range.</td>
</tr>
<tr>
<td>Derivative</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=derivative">(link)</a></td>
<td>11‑19‑2010</td>
<td>C++</td>
<td>A <a href="http://en.wikipedia.org/wiki/Function_object">function object</a> that approximates the <a href="http://en.wikipedia.org/wiki/Derivative">derivative</a> of a function.</td>
</tr>
<tr>
<td>Levenshtein Distance</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=levenshtein">(link)</a></td>
<td>11‑19‑2010</td>
<td>C++</td>
<td>An algorithm for computing the <a href="http://en.wikipedia.org/wiki/Levenshtein_distance">Levenshtein distance</a> between two sequences.</td>
</tr>
<tr>
<td>Skiplist</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=skiplist">(link)</a></td>
<td>11‑20‑2010</td>
<td>C++</td>
<td>An implementation of a <a href="http://en.wikipedia.org/wiki/Skip_list">skip list</a>, a randomized data structure for maintaining a sorted collection.</td>
</tr>
<tr>
<td>van Emde Boas Tree</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=van-emde-boas-tree">(link)</a></td>
<td>11‑26‑2010</td>
<td>C++</td>
<td>An implementation of a sorted associative array backed by a <a href="http://en.wikipedia.org/wiki/Van_Emde_Boas_tree">van Emde Boas tree</a>.</td>
</tr>
<tr>
<td>Cuckoo HashMap</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=cuckoo-hashmap">(link)</a></td>
<td>11‑27‑2010</td>
<td>Java</td>
<td>An implementation of a <a href="http://en.wikipedia.org/wiki/Hash_table">hash table</a> using <a href="http://en.wikipedia.org/wiki/Cuckoo_hashing">cuckoo hashing</a>.</td>
</tr>
<tr>
<td>Needleman-Wunsch Algorithm</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=needleman-wunsch">(link)</a></td>
<td>11‑28‑2010</td>
<td>C++</td>
<td>An implementation of the <a href="http://en.wikipedia.org/wiki/Needleman%E2%80%93Wunsch_algorithm">Needleman-Wunsch</a> algorithm for optimal string alignment.</td>
</tr>
<tr>
<td>Treap</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=treap">(link)</a></td>
<td>11‑28‑2010</td>
<td>C++</td>
<td>An implementation of a sorted associative array backed by a <a href="http://en.wikipedia.org/wiki/Treap">treap</a>.</td>
</tr>
<tr>
<td>Floyd-Warshall Algorithm</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=floyd-warshall">(link)</a></td>
<td>12‑10‑2010</td>
<td>Java</td>
<td>An implementation of the <a href="http://en.wikipedia.org/wiki/Floyd-Warshall_algorithm">Floyd-Warshall algorithm</a> for all-pairs shortest paths in a graph.</td>
</tr>
<tr>
<td>Power Iteration</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=power-iteration">(link)</a></td>
<td>12‑10‑2010</td>
<td>C++</td>
<td>An implementation of the <a href="http://en.wikipedia.org/wiki/Power_iteration">power iteration</a> algorithm for finding dominant eigenvectors.</td>
</tr>
<tr>
<td>Edmonds&#8217;s Matching Algorithm</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=edmonds-matching">(link)</a></td>
<td>12‑15‑2010</td>
<td>Java</td>
<td>An implementation of <a href="http://en.wikipedia.org/wiki/Edmonds's_matching_algorithm">Edmonds&#8217;s matching algorithm</a> for finding <a href="http://en.wikipedia.org/wiki/Matching_(graph_theory)#Maximum_matchings">maximum matchings</a> in undirected graphs.</td>
</tr>
<tr>
<td>Kosaraju&#8217;s Algorithm</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=kosaraju">(link)</a></td>
<td>12‑15‑2010</td>
<td>Java</td>
<td>An implementation of <a href="http://en.wikipedia.org/wiki/Kosaraju's_algorithm">Kosaraju&#8217;s algorithm</a> algorithm for finding <a href="http://en.wikipedia.org/wiki/Strongly_connected_component">strongly connected components</a> of a directed graph.</td>
</tr>
<tr>
<td>2-SAT</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=2sat">(link)</a></td>
<td>12‑15‑2010</td>
<td>Java</td>
<td>A linear-time algorithm for solving <a href="http://en.wikipedia.org/wiki/2-satisfiability">2-SAT</a>.</td>
</tr>
<tr>
<td>Bellman-Ford Algorithm</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=bellman-ford">(link)</a></td>
<td>12‑17‑2010</td>
<td>Java</td>
<td>An implementation of the <a href="http://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm">Bellman-Ford</a> algorithm for single-source shortest paths.</td>
</tr>
<tr>
<td>Topological Sort</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=topological-sort">(link)</a></td>
<td>12‑17‑2010</td>
<td>Java</td>
<td>An algorithm for computing a <a href="http://en.wikipedia.org/wiki/Topological_sorting">topological sort</a> of a directed acyclic graph.</td>
</tr>
<tr>
<td>Graham Scan</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=graham-scan">(link)</a></td>
<td>12‑19‑2010</td>
<td>C++</td>
<td>An implementation of the <a href="http://en.wikipedia.org/wiki/Graham_scan">Graham scan</a> for finding convex hulls in 2D space.</td>
</tr>
<tr>
<td>Bipartite Testing</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=bipartite-verify">(link)</a></td>
<td>12‑19‑2010</td>
<td>Java</td>
<td>A linear-time algorithm for checking whether a directed graph is <a href="http://en.wikipedia.org/wiki/Bipartite_graph">bipartite</a>.</td>
</tr>
<tr>
<td>Johnson&#8217;s Algorithm</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=johnson">(link)</a></td>
<td>12‑19‑2010</td>
<td>Java</td>
<td>An implementation of <a href="http://en.wikipedia.org/wiki/Johnson's_algorithm">Johnson&#8217;s algorithm</a> for all-pairs shortest paths.</td>
</tr>
<tr>
<td>Strassen Algorithm</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=strassen">(link)</a></td>
<td>12‑20‑2010</td>
<td>C++</td>
<td>An implementation of the <a href="http://en.wikipedia.org/wiki/Strassen_algorithm">Strassen algorithm</a> for fast matrix multiplication.</td>
</tr>
<tr>
<td>Cartesian Tree Sort</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=cartesian-tree-sort">(link)</a></td>
<td>12‑21‑2010</td>
<td>C++</td>
<td>An implementation of <a href="http://en.wikipedia.org/wiki/Cartesian_tree#Application_in_sorting">Cartesian tree sort</a>, an adaptive, out-of-place heapsort variant.</td>
</tr>
<tr>
<td>Ford-Fulkerson Algorithm</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=ford-fulkerson">(link)</a></td>
<td>12‑21‑2010</td>
<td>Java</td>
<td>An implementation of the <a href="http://en.wikipedia.org/wiki/Ford%E2%80%93Fulkerson_algorithm">Ford-Fulkerson</a> maximum-flow algorithm.</td>
</tr>
<tr>
<td>Scaling Ford-Fulkerson</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=ford-fulkerson-scaling">(link)</a></td>
<td>12‑22‑2010</td>
<td>Java</td>
<td>An modification of the <a href="http://en.wikipedia.org/wiki/Ford%E2%80%93Fulkerson_algorithm">Ford-Fulkerson</a> maximum-flow algorithm that uses scaling to achieve polynomial time..</td>
</tr>
<tr>
<td>Splay Tree</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=splay-tree">(link)</a></td>
<td>12‑27‑2010</td>
<td>C++</td>
<td>An implementation of a sorted associative array backed by a <a href="http://en.wikipedia.org/wiki/Splay_tree">splay tree</a>.</td>
</tr>
<tr>
<td>Ternary Search Tree</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=ternary-search-tree">(link)</a></td>
<td>12‑28‑2010</td>
<td>C++</td>
<td>An implementation of a sorted set of strings backed by a <a href="http://en.wikipedia.org/wiki/Ternary_search_tree">ternary search tree</a>.</td>
</tr>
<tr>
<td>Ring Buffer</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=ring-buffer">(link)</a></td>
<td>12‑30‑2010</td>
<td>Java</td>
<td>An implementation of a FIFO queue using a <a href="http://en.wikipedia.org/wiki/Circular_buffer">ring buffer</a>.</td>
</tr>
<tr>
<td>AVL Tree</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=avl-tree">(link)</a></td>
<td>12‑30‑2010</td>
<td>C++</td>
<td>A sorted associative container backed by an <a href="http://en.wikipedia.org/wiki/AVL_tree">AVL tree</a>.</td>
</tr>
<tr>
<td>Rabin-Karp Algorithm</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=rabin-karp">(link)</a></td>
<td>1‑1‑2011</td>
<td>C++</td>
<td>An implementation of the <a href="http://en.wikipedia.org/wiki/Rabin%E2%80%93Karp_string_search_algorithm">Rabin-Karp algorithm</a> for string matching.</td>
</tr>
<tr>
<td>RPN Evaluator</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=rpn-evaluate">(link)</a></td>
<td>1‑18‑2011</td>
<td>C++ / strain</td>
<td>A library to tokenize and evaluate simple arithmetic expressions in <a href="http://en.wikipedia.org/wiki/Reverse_Polish_notation">reverse Polish notation</a>.</td>
</tr>
<tr>
<td>Shunting-Yard Algorithm</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=shunting-yard">(link)</a></td>
<td>1‑18‑2011</td>
<td>C++ / strain</td>
<td>An implementation of Dijkstra&#8217;s <a href="http://en.wikipedia.org/wiki/Shunting-yard_algorithm">shunting-yard algorithm</a> for converting infix expressions to reverse-Polish notation.</td>
</tr>
<tr>
<td>Skew Binomial Heap</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=skew-binomial-heap">(link)</a></td>
<td>1‑20‑2011</td>
<td>C++</td>
<td>An implementation of a priority queue backed by a <a href="http://en.wikipedia.org/wiki/Skew_binomial_heap">skew binomial heap</a>.</td>
</tr>
<tr>
<td>2/3 Heap</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=two-three-heap">(link)</a></td>
<td>3‑1‑2011</td>
<td>C++</td>
<td>An implementation of a priority queue whose branching factor alternates at different levels to maximize performance.</td>
</tr>
<tr>
<td>Zeckendorf Logarithm</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=zeckendorf-logarithm">(link)</a></td>
<td>3‑10‑2011</td>
<td>C++</td>
<td>An algorithm based on <a href="http://en.wikipedia.org/wiki/Zeckendorf's_theorem">Zeckendorf representations</a> that efficiently computes logarithms.</td>
</tr>
<tr>
<td>Factoradic Permutations</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=factoradic-permutation">(link)</a></td>
<td>3‑17‑2011</td>
<td>C++</td>
<td>A set of algorithms for generating <a href="http://en.wikipedia.org/wiki/Permutation">permutations</a> using the <a href="http://en.wikipedia.org/wiki/Factorial_number_system">factoradic number system</a>.</td>
</tr>
<tr>
<td>Binary Cyclic Subsets</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=binary-subset">(link)</a></td>
<td>3‑20‑2011</td>
<td>C++</td>
<td>A set of algorithms for generating <a href="http://en.wikipedia.org/wiki/Subset">subsets</a> in <a href="http://en.wikipedia.org/wiki/Lexicographical_order">lexicographical order</a> using <a href="http://www.keithschwarz.com/binary-subsets">binary numbers and cyclic shifts</a>.</td>
</tr>
<tr>
<td>Fibonacci Iterator</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=fibonacci-iterator">(link)</a></td>
<td>3‑22‑2011</td>
<td>C++</td>
<td>An STL-style iterator for iterating over the <a href="http://en.wikipedia.org/wiki/Fibonacci_number">Fibonacci numbers</a>.</td>
</tr>
<tr>
<td>Fibonacci Search</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=fibonacci-search">(link)</a></td>
<td>3‑22‑2011</td>
<td>C++</td>
<td>An implementation of the <a href="http://en.wikipedia.org/wiki/Fibonacci_search_technique">Fibonacci search</a> algorithm.</td>
</tr>
<tr>
<td>Euclid&#8217;s Algorithm</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=euclid">(link)</a></td>
<td>4‑18‑2011</td>
<td>Haskell</td>
<td>An implementation of <a href="http://en.wikipedia.org/wiki/Euclidean_algorithm">Euclid&#8217;s algorithm</a> and applications to <a href="http://en.wikipedia.org/wiki/Continued_fraction">continued fractions</a> and <a href="http://en.wikipedia.org/wiki/Extended_Euclidean_algorithm">the extended Euclidean algorithm</a>.</td>
</tr>
<tr>
<td>Find Duplicate</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=find-duplicate">(link)</a></td>
<td>4‑18‑2011</td>
<td>Python</td>
<td>An algorithm to find a repeated element in an array using <a href="http://en.wikipedia.org/wiki/Cycle_detection#Tortoise_and_hare">Floyd&#8217;s cycle-finding algorithm</a>.</td>
</tr>
<tr>
<td>Permutation Generator</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=permutation-generator">(link)</a></td>
<td>4‑19‑2011</td>
<td>Python</td>
<td>A <a href="http://en.wikipedia.org/wiki/Generator_(computer_programming)">generator</a> for producing all <a href="http://en.wikipedia.org/wiki/Permutation">permutations</a> of a list of elements.</td>
</tr>
<tr>
<td>Matrix Find</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=matrix-find">(link)</a></td>
<td>4‑19‑2011</td>
<td>Python</td>
<td>A solution to the classic interview question of searching a sorted matrix for a particular value.</td>
</tr>
<tr>
<td>Binary GCD</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=binary-gcd">(link)</a></td>
<td>4‑23‑2011</td>
<td>Scheme</td>
<td>An implementation of the <a href="http://en.wikipedia.org/wiki/Binary_GCD_algorithm">binary GCD algorithm</a> for computing greatest common divisors of nonnegative integers.</td>
</tr>
<tr>
<td>Knuth-Morris-Pratt Algorithm</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=knuth-morris-pratt">(link)</a></td>
<td>5‑3‑2011</td>
<td>Python</td>
<td>An implementation of the <a href="http://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm">Knuth-Morris-Pratt algorithm</a> for fast string matching.</td>
</tr>
<tr>
<td>Kadane&#8217;s Algorithm</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=kadane">(link)</a></td>
<td>5‑7‑2011</td>
<td>C++</td>
<td>An implementation of Kadane&#8217;s algorithm for solving the <a href="http://en.wikipedia.org/wiki/Maximum_subarray_problem">maximum-weight subarray problem</a>.</td>
</tr>
<tr>
<td>Karatsuba&#8217;s Algorithm</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=karatsuba">(link)</a></td>
<td>8‑15‑2011</td>
<td>Python</td>
<td>An implementation of <a href="http://en.wikipedia.org/wiki/Karatsuba_algorithm">Karatsuba&#8217;s algorithm</a> for fast integer multiplication.</td>
</tr>
<tr>
<td>Min-Stack</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=min-stack">(link)</a></td>
<td>8‑15‑2011</td>
<td>C++</td>
<td>An implementation of a <a href="http://en.wikipedia.org/wiki/Stack_(data_structure)">LIFO stack</a> that supports O(1) push, pop, and find-minimum.</td>
</tr>
<tr>
<td>Random Bag</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=random-bag">(link)</a></td>
<td>8‑15‑2011</td>
<td>Python</td>
<td>A data structure that supports insertion and removal of a uniformly-random element.</td>
</tr>
<tr>
<td>Min-Queue</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=min-queue">(link)</a></td>
<td>8‑15‑2011</td>
<td>C++</td>
<td>An implementation of a <a href="http://en.wikipedia.org/wiki/Queue_(data_structure)">FIFO queue</a> that supports O(1) push, pop, and find-minimum.</td>
</tr>
<tr>
<td>Lights-Out Solver</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=lights-out">(link)</a></td>
<td>8‑29‑2011</td>
<td>C++</td>
<td>A solver for the game <a href="http://en.wikipedia.org/wiki/Lights_Out_(game)">Lights Out</a> using <a href="http://en.wikipedia.org/wiki/Gaussian_elimination">Gaussian elimination</a> over <a href="http://en.wikipedia.org/wiki/GF(2)">GF(2)</a>.</td>
</tr>
<tr>
<td>Maximum Single-Sell Profit</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=single-sell-profit">(link)</a></td>
<td>11‑9‑2011</td>
<td>Python</td>
<td>Four algorithms for the <a href="http://stackoverflow.com/q/7086464/501557">maximum single-sell profit problem</a>, each showing off a different algorithmic technique.</td>
</tr>
<tr>
<td>Generalized Kadane&#8217;s Algorithm</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=generalized-kadane">(link)</a></td>
<td>11‑10‑2011</td>
<td>C++</td>
<td>A generalization of <a href="http://en.wikipedia.org/wiki/Maximum_subarray_problem">Kadane&#8217;s algorithm</a> for solving the maximum subarray problem subject to a <a href="http://stackoverflow.com/q/7861387/501557">length restriction</a>.</td>
</tr>
<tr>
<td>Longest Range</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=longest-range">(link)</a></td>
<td>11‑19‑2011</td>
<td>Java</td>
<td>An algorithm for solving the <a href="http://stackoverflow.com/q/5415305/501557">longest contiguous range</a> problem.</td>
</tr>
<tr>
<td>Egyptian Fractions</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=egyptian-fraction">(link)</a></td>
<td>11‑20‑2011</td>
<td>Python</td>
<td>An implementation of the <a href="http://en.wikipedia.org/wiki/Greedy_algorithm_for_Egyptian_fractions">greedy algorithm</a> for finding <a href="http://en.wikipedia.org/wiki/Egyptian_fraction">Egyptian fractions</a>.</td>
</tr>
<tr>
<td>LL(1) Parser Generator</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=ll1">(link)</a></td>
<td>11‑21‑2011</td>
<td>Java</td>
<td>An <a href="http://en.wikipedia.org/wiki/LL_parser">LL(1) parser generator</a>.</td>
</tr>
<tr>
<td>LR(0) Parser Generator</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=lr0">(link)</a></td>
<td>11‑23‑2011</td>
<td>Java</td>
<td>An <a href="http://en.wikipedia.org/wiki/LR_parser">LR(0) parser generator</a>.</td>
</tr>
<tr>
<td>Word Ladders</td>
<td><a href="http://www.keithschwarz.com/interesting/code/?dir=word-ladder">(link)</a></td>
<td>11‑27‑2011</td>
<td>JavaScript</td>
<td>A program for finding <a href="http://en.wikipedia.org/wiki/Word_ladder">word ladders</a> between two words.</td>
</tr>
</tbody>
</table>
<p>（全文完）<!--



<p align="center"><a href= target=_blank><img decoding="async" src=""></a></p>





<p align="center"><img decoding="async" src="https://coolshell.cn/wp-content/uploads/2020/03/coolshell.weixin.jpg"> <img decoding="async" loading="lazy" src="https://coolshell.cn/wp-content/uploads/2020/03/coolshell.mini_.jpg" width="300" height="300"> <br />关注CoolShell微信公众账号和微信小程序</p>

 

--></p>
<div style="margin-top: 15px; font-size: 16px;color: #cc0000;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 &#8211; CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>

<div class="wp_rp_wrap  wp_rp_vertical_m" ><div class="wp_rp_content"><h3 class="related_post_title">相关文章</h3><ul class="related_post wp_rp"><li ><a href="https://coolshell.cn/articles/12052.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/plugins/wordpress-23-related-posts-plugin/static/thumbs/29.jpg" alt="Leetcode 编程训练" width="150" height="150" /></a><a href="https://coolshell.cn/articles/12052.html" class="wp_rp_title">Leetcode 编程训练</a></li><li ><a href="https://coolshell.cn/articles/4220.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/plugins/wordpress-23-related-posts-plugin/static/thumbs/0.jpg" alt="一些有意思的文章和资源" width="150" height="150" /></a><a href="https://coolshell.cn/articles/4220.html" class="wp_rp_title">一些有意思的文章和资源</a></li><li ><a href="https://coolshell.cn/articles/9886.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/plugins/wordpress-23-related-posts-plugin/static/thumbs/8.jpg" alt="二叉树迭代器算法" width="150" height="150" /></a><a href="https://coolshell.cn/articles/9886.html" class="wp_rp_title">二叉树迭代器算法</a></li><li ><a href="https://coolshell.cn/articles/8239.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2012/09/lock_free_bicycle-150x150.jpg" alt="无锁队列的实现" width="150" height="150" /></a><a href="https://coolshell.cn/articles/8239.html" class="wp_rp_title">无锁队列的实现</a></li><li ><a href="https://coolshell.cn/articles/4671.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/plugins/wordpress-23-related-posts-plugin/static/thumbs/11.jpg" alt="可视化的数据结构和算法" width="150" height="150" /></a><a href="https://coolshell.cn/articles/4671.html" class="wp_rp_title">可视化的数据结构和算法</a></li><li ><a href="https://coolshell.cn/articles/3933.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/plugins/wordpress-23-related-posts-plugin/static/thumbs/23.jpg" alt="可视化的排序过程" width="150" height="150" /></a><a href="https://coolshell.cn/articles/3933.html" class="wp_rp_title">可视化的排序过程</a></li></ul></div></div>The post <a href="https://coolshell.cn/articles/6010.html">一些有意思的算法代码</a> first appeared on <a href="https://coolshell.cn">酷 壳 - CoolShell</a>.]]></content:encoded>
					
					<wfw:commentRss>https://coolshell.cn/articles/6010.html/feed</wfw:commentRss>
			<slash:comments>45</slash:comments>
		
		
			</item>
		<item>
		<title>一些文章资源和趣闻</title>
		<link>https://coolshell.cn/articles/5537.html</link>
					<comments>https://coolshell.cn/articles/5537.html#comments</comments>
		
		<dc:creator><![CDATA[陈皓]]></dc:creator>
		<pubDate>Thu, 24 Nov 2011 04:39:04 +0000</pubDate>
				<category><![CDATA[Web开发]]></category>
		<category><![CDATA[技术读物]]></category>
		<category><![CDATA[杂项资源]]></category>
		<category><![CDATA[编程工具]]></category>
		<category><![CDATA[轶事趣闻]]></category>
		<category><![CDATA[design pattern]]></category>
		<category><![CDATA[Game]]></category>
		<category><![CDATA[HTML]]></category>
		<category><![CDATA[Javascript]]></category>
		<category><![CDATA[Web]]></category>
		<guid isPermaLink="false">http://coolshell.cn/?p=5537</guid>

					<description><![CDATA[<p>下面是我这段时间来收集的一些有意思的东西。本站这样的文章还很多，如这个，这个，这个。 Javascript Garden，这是学习Javascript最好的网站...</p>
<p class="read-more"><a class="btn btn-default" href="https://coolshell.cn/articles/5537.html"> Read More<span class="screen-reader-text">  Read More</span></a></p>
The post <a href="https://coolshell.cn/articles/5537.html">一些文章资源和趣闻</a> first appeared on <a href="https://coolshell.cn">酷 壳 - CoolShell</a>.]]></description>
										<content:encoded><![CDATA[<p><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3415450859608158"
     crossorigin="anonymous"></script>下面是我这段时间来收集的一些有意思的东西。本站这样的文章还很多，如<a title="一些文章和各种资源" href="https://coolshell.cn/articles/5224.html" target="_blank">这个</a>，<a href="https://coolshell.cn/articles/3013.html" target="_blank">这个</a>，<a href="https://coolshell.cn/articles/3903.html" target="_blank">这个</a>。</p>
<p>Javascript Garden，这是学习Javascript最好的网站了。<a href="http://bonsaiden.github.com/JavaScript-Garden">http://bonsaiden.github.com/JavaScript-Garden</a>，这个文档由两具StackOverflow的人写成, <a href="http://stackoverflow.com/users/170224/ivo-wetzel">Ivo Wetzel</a>(Writing) 和 <a href="http://stackoverflow.com/users/313758/yi-jiang">Zhang Yi Jiang</a> (Design)，表示敬意。</p>
<p>想看看Web开发有哪些技术吗？你得看看这个网站：<a href="http://stackparts.com/">http://stackparts.com/</a>，他对目前几乎所有Web上用得到的技术都分了个类。下面是个抓图。</p>
<p><a href="http://stackparts.com"><img decoding="async" loading="lazy" class="aligncenter size-full wp-image-5950" title="各种Web开发用到的技术" src="https://coolshell.cn/wp-content/uploads/2011/11/stackparts.com_.png" alt="" width="513" height="414" srcset="https://coolshell.cn/wp-content/uploads/2011/11/stackparts.com_.png 513w, https://coolshell.cn/wp-content/uploads/2011/11/stackparts.com_-300x242.png 300w, https://coolshell.cn/wp-content/uploads/2011/11/stackparts.com_-335x270.png 335w" sizes="(max-width: 513px) 100vw, 513px" /></a></p>
<p>Mozilla的安全编程规范 <a href="https://wiki.mozilla.org/WebAppSec/Secure_Coding_Guidelines">https://wiki.mozilla.org/WebAppSec/Secure_Coding_Guidelines</a> <a href="http://research.microsoft.com/apps/dp/sq.aspx?a=47204&amp;sq=dl#a=!77148!80820!132314!81593!77135!103269!77072!138731!77112!131133!149403!77128!78088!143130!77023!139171!138997!141118&amp;p=1&amp;ps=36">Downloads associated to Software development</a></p>
<p>PHP,Perl, Ruby, Python语法比较<a href="http://hyperpolyglot.org/scripting?utm_source">http://hyperpolyglot.org/scripting?utm_source</a></p>
<p><span id="more-5537"></span></p>
<p>图形游戏编程的电子书 <a href="http://ploobs.com.br/?p=766">http://ploobs.com.br/?p=766</a></p>
<p>图形编程黑皮书：<a href="http://drdobbs.com/high-performance-computing/184404919" target="_blank">http://drdobbs.com/high-performance-computing/184404919</a></p>
<p><a href="http://www.dpfiles.com/dpfileswiki/index.php?title=Black_Art_of_3D_Game_Programming:_Writing_Your_Own_High-Speed_3D_Polygon_Video_Games_in_C" target="_blank">Black Art of 3D Game Programming: Writing Your Own High-Speed 3D Polygon Video Games in C </a></p>
<p>想学设计模式吗？这是一个非常好的网站：<a href="http://www.vincehuston.org/dp/">http://www.vincehuston.org/dp/</a> 以元素周期表的形式把23个经典模式列出来，让我想到了这几天在看的美剧Breaking Bad，呵呵。</p>
<p><img decoding="async" loading="lazy" class="alignnone aligncenter" title="设计模式元素周期表" src="http://www.vincehuston.org/images/GoF_full_medium.png" alt="" width="450" height="331" /></p>
<p>Learn C the Hard Way <a href="http://c.learncodethehardway.org/book/" target="_blank">http://c.learncodethehardway.org/book/</a></p>
<p>Learn Ruby the Hard Way <a href="http://ruby.learncodethehardway.org/book/">http://ruby.learncodethehardway.org/book/</a></p>
<p>Learn Python the Hard Way <a href="http://learnpythonthehardway.org/">http://learnpythonthehardway.org/</a></p>
<p>Learn SQL the Hard Way <a href="http://sql.learncodethehardway.org/book/">http://sql.learncodethehardway.org/book/</a></p>
<p>Linux基础学习：</p>
<ul>
<li><a title="Linux Fundamentals, Part 2" href="http://www.funtoo.org/wiki/Linux_Fundamentals,_Part_1" target="_blank">Linux Fundamentals, Part 1</a></li>
<li><a title="Linux Fundamentals, Part 2" href="http://www.funtoo.org/wiki/Linux_Fundamentals,_Part_2">Linux Fundamentals, Part 2</a></li>
<li><a title="Linux Fundamentals, Part 3" href="http://www.funtoo.org/wiki/Linux_Fundamentals,_Part_3">Linux Fundamentals, Part 3</a></li>
<li><a title="Linux Fundamentals, Part 4" href="http://www.funtoo.org/wiki/Linux_Fundamentals,_Part_4">Linux Fundamentals, Part 4</a></li>
</ul>
<div>相了解GIF吗？这里有篇不错的文章：<a href="http://matthewflickinger.com/lab/whatsinagif/bits_and_bytes.asp" target="_blank">http://matthewflickinger.com/lab/whatsinagif/bits_and_bytes.asp</a></div>
<div>如何在PC上通过VirtualBox装一个Android操作系统。 <a href="http://www.javacodegeeks.com/2010/06/install-android-os-on-pc-with.html" target="_blank">http://www.javacodegeeks.com/2010/06/install-android-os-on-pc-with.html</a> 不过这篇文章有点老了，是去年的，最新的方式是使用<a href="http://www.android-x86.org/" target="_blank">Android-x86</a>这个项目。</div>
<p>一些你可能不知道的git的tips：<a href="http://mislav.uniqpath.com/2010/07/git-tips/">http://mislav.uniqpath.com/2010/07/git-tips/</a></p>
<p>一个给C/C++程序员用的Vim Plugin，我试用了一下，不是很好用。不过也许你会喜欢：<a href="http://www.fortystones.com/vim-plugins-c-cplusplus-developer/">http://www.fortystones.com/vim-plugins-c-cplusplus-developer/</a></p>
<p>数独游戏的程序算法，140个字节的一段javascript程序： <a href="https://gist.github.com/1230481/95f6facb74f51d089bea87eba0f470cf3bbed83a" target="_blank">https://gist.github.com/1230481/95f6facb74f51d089bea87eba0f470cf3bbed83a</a></p>
<p>一个教你用HTML5做一个画图版的教程：<a href="http://www.primaryobjects.com/CMS/Article134.aspx">http://www.primaryobjects.com/CMS/Article134.aspx</a> 其示例在这里 <a href="http://www.primaryobjects.com/paint/">http://www.primaryobjects.com/paint/</a></p>
<p><img decoding="async" loading="lazy" class="alignnone aligncenter" src="https://lh5.googleusercontent.com/-z17zh24rw4k/TmrH2wrPSRI/AAAAAAAAADQ/Az9W5Lge3Ok/h301/Untitled-1.gif" alt="" width="376" height="301" /></p>
<p>这里又是一个HTML5的演示 <a href="http://www.spielzeugz.de/html5/sticky-thing/">http://www.spielzeugz.de/html5/sticky-thing/</a>，一个物理的会粘在浏览器边框上的小方块，在iPad里演示相当有意思。只是其代码好像被搞得非常地不易读，不过，你可以试试这个工具来整理代码：<a href="http://jsbeautifier.org/">http://jsbeautifier.org/</a>，但是变量命名还是会让你毫无头绪。</p>
<p>HTML5的一个很炫的示例：<a href="http://lights.elliegoulding.com/" target="_blank">http://lights.elliegoulding.com/</a>  你可以用鼠标巡航，点左键加速（另，那位朋友知道其背景音乐？）</p>
<p style="text-align: center;"><a href="http://lights.elliegoulding.com/"><img decoding="async" loading="lazy" class="size-full wp-image-5951 aligncenter" title="lights" src="https://coolshell.cn/wp-content/uploads/2011/11/lights.jpg" alt="" width="600" height="322" srcset="https://coolshell.cn/wp-content/uploads/2011/11/lights.jpg 600w, https://coolshell.cn/wp-content/uploads/2011/11/lights-300x161.jpg 300w" sizes="(max-width: 600px) 100vw, 600px" /></a></p>
<p>想用HTML5做股票图吗？看看这个库：<a href="http://www.rocketcharts.com/">http://www.rocketcharts.com/</a></p>
<div>
<div><img decoding="async" class="aligncenter" src="http://www.rocketcharts.com/img/rocketcharts.png" alt="" /></div>
</div>
<p>一个7K的js，可以让你的HTML的列表很灵活的分类，排序，搜索，过滤：<a href="http://listjs.com/">http://listjs.com/</a></p>
<p>一个OOP的PHP处理图片的类库：<a href="http://imagine.readthedocs.org/">http://imagine.readthedocs.org</a></p>
<p><img decoding="async" loading="lazy" class="aligncenter" src="http://imagine.readthedocs.org/en/latest/_static/logo.png" alt="" width="280" height="140" /></p>
<p>一个Javascript实现的H.264解码器。<a href="https://github.com/mbebenita/Broadway">https://github.com/mbebenita/Broadway</a> （<a href="http://mbebenita.github.com/Broadway/broadway.html" target="_blank">演示地址</a> &#8211; 请用firefox打开，download速度可能很慢）不过，其是用Android C实现的，然后把C转成Javascript的代码。如果你想知道如何把C代码转成Javascript，你可以看看这个项目：<a href="https://github.com/kripken/emscripten">https://github.com/kripken/emscripten</a> &#8211; LLVM-to-JavaScript compiler。（变态！）</p>
<p>一个可以画流程图的Javascript lib &#8211; WireIt：<a href="http://neyric.github.com/wireit/">http://neyric.github.com/wireit/</a></p>
<p><img decoding="async" loading="lazy" class="aligncenter size-full wp-image-5952" title="wireit" src="https://coolshell.cn/wp-content/uploads/2011/11/wireit.png" alt="" width="411" height="283" srcset="https://coolshell.cn/wp-content/uploads/2011/11/wireit.png 411w, https://coolshell.cn/wp-content/uploads/2011/11/wireit-300x206.png 300w" sizes="(max-width: 411px) 100vw, 411px" /></p>
<p>这是一个网站，仅用CSS，没有JS，没有图片做的N多公司的logo。但其可以用纯CSS做个动画，你可以看看：<a href="http://www.ecsspert.com/atari.php" target="_blank">http://www.ecsspert.com/atari.php</a> 研究了一下发现其用到了  <span class="Apple-style-span" style="font-family: monospace; font-size: 12px; line-height: 18px; white-space: pre;">-webkit-animation</span>。</p>
<p>一个用bash处理JSON的脚本：<a href="https://github.com/rcrowley/json.sh" target="_blank">https://github.com/rcrowley/json.sh</a></p>
<p>微软VS中的Debug Canvas,相当的不错啊。<a href="http://msdn.microsoft.com/en-us/devlabs/debuggercanvas">http://msdn.microsoft.com/en-us/devlabs/debuggercanvas</a>，可惜只在 Visual Studio Ultimate里。</p>
<p>介绍一下很有意思的Firefox插件<a href="https://addons.mozilla.org/en-US/firefox/addon/tilt/" target="_blank"> Titl 3D</a>，其项目主页在 <a href="https://github.com/victorporof/Tilt">https://github.com/victorporof/Tilt</a>。这个插件使用WebGL可以3D地显示网页，安装好插件后，简单地按一下Ctrl+Shift+M就可以了。下面我用其显示了新浪微博和WebQQ。目前的功能不是很多，但是这个插件简直是太cool了——可以大胆的设想一下以后会不会有3D的网页。</p>
<p><img decoding="async" loading="lazy" class="aligncenter" title="tile3d_weibo" src="https://coolshell.cn/wp-content/uploads/2011/11/tile3d_weibo.png" alt="" width="650" height="331" /></p>
<p><img decoding="async" loading="lazy" class="aligncenter size-full wp-image-5810" title="tile3d_webqq" src="https://coolshell.cn/wp-content/uploads/2011/11/tile3d_webqq.png" alt="" width="650" height="331" srcset="https://coolshell.cn/wp-content/uploads/2011/11/tile3d_webqq.png 650w, https://coolshell.cn/wp-content/uploads/2011/11/tile3d_webqq-300x152.png 300w" sizes="(max-width: 650px) 100vw, 650px" /></p>
<p>最后，在网上看到一个笑话，如下：</p>
<p>这是给程序员们女朋友的建议。如果某程序员要和你分手，你可以参照这位国外程序员女友的作法——“你可以在facebook和twitter上拉黑我，也可以不回我的短信，但是，你永远不可能阻止我对你在Reddit上发的所有的贴投反对票！FUCK YOU ！”</p>
<p><img decoding="async" loading="lazy" class="aligncenter size-full wp-image-5953" title="生气的女友" src="https://coolshell.cn/wp-content/uploads/2011/11/1z2qalh.png" alt="" width="499" height="78" srcset="https://coolshell.cn/wp-content/uploads/2011/11/1z2qalh.png 499w, https://coolshell.cn/wp-content/uploads/2011/11/1z2qalh-300x46.png 300w" sizes="(max-width: 499px) 100vw, 499px" /></p>
<p>就这些，希望对你会喜欢。<!--



<p align="center"><a href= target=_blank><img decoding="async" src=""></a></p>





<p align="center"><img decoding="async" src="https://coolshell.cn/wp-content/uploads/2020/03/coolshell.weixin.jpg"> <img decoding="async" loading="lazy" src="https://coolshell.cn/wp-content/uploads/2020/03/coolshell.mini_.jpg" width="300" height="300"> <br />关注CoolShell微信公众账号和微信小程序</p>

 

--></p>
<div style="margin-top: 15px; font-size: 16px;color: #cc0000;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="https://coolshell.cn/">酷 壳 &#8211; CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>

<div class="wp_rp_wrap  wp_rp_vertical_m" ><div class="wp_rp_content"><h3 class="related_post_title">相关文章</h3><ul class="related_post wp_rp"><li ><a href="https://coolshell.cn/articles/9666.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2013/05/Render-Process-150x150.jpg" alt="浏览器的渲染原理简介" width="150" height="150" /></a><a href="https://coolshell.cn/articles/9666.html" class="wp_rp_title">浏览器的渲染原理简介</a></li><li ><a href="https://coolshell.cn/articles/4795.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/plugins/wordpress-23-related-posts-plugin/static/thumbs/7.jpg" alt="开源中最好的Web开发的资源" width="150" height="150" /></a><a href="https://coolshell.cn/articles/4795.html" class="wp_rp_title">开源中最好的Web开发的资源</a></li><li ><a href="https://coolshell.cn/articles/3903.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/plugins/wordpress-23-related-posts-plugin/static/thumbs/14.jpg" alt="一些有意思的贴子和工具" width="150" height="150" /></a><a href="https://coolshell.cn/articles/3903.html" class="wp_rp_title">一些有意思的贴子和工具</a></li><li ><a href="https://coolshell.cn/articles/3684.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2011/02/1128-150x150.jpg" alt="Web开发人员速查卡" width="150" height="150" /></a><a href="https://coolshell.cn/articles/3684.html" class="wp_rp_title">Web开发人员速查卡</a></li><li ><a href="https://coolshell.cn/articles/3516.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/plugins/wordpress-23-related-posts-plugin/static/thumbs/23.jpg" alt="JS游戏引擎列表" width="150" height="150" /></a><a href="https://coolshell.cn/articles/3516.html" class="wp_rp_title">JS游戏引擎列表</a></li><li ><a href="https://coolshell.cn/articles/18360.html" class="wp_rp_thumbnail"><img src="https://coolshell.cn/wp-content/uploads/2018/05/300x262-150x150.jpg" alt="程序员练级攻略（2018)  与我的专栏" width="150" height="150" /></a><a href="https://coolshell.cn/articles/18360.html" class="wp_rp_title">程序员练级攻略（2018)  与我的专栏</a></li></ul></div></div>The post <a href="https://coolshell.cn/articles/5537.html">一些文章资源和趣闻</a> first appeared on <a href="https://coolshell.cn">酷 壳 - CoolShell</a>.]]></content:encoded>
					
					<wfw:commentRss>https://coolshell.cn/articles/5537.html/feed</wfw:commentRss>
			<slash:comments>81</slash:comments>
		
		
			</item>
	</channel>
</rss>
