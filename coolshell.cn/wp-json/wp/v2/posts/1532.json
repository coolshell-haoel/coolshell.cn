{"id":1532,"date":"2009-10-11T18:01:06","date_gmt":"2009-10-11T10:01:06","guid":{"rendered":"http:\/\/coolshell.cn\/?p=1532"},"modified":"2020-12-28T16:22:50","modified_gmt":"2020-12-28T08:22:50","slug":"%e5%88%b0%e5%a4%84%e9%83%bd%e6%98%afunix%e7%9a%84%e8%83%8e%e8%ae%b0","status":"publish","type":"post","link":"https:\/\/coolshell.cn\/articles\/1532.html","title":{"rendered":"\u5230\u5904\u90fd\u662fUnix\u7684\u80ce\u8bb0"},"content":{"rendered":"<p>\u4e00\u8bf4\u8d77Unix\u7f16\u7a0b\uff0c\u4e0d\u5fc5\u591a\u8bf4\uff0c\u6700\u8457\u540d\u7684\u7cfb\u7edf\u8c03\u7528\u5c31\u662ffork\uff0cpipe\uff0cexec\uff0ckill\u6216\u662fsocket\u4e86\uff08<a href=\"http:\/\/www.kernel.org\/doc\/man-pages\/online\/pages\/man2\/fork.2.html\"><code>fork(2)<\/code><\/a>, <a href=\"http:\/\/www.kernel.org\/doc\/man-pages\/online\/pages\/man2\/execve.2.html\"><code>execve(2)<\/code><\/a>, <a href=\"http:\/\/www.kernel.org\/doc\/man-pages\/online\/pages\/man2\/pipe.2.html\"><code>pipe(2)<\/code><\/a>, <a href=\"http:\/\/www.kernel.org\/doc\/man-pages\/online\/pages\/man2\/socketpair.2.html\"><code>socketpair(2)<\/code><\/a>, <a href=\"http:\/\/www.kernel.org\/doc\/man-pages\/online\/pages\/man2\/select.2.html\"><code>select(2)<\/code><\/a>, <a href=\"http:\/\/www.kernel.org\/doc\/man-pages\/online\/pages\/man2\/kill.2.html\"><code>kill(2)<\/code><\/a>, <a href=\"http:\/\/www.kernel.org\/doc\/man-pages\/online\/pages\/man2\/sigaction.2.html\"><code>sigaction(2)<\/code><\/a>\uff09\u8fd9\u4e9b\u7cfb\u7edf\u8c03\u7528\u90fd\u50cf\u662fUnix\u7f16\u7a0b\u7684\u80ce\u8bb0\u6216\u7b7e\u540d\u4e00\u6837\uff0c\u8868\u660e\u7740\u5b83\u6765\u81ea\u4e8eUnix\u3002<\/p>\n<p>\u4e0b\u9762\u8fd9\u7bc7\u6587\u7ae0\uff0c\u5c06\u5411\u5927\u5bb6\u5c55\u793aUnix\u4e0b\u6700\u7ecf\u5178\u7684socket\u7684\u7f16\u7a0b\u4f8b\u5b50\u2014\u2014\u4f7f\u7528fork + socket\u6765\u521b\u5efa\u4e00\u4e2aTCP\/IP\u7684\u670d\u52a1\u7a0b\u5e8f\u3002\u8fd9\u4e2a\u7f16\u7a0b\u6a21\u5f0f\u5f88\u7b80\u5355\uff0c\u9996\u5148\u662f\u521b\u5efaSocket\uff0c\u7136\u540e\u628a\u5176\u7ed1\u5b9a\u5728\u67d0\u4e2aIP\u548cPort\u4e0a\u4e0a\u4fa6\u542c\u8fde\u63a5\uff0c\u63a5\u4e0b\u6765\u7684\u4e00\u822c\u505a\u6cd5\u662f\u4f7f\u7528\u4e00\u4e2afork\u521b\u5efa\u4e00\u4e2aclient\u670d\u52a1\u8fdb\u7a0b\u518d\u52a0\u4e0a\u4e00\u4e2a\u6b7b\u5faa\u73af\u7528\u4e8e\u5904\u7406\u548cclient\u7684\u4ea4\u4e92\u3002\u8fd9\u4e2a\u6a21\u5f0f\u662fUnix\u4e0b\u6700\u7ecf\u5178\u7684Socket\u7f16\u7a0b\u4f8b\u5b50\u3002<\/p>\n<p>\u4e0b\u9762\uff0c\u8ba9\u6211\u4eec\u770b\u770b\u7528C\uff0cRuby\uff0cPython\uff0cPerl\uff0cPHP\u548cHaskell\u6765\u5b9e\u73b0\u8fd9\u4e00\u4f8b\u5b50\uff0c\u4f60\u4f1a\u53d1\u73b0\u8fd9\u4e9b\u4f8b\u5b50\u4e2d\u7684Unix\u7684\u80ce\u8bb0\u3002\u5982\u679c\u4f60\u60f3\u77e5\u9053\u8fd9\u4e9b\u4f8b\u5b50\u4e2d\u7684\u6280\u672f\u7ec6\u8282\uff0c\u90a3\u4e48\uff0c\u5411\u4f60\u63a8\u8350\u4e24\u672c\u7ecf\u5178\u4e66\u2014\u2014\u300aUnix\u9ad8\u7ea7\u73af\u5883\u7f16\u7a0b\u300b\u548c\u300aUnix\u7f51\u7edc\u7f16\u7a0b\u300b\u3002<\/p>\n<p><!--more--><\/p>\n<div id=\"ez-toc-container\" class=\"ez-toc-v2_0_48 counter-hierarchy ez-toc-counter ez-toc-grey ez-toc-container-direction\">\n<div class=\"ez-toc-title-container\">\n<p class=\"ez-toc-title\">\u76ee\u5f55<\/p>\n<span class=\"ez-toc-title-toggle\"><\/span><\/div>\n<nav><ul class='ez-toc-list ez-toc-list-level-1 ' ><li class='ez-toc-page-1 ez-toc-heading-level-4'><a class=\"ez-toc-link ez-toc-heading-1\" href=\"https:\/\/coolshell.cn\/articles\/1532.html\/#C%E8%AF%AD%E8%A8%80\" title=\"C\u8bed\u8a00\">C\u8bed\u8a00<\/a><\/li><li class='ez-toc-page-1 ez-toc-heading-level-4'><a class=\"ez-toc-link ez-toc-heading-2\" href=\"https:\/\/coolshell.cn\/articles\/1532.html\/#Ruby\" title=\"Ruby\">Ruby<\/a><\/li><li class='ez-toc-page-1 ez-toc-heading-level-4'><a class=\"ez-toc-link ez-toc-heading-3\" href=\"https:\/\/coolshell.cn\/articles\/1532.html\/#Python\" title=\"Python\">Python<\/a><\/li><li class='ez-toc-page-1 ez-toc-heading-level-4'><a class=\"ez-toc-link ez-toc-heading-4\" href=\"https:\/\/coolshell.cn\/articles\/1532.html\/#Perl\" title=\"Perl\">Perl<\/a><\/li><li class='ez-toc-page-1 ez-toc-heading-level-4'><a class=\"ez-toc-link ez-toc-heading-5\" href=\"https:\/\/coolshell.cn\/articles\/1532.html\/#PHP\" title=\"PHP\">PHP<\/a><\/li><li class='ez-toc-page-1 ez-toc-heading-level-4'><a class=\"ez-toc-link ez-toc-heading-6\" href=\"https:\/\/coolshell.cn\/articles\/1532.html\/#Haskell\" title=\"Haskell\">Haskell<\/a><\/li><\/ul><\/nav><\/div>\n<h4><span class=\"ez-toc-section\" id=\"C%E8%AF%AD%E8%A8%80\"><\/span>C\u8bed\u8a00<span class=\"ez-toc-section-end\"><\/span><\/h4>\n<p>\u6211\u4eec\u5148\u6765\u770b\u4e00\u4e0b\u7ecf\u5178\u7684C\u662f\u600e\u4e48\u5b9e\u73b0\u7684\u3002<\/p>\n<pre class=\"EnlighterJSRAW\" data-enlighter-language=\"c\">\/**\n * A simple preforking echo server in C.\n *\n * Building:\n *\n * $ gcc -Wall -o echo echo.c\n *\n * Usage:\n *\n * $ .\/echo\n *\n *   ~ then in another terminal ... ~\n *\n * $ echo 'Hello, world!' | nc localhost 4242\n *\n *\/\n\n#include &lt;unistd.h&gt; \/* fork, close *\/\n#include &lt;stdlib.h&gt; \/* exit *\/\n#include &lt;string.h&gt; \/* strlen *\/\n#include &lt;stdio.h&gt; \/* perror, fdopen, fgets *\/\n#include &lt;sys\/socket.h&gt;\n#include &lt;sys\/wait.h&gt; \/* waitpid *\/\n#include &lt;netdb.h&gt; \/* getaddrinfo *\/\n\n#define die(msg) do { perror(msg); exit(EXIT_FAILURE); } while (0)\n\n#define PORT \"4242\"\n#define NUM_CHILDREN 3\n\n#define MAXLEN 1024\n\nint readline(int fd, char *buf, int maxlen); \/\/ forward declaration\n\nint\nmain(int argc, char** argv)\n{\n    int i, n, sockfd, clientfd;\n    int yes = 1; \/\/ used in setsockopt(2)\n    struct addrinfo *ai;\n    struct sockaddr_in *client;\n    socklen_t client_t;\n    pid_t cpid; \/\/ child pid\n    char line[MAXLEN];\n    char cpid_s[32];\n    char welcome[32];\n\n    \/* Create a socket and get its file descriptor -- socket(2) *\/\n    sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    if (sockfd == -1) {\n    die(\"Couldn't create a socket\");\n    }\n\n    \/* Prevents those dreaded \"Address already in use\" errors *\/\n    if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, (const void *)&amp;yes, sizeof(int)) == -1) {\n    die(\"Couldn't setsockopt\");\n    }\n\n    \/* Fill the address info struct (host + port) -- getaddrinfo(3) *\/\n    if (getaddrinfo(NULL, PORT, NULL, &amp;ai) != 0) {\n    die(\"Couldn't get address\");\n    }\n\n    \/* Assign address to this socket's fd *\/\n    if (bind(sockfd, ai-&gt;ai_addr, ai-&gt;ai_addrlen) != 0) {\n    die(\"Couldn't bind socket to address\");\n    }\n\n    \/* Free the memory used by our address info struct *\/\n    freeaddrinfo(ai);\n\n    \/* Mark this socket as able to accept incoming connections *\/\n    if (listen(sockfd, 10) == -1) {\n    die(\"Couldn't make socket listen\");\n    }\n\n    \/* Fork you some child processes. *\/\n    for (i = 0; i &lt; NUM_CHILDREN; i++) {\n    cpid = fork();\n    if (cpid == -1) {\n        die(\"Couldn't fork\");\n    }\n\n    if (cpid == 0) { \/\/ We're in the child ...\n        for (;;) { \/\/ Run forever ...\n        \/* Necessary initialization for accept(2) *\/\n        client_t = sizeof client;\n\n        \/* Blocks! *\/\n        clientfd = accept(sockfd, (struct sockaddr *)&amp;client, &amp;client_t);\n        if (clientfd == -1) {\n            die(\"Couldn't accept a connection\");\n        }\n\n        \/* Send a welcome message\/prompt *\/\n        bzero(cpid_s, 32);\n        bzero(welcome, 32);\n        sprintf(cpid_s, \"%d\", getpid());\n        sprintf(welcome, \"Child %s echo&gt; \", cpid_s);\n        send(clientfd, welcome, strlen(welcome), 0);\n\n        \/* Read a line from the client socket ... *\/\n        n = readline(clientfd, line, MAXLEN);\n        if (n == -1) {\n            die(\"Couldn't read line from connection\");\n        }\n\n        \/* ... and echo it back *\/\n        send(clientfd, line, n, 0);\n\n        \/* Clean up the client socket *\/\n        close(clientfd);\n        }\n    }\n    }\n\n    \/* Sit back and wait for all child processes to exit *\/\n    while (waitpid(-1, NULL, 0) &gt; 0);\n\n    \/* Close up our socket *\/\n    close(sockfd);\n\n    return 0;\n}\n\n\/**\n * Simple utility function that reads a line from a file descriptor fd,\n * up to maxlen bytes -- ripped from Unix Network Programming, Stevens.\n *\/\nint\nreadline(int fd, char *buf, int maxlen)\n{\n    int n, rc;\n    char c;\n\n    for (n = 1; n &lt; maxlen; n++) {\n    if ((rc = read(fd, &amp;c, 1)) == 1) {\n        *buf++ = c;\n        if (c == '\\n')\n        break;\n    } else if (rc == 0) {\n        if (n == 1)\n        return 0; \/\/ EOF, no data read\n        else\n        break; \/\/ EOF, read some data\n    } else\n        return -1; \/\/ error\n    }\n\n    *buf = '\\0'; \/\/ null-terminate\n    return n;\n}\n<\/pre>\n<h4><span class=\"ez-toc-section\" id=\"Ruby\"><\/span>Ruby<span class=\"ez-toc-section-end\"><\/span><\/h4>\n<p>\u4e0b\u9762\u662fRuby\uff0c\u4f60\u53ef\u4ee5\u770b\u5230\u5176\u4e2d\u7684fork<\/p>\n<pre class=\"EnlighterJSRAW\" data-enlighter-language=\"ruby\">\n# simple preforking echo server in Ruby\nrequire 'socket'\n\n# Create a socket, bind it to localhost:4242, and start listening.\n# Runs once in the parent; all forked children inherit the socket's\n# file descriptor.\nacceptor = Socket.new(Socket::AF_INET, Socket::SOCK_STREAM, 0)\naddress = Socket.pack_sockaddr_in(4242, 'localhost')\nacceptor.bind(address)\nacceptor.listen(10)\n\n# Close the socket when we exit the parent or any child process. This\n# only closes the file descriptor in the calling process, it does not\n# take the socket out of the listening state (until the last fd is\n# closed).\n#\n# The trap is guaranteed to happen, and guaranteed to happen only\n# once, right before the process exits for any reason (unless\n# it's terminated with a SIGKILL).\ntrap('EXIT') { acceptor.close }\n\n# Fork you some child processes. In the parent, the call to fork\n# returns immediately with the pid of the child process; fork never\n# returns in the child because we exit at the end of the block.\n3.times do\n\u00a0 fork do\n\u00a0\u00a0\u00a0 # now we're in the child process; trap (Ctrl-C) interrupts and\n\u00a0\u00a0\u00a0 # exit immediately instead of dumping stack to stderr.\n\u00a0\u00a0\u00a0 trap('INT') { exit }\n\n\u00a0\u00a0\u00a0 puts \"child #$$ accepting on shared socket (localhost:4242)\"\n\u00a0\u00a0\u00a0 loop {\n\u00a0\u00a0\u00a0\u00a0\u00a0 # This is where the magic happens. accept(2) blocks until a\n\u00a0\u00a0\u00a0\u00a0\u00a0 # new connection is ready to be dequeued.\n\u00a0\u00a0\u00a0\u00a0\u00a0 socket, addr = acceptor.accept\n\u00a0\u00a0\u00a0\u00a0\u00a0 socket.write \"child #$$ echo&gt; \"\n\u00a0\u00a0\u00a0\u00a0\u00a0 socket.flush\n\u00a0\u00a0\u00a0\u00a0\u00a0 message = socket.gets\n\u00a0\u00a0\u00a0\u00a0\u00a0 socket.write message\n\u00a0\u00a0\u00a0\u00a0\u00a0 socket.close\n\u00a0\u00a0\u00a0\u00a0\u00a0 puts \"child #$$ echo'd: '#{message.strip}'\"\n\u00a0\u00a0\u00a0 }\n\u00a0\u00a0\u00a0 exit\n\u00a0 end\nend\n\n# Trap (Ctrl-C) interrupts, write a note, and exit immediately\n# in parent. This trap is not inherited by the forks because it\n# runs after forking has commenced.\ntrap('INT') { puts \"\\nbailing\" ; exit }\n\n# Sit back and wait for all child processes to exit.\nProcess.waitall\n\n<\/pre>\n<h4><span class=\"ez-toc-section\" id=\"Python\"><\/span>Python<span class=\"ez-toc-section-end\"><\/span><\/h4>\n<pre class=\"EnlighterJSRAW\" data-enlighter-language=\"python\">\"\"\"\nSimple preforking echo server in Python.\n\"\"\"\n\nimport os\nimport sys\nimport socket\n\n# Create a socket, bind it to localhost:4242, and start\n# listening. Runs once in the parent; all forked children\n# inherit the socket's file descriptor.\nacceptor = socket.socket()\nacceptor.bind(('localhost', 4242))\nacceptor.listen(10)\n\n# Ryan's Ruby code here traps EXIT and closes the socket. This\n# isn't required in Python; the socket will be closed when the\n# socket object gets garbage collected.\n\n# Fork you some child processes. In the parent, the call to\n# fork returns immediately with the pid of the child process;\n# fork never returns in the child because we exit at the end\n# of the block.\nfor i in range(3):\n    pid = os.fork()\n\n    # os.fork() returns 0 in the child process and the child's\n    # process id in the parent. So if pid == 0 then we're in\n    # the child process.\n    if pid == 0:\n        # now we're in the child process; trap (Ctrl-C)\n        # interrupts by catching KeyboardInterrupt) and exit\n        # immediately instead of dumping stack to stderr.\n        childpid = os.getpid()\n        print \"Child %s listening on localhost:4242\" % childpid\n        try:\n            while 1:\n                # This is where the magic happens. accept(2)\n                # blocks until a new connection is ready to be\n                # dequeued.\n                conn, addr = acceptor.accept()\n\n                # For easier use, turn the socket connection\n                # into a file-like object.\n                flo = conn.makefile()\n                flo.write('Child %s echo&gt; ' % childpid)\n                flo.flush()\n                message = flo.readline()\n                flo.write(message)\n                flo.close()\n                conn.close()\n                print \"Child %s echo'd: %r\" % \\\n                          (childpid, message.strip())\n        except KeyboardInterrupt:\n            sys.exit()\n\n# Sit back and wait for all child processes to exit.\n#\n# Trap interrupts, write a note, and exit immediately in\n# parent. This trap is not inherited by the forks because it\n# runs after forking has commenced.\ntry:\n    os.waitpid(-1, 0)\nexcept KeyboardInterrupt:\n    print \"\\nbailing\"\n    sys.exit()\n<\/pre>\n<h4><span class=\"ez-toc-section\" id=\"Perl\"><\/span>Perl<span class=\"ez-toc-section-end\"><\/span><\/h4>\n<pre class=\"EnlighterJSRAW\" data-enlighter-language=\"perl\">#!\/usr\/bin\/perl\nuse 5.010;\nuse strict;\n\n# simple preforking echo server in Perl\nuse Proc::Fork;\nuse IO::Socket::INET;\n\nsub strip { s\/\\A\\s+\/\/, s\/\\s+\\z\/\/ for my @r = @_; @r }\n\n# Create a socket, bind it to localhost:4242, and start listening.\n# Runs once in the parent; all forked children inherit the socket's\n# file descriptor.\nmy $acceptor = IO::Socket::INET-&gt;new(\n    LocalPort =&gt; 4242,\n    Reuse     =&gt; 1,\n    Listen    =&gt; 10,\n) or die \"Couln't start server: $!\\n\";\n\n# Close the socket when we exit the parent or any child process. This\n# only closes the file descriptor in the calling process, it does not\n# take the socket out of the listening state (until the last fd is\n# closed).\nEND { $acceptor-&gt;close }\n\n# Fork you some child processes. The code after the run_fork block runs\n# in all process, but because the child block ends in an exit call, only\n# the parent executes the rest of the program. If a parent block were\n# specified here, it would be invoked in the parent only, and passed the\n# PID of the child process.\nfor ( 1 .. 3 ) {\n    run_fork { child {\n        while (1) {\n            my $socket = $acceptor-&gt;accept;\n            $socket-&gt;printflush( \"child $$ echo&gt; \" );\n            my $message = $socket-&gt;getline;\n            $socket-&gt;print( $message );\n            $socket-&gt;close;\n            say \"child $$ echo'd: '${\\strip $message}'\";\n        }\n        exit;\n    } }\n}\n\n# Trap (Ctrl-C) interrupts, write a note, and exit immediately\n# in parent. This trap is not inherited by the forks because it\n# runs after forking has commenced.\n$SIG{ 'INT' } = sub { print \"bailing\\n\"; exit };\n\n# Sit back and wait for all child processes to exit.\n1 while 0 &lt; waitpid -1, 0;\n<\/pre>\n<h4><span class=\"ez-toc-section\" id=\"PHP\"><\/span>PHP<span class=\"ez-toc-section-end\"><\/span><\/h4>\n<pre class=\"EnlighterJSRAW\" data-enlighter-language=\"perl\">\n&lt;?\n\/*\nSimple preforking echo server in PHP.\nRussell Beattie (russellbeattie.com)\n*\/\n\n\/* Allow the script to hang around waiting for connections. *\/\nset_time_limit(0);\n\n# Create a socket, bind it to localhost:4242, and start\n# listening. Runs once in the parent; all forked children\n# inherit the socket's file descriptor.\n$socket = socket_create(AF_INET, SOCK_STREAM, SOL_TCP);\nsocket_bind($socket,'localhost', 4242);\nsocket_listen($socket, 10);\n\npcntl_signal(SIGTERM, 'shutdown');\npcntl_signal(SIGINT, 'shutdown');\n\nfunction shutdown($signal){\n\u00a0\u00a0\u00a0 global $socket;\n\u00a0\u00a0\u00a0 socket_close($socket);\n\u00a0\u00a0\u00a0 exit();\n}\n# Fork you some child processes. In the parent, the call to\n# fork returns immediately with the pid of the child process;\n# fork never returns in the child because we exit at the end\n# of the block.\nfor($x = 1; $x &lt;= 3; $x++){\n\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0 $pid = pcntl_fork();\n\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0 # pcntl_fork() returns 0 in the child process and the child's\n\u00a0\u00a0\u00a0 # process id in the parent. So if $pid == 0 then we're in\n\u00a0\u00a0\u00a0 # the child process.\n\u00a0\u00a0\u00a0 if($pid == 0){\n\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 $childpid = posix_getpid();\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 echo \"Child $childpid listening on localhost:4242 \\n\";\n\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 while(true){\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 # This is where the magic happens. accept(2)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 # blocks until a new connection is ready to be\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 # dequeued.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 $conn = socket_accept($socket);\n\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 $message = socket_read($conn,1000,PHP_NORMAL_READ);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 socket_write($conn, \"Child $childpid echo&gt; $message\");\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 socket_close($conn);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 echo \"Child $childpid echo'd: $message \\n\";\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 }\n\n\u00a0\u00a0\u00a0 }\n}\n#\n# Trap interrupts, write a note, and exit immediately in\n# parent. This trap is not inherited by the forks because it\n# runs after forking has commenced.\ntry{\n\n\u00a0\u00a0\u00a0 pcntl_waitpid(-1, $status);\n\n} catch (Exception $e) {\n\n\u00a0\u00a0\u00a0 echo \"bailing \\n\";\n\u00a0\u00a0\u00a0 exit();\n\n}<\/pre>\n<h4><span class=\"ez-toc-section\" id=\"Haskell\"><\/span>Haskell<span class=\"ez-toc-section-end\"><\/span><\/h4>\n<pre class=\"EnlighterJSRAW\" data-enlighter-language=\"haskell\">import Network\nimport Prelude hiding ((-))\nimport Control.Monad\nimport System.IO\nimport Control.Applicative\nimport System.Posix\nimport System.Exit\nimport System.Posix.Signals\n\nmain :: IO ()\nmain = with =&lt;&lt; (listenOn - PortNumber 4242) where\n\n\u00a0 with socket = do\n\u00a0\u00a0\u00a0 replicateM 3 - forkProcess work\n\u00a0\u00a0\u00a0 wait\n\n\u00a0\u00a0\u00a0 where\n\u00a0\u00a0\u00a0 work = do\n\u00a0\u00a0\u00a0\u00a0\u00a0 installHandler sigINT (Catch trap_int) Nothing\n\u00a0\u00a0\u00a0\u00a0\u00a0 pid &lt;- show &lt;$&gt; getProcessID\n\u00a0\u00a0\u00a0\u00a0\u00a0 puts - \"child \" ++ pid ++ \" accepting on shared socket (localhost:4242)\"\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0 forever - do\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 (h, _, _) &lt;- accept socket\n\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 let write\u00a0\u00a0 = hPutStr h\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 flush\u00a0\u00a0 = hFlush h\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 getline = hGetLine h\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 close\u00a0\u00a0 = hClose h\n\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 write - \"child \" ++ pid ++ \" echo&gt; \"\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 flush\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 message &lt;- getline\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 write - message ++ \"\\n\"\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 puts - \"child \" ++ pid ++ \" echo'd: '\" ++ message ++ \"'\"\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 close\n\n\u00a0\u00a0\u00a0 wait = forever - do\n\u00a0\u00a0\u00a0\u00a0\u00a0 ( const () &lt;$&gt; getAnyProcessStatus True True\u00a0 ) <code data-enlighter-language=\"raw\" class=\"EnlighterJSRAW\">catch<\/code> const trap_exit\n\n\u00a0\u00a0\u00a0 trap_int = exitImmediately ExitSuccess\n\n\u00a0\u00a0\u00a0 trap_exit = do\n\u00a0\u00a0\u00a0\u00a0\u00a0 puts \"\\nbailing\"\n\u00a0\u00a0\u00a0\u00a0\u00a0 sClose socket\n\u00a0\u00a0\u00a0\u00a0\u00a0 exitSuccess\n\n\u00a0\u00a0\u00a0 puts = putStrLn\n\n\u00a0 (-) = ($)\n\u00a0 infixr 0 -\n\n<\/pre>\n<p>\u5982\u679c\u4f60\u77e5\u9053\u66f4\u591a\u7684\uff0c\u8bf7\u4f60\u544a\u8bc9\u6211\u4eec\u3002\uff08\u5168\u6587\u5b8c\uff09<\/p>\n","raw":"","protected":false},"excerpt":{"rendered":"<p>\u4e00\u8bf4\u8d77Unix\u7f16\u7a0b\uff0c\u4e0d\u5fc5\u591a\u8bf4\uff0c\u6700\u8457\u540d\u7684\u7cfb\u7edf\u8c03\u7528\u5c31\u662ffork\uff0cpipe\uff0cexec\uff0ckill\u6216\u662fsocket\u4e86\uff08fork(2), execve(2), pipe(2&#8230;<\/p>\n<p class=\"read-more\"><a class=\"btn btn-default\" href=\"https:\/\/coolshell.cn\/articles\/1532.html\"> Read More<span class=\"screen-reader-text\">  Read More<\/span><\/a><\/p>\n","protected":false},"author":2,"featured_media":0,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":[],"categories":[20],"tags":[59,26,212,210,35,791,69,211,21],"series":[],"aioseo_notices":[],"views":26290,"post_thumbnail_image":"","content_first_image":"","post_medium_image_300":"","post_thumbnail_image_624":"","post_frist_image":"","post_medium_image":"","post_large_image":"","post_full_image":"","post_all_images":[],"videoAdId":"","listAd":"0","listAdId":"","listAdEvery":5,"total_comments":19,"category_name":"Unix\/Linux","post_date":"2009-10-11","like_count":"0","praiseWord":"\u9f13\u52b1","excitationAd":"0","rewardedVideoAdId":"","detailAdId":"","detailAd":"0","enterpriseMinapp":"0","audios":[],"postImageUrl":"http:\/\/coolshell.cn\/wp-content\/uploads\/2016\/09\/coolshell-360x200.jpg","avatarurls":[],"related_posts":[],"pageviews":26291,"pageviews_wl":9610,"ratings_average":3,"ratings_total":40,"ratings_users":12,"next_post_id":1574,"next_post_title":"bash \u51fd\u6570\u7ea7\u91cd\u5b9a\u5411","previous_post_id":1462,"previous_post_title":"CentOS\u4e0aphp\u7684\u95ee\u9898\u53caSelinux\u5b89\u5168\u8bbe\u7f6e"}