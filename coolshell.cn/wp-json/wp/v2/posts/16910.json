{"id":16910,"date":"2014-12-31T09:59:33","date_gmt":"2014-12-31T01:59:33","guid":{"rendered":"http:\/\/coolshell.cn\/?p=16910"},"modified":"2014-12-31T09:59:33","modified_gmt":"2014-12-31T01:59:33","slug":"linus%ef%bc%9a%e4%b8%ba%e4%bd%95%e5%af%b9%e8%b1%a1%e5%bc%95%e7%94%a8%e8%ae%a1%e6%95%b0%e5%bf%85%e9%a1%bb%e6%98%af%e5%8e%9f%e5%ad%90%e7%9a%84","status":"publish","type":"post","link":"https:\/\/coolshell.cn\/articles\/16910.html","title":{"rendered":"Linus\uff1a\u4e3a\u4f55\u5bf9\u8c61\u5f15\u7528\u8ba1\u6570\u5fc5\u987b\u662f\u539f\u5b50\u7684"},"content":{"rendered":"<p><strong>\uff08\u611f\u8c22\u7f51\u53cb\u00a0<\/strong><a href=\"http:\/\/weibo.com\/fullofbull\" target=\"_blank\"><strong>@\u6211\u7684\u4e0a\u94fa\u53eb\u8def\u9065<\/strong><\/a><strong>\u00a0\u6295\u7a3f\uff09<\/strong><\/p>\n<p>Linus\u5927\u795e\u53c8\u5728rant\u4e86\uff01\u8fd9\u6b21\u7684\u5410\u69fd\u5bf9\u8c61\u662f\u65f6\u4e0b\u5f88\u706b\u70ed\u7684<strong>\u5e76\u884c\u6280\u672f(parellism)<\/strong>\uff0c\u5e76\u76f4\u622a\u4e86\u5f53\u5730\u8868\u793a<a title=\"\u5e76\u884c\u8ba1\u7b97\u57fa\u672c\u4e0a\u5c31\u662f\u6d6a\u8d39\u5927\u5bb6\u7684\u65f6\u95f4\" href=\"http:\/\/www.vaikan.com\/linus-parallel-computing-is-a-huge-waste-of-everybodys-time\/\" target=\"_blank\">\u5e76\u884c\u8ba1\u7b97\u662f\u6d6a\u8d39\u6240\u6709\u4eba\u65f6\u95f4<\/a>(<a href=\"http:\/\/www.realworldtech.com\/forum\/?threadid=146066&amp;curpostid=146227\">&#8220;The whole &#8220;let&#8217;s parallelize&#8221; thing is a huge waste of everybody&#8217;s time.&#8221;<\/a>)\u3002\u5927\u81f4\u610f\u601d\u662f\u8bf4<strong>\u4e71\u5e8f\u6027\u80fd\u5feb\u3001\u63d0\u9ad8\u7f13\u5b58\u5bb9\u91cf\u3001\u964d\u529f\u8017<\/strong>\u3002\u5f53\u7136\u7b14\u8005\u4e0d\u6253\u7b97\u6b63\u9762\u8ba8\u8bba\u5e76\u884c\u7684\u662f\u662f\u975e\u975e\uff08\u8fc7\u4e8e\u5b8f\u4f1f\u7684\u4e3b\u9898\uff09\uff0c\u56e0\u4e3aLinus\u5728\u53e6\u4e00\u5219<a title=\"reference counting\" href=\"http:\/\/www.realworldtech.com\/forum\/?threadid=146066&amp;curpostid=146183\" target=\"_blank\">\u5e16\u5b50<\/a>\u4e2d\u4e3e\u4e86\u5bf9\u8c61<strong>\u5f15\u7528\u8ba1\u6570(reference counting)<\/strong>\u7684\u4f8b\u5b50\u6765\u8bf4\u660e\u5e76\u884c\u7684\u590d\u6742\u6027\u3002<\/p>\n<p>\u5728Linus\u56de\u590d\u4e4b\u524d\u6709\u4eba\u6307\u51fa<strong>\u5bf9\u8c61\u9700\u8981\u9501\u673a\u5236\u7684\u60c5\u51b5\u4e0b\uff0c\u5f15\u7528\u8ba1\u6570\u7684\u539f\u5b50\u6027\u95ee\u9898\uff1a<\/strong><\/p>\n<blockquote><p>Since it is being accessed in a multi-threaded way, via multiple access paths, generally it needs its own mutex &#8212; otherwise, reference counting would not be required to be atomic and a lock of a higher-level object would suffice.<\/p>\n<p>\u7531\u4e8e\uff08\u5bf9\u8c61\uff09\u901a\u8fc7\u591a\u7ebf\u7a0b\u65b9\u5f0f\u53ca\u591a\u79cd\u83b7\u53d6\u6e20\u9053\uff0c\u4e00\u822c\u800c\u8a00\u5b83\u9700\u8981\u81ea\u8eab\u7ef4\u62a4\u4e00\u4e2a\u4e92\u65a5\u9501\u2014\u2014\u5426\u5219\u5f15\u7528\u8ba1\u6570\u5c31\u4e0d\u8981\u6c42\u662f\u539f\u5b50\u7684\uff0c\u4e00\u4e2a\u66f4\u9ad8\u5c42\u6b21\u7684\u5bf9\u8c61\u9501\u8db3\u77e3\u3002<\/p><\/blockquote>\n<p>\u800cLinus\u4e0d\u90a3\u4e48\u8ba4\u4e3a\uff1a<\/p>\n<blockquote><p>The problem with reference counts is that you often need to take them *before* you take the lock that protects the object data.<\/p>\n<p>\u5f15\u7528\u8ba1\u6570\u7684\u95ee\u9898\u5728\u4e8e\u4f60\u7ecf\u5e38\u9700\u8981\u5728\u5bf9\u8c61\u6570\u636e<strong>\u4e0a\u9501\u4fdd\u62a4\u4e4b\u524d<\/strong>\u5b8c\u6210\u5b83\u3002<\/p><\/blockquote>\n<p>The thing is, you have two different cases:<\/p>\n<p>\u95ee\u9898\u6709\u4e24\u79cd\u60c5\u51b5\uff1a<\/p>\n<p style=\"padding-left: 30px;\"><strong>&#8211; object *reference* \u5bf9\u8c61\u5f15\u7528<\/strong><\/p>\n<p style=\"padding-left: 30px;\"><strong>&#8211; object data \u5bf9\u8c61\u6570\u636e<\/strong><\/p>\n<p>and they have completely different locking.<\/p>\n<p><strong>\u5b83\u4eec\u9501\u673a\u5236\u662f\u5b8c\u5168\u4e0d\u4e00\u6837\u7684\u3002<\/strong><\/p>\n<p><!--more--><\/p>\n<p>Object data locking is generally per-object. Well, unless you don&#8217;t have huge scalability issues, in which case you may have some external bigger lock (extreme case: one single global lock).<\/p>\n<p>\u5bf9\u8c61\u6570\u636e\u4fdd\u62a4\u4e00\u822c\u662f\u4e00\u4e2a\u5bf9\u8c61\u62e5\u6709\u4e00\u4e2a\u9501\uff0c\u5047\u8bbe\u4f60\u6ca1\u6709\u6d77\u91cf\u6269\u5c55\u6027\u95ee\u9898\uff0c\u4e0d\u7136\u4f60\u9700\u8981\u4e00\u4e9b\u5916\u90e8\u5927\u4e00\u70b9\u7684\u9501\uff08\u6781\u7aef\u7684\u4f8b\u5b50\uff0c\u4e00\u4e2a\u5bf9\u8c61\u4e00\u4e2a\u5168\u5c40\u9501\uff09\u3002<\/p>\n<p>But object *referencing* is mostly about finding the object (and removing\/freeing it). Is it on a hash chain? Is it in a tree? Linked list? When the reference count goes down to zero, it&#8217;s not the object data that you need to protect (the object is not used by anything else, so there&#8217;s nothing to protect!), it&#8217;s the ways to find the object you need to protect.<\/p>\n<p>\u4f46\u5bf9\u8c61\u5f15\u7528\u4e3b\u8981\u5173\u4e8e\u5bf9\u8c61\u7684\u5bfb\u627e\uff08\u79fb\u9664\u6216\u91ca\u653e\uff09\uff0c\u5b83\u662f\u5426\u5728\u54c8\u5e0c\u94fe\uff0c\u4e00\u68f5\u6811\u6216\u8005\u94fe\u8868\u4e0a\u3002<strong>\u5f53\u5bf9\u8c61\u5f15\u7528\u8ba1\u6570\u964d\u4e3a\u96f6\uff0c\u4f60\u8981\u4fdd\u62a4\u7684\u4e0d\u662f\u5bf9\u8c61\u6570\u636e\uff0c\u56e0\u4e3a\u5bf9\u8c61\u6ca1\u6709\u5728\u5176\u5b83\u5730\u65b9\u4f7f\u7528\uff0c\u4f60\u8981\u4fdd\u62a4\u7684\u662f\u5bf9\u8c61\u7684\u5bfb\u627e\u64cd\u4f5c\u3002<\/strong><\/p>\n<p>And the lock for the lookup operation cannot be in the object, because &#8211; by definition &#8211; you don&#8217;t know what the object is! You&#8217;re trying to look it up, after all.<\/p>\n<p>\u800c\u4e14\u67e5\u8be2\u64cd\u4f5c\u7684\u9501\u4e0d\u53ef\u80fd\u5728\u5bf9\u8c61\u5185\u90e8\uff0c\u56e0\u4e3a\u6839\u636e\u5b9a\u4e49\uff0c\u4f60\u8fd8\u4e0d\u77e5\u9053\u8fd9\u662f\u4ec0\u4e48\u5bf9\u8c61\uff0c\u4f60\u5728\u5c1d\u8bd5\u5bfb\u627e\u5b83\u3002<\/p>\n<p>So generally you have a lock that protects the lookup operation some way, and the reference count needs to be atomic with respect to that lock.<\/p>\n<p>\u56e0\u6b64\u4e00\u822c\u4f60\u8981\u5bf9\u67e5\u8be2\u64cd\u4f5c\u4e0a\u9501\uff0c\u800c\u4e14\u5f15\u7528\u8ba1\u6570\u76f8\u5bf9<strong>\u90a3\u4e2a\u9501<\/strong>\u6765\u8bf4\u662f\u539f\u5b50\u7684\uff08\u8bd1\u8005\u6ce8\uff1a\u67e5\u8be2\u9501\u4e0d\u662f\u5f15\u7528\u8ba1\u6570\u6240\u5728\u7684\u5bf9\u8c61\u6240\u6709\uff0c\u4e0d\u80fd\u4fdd\u62a4\u5bf9\u8c61\u5f15\u7528\u8ba1\u6570\uff0c\u540e\u9762\u4f1a\u89e3\u91ca\u4e3a\u4f55\u5f15\u7528\u8ba1\u6570\u53d8\u66f4\u65f6\u5176\u6240\u5728\u5bf9\u8c61\u4e0d\u80fd\u4e0a\u9501\uff09\u3002<\/p>\n<p>And yes, that lock may well be sufficient, and now you&#8217;re back to non-atomic reference counts. But you usually don&#8217;t have just one way to look things up: you might have pointers from other objects (and that pointer is protected by the object locking of the other object), but there may be multiple such objects that point to this (which is why you have a reference count in the first place!)<\/p>\n<p>\u5f53\u7136\u8fd9\u4e2a\u9501\u662f\u5145\u5206\u6709\u6548\u7684\uff0c\u73b0\u5728\u5047\u8bbe\u5f15\u7528\u8ba1\u6570\u662f\u975e\u539f\u5b50\u7684\uff0c\u4f46\u4f60\u5e38\u5e38\u4e0d\u4ec5\u4ec5\u4f7f\u7528\u4e00\u79cd\u65b9\u5f0f\u6765\u67e5\u8be2\uff1a\u4f60\u53ef\u80fd\u62e5\u6709\u5176\u5b83\u5bf9\u8c61\u7684\u6307\u9488\uff08\u8fd9\u4e2a\u6307\u9488\u53c8\u88ab\u5176\u5b83\u5bf9\u8c61\u7684\u5bf9\u8c61\u9501\u7ed9\u4fdd\u62a4\u8d77\u6765\uff09\uff0c\u4f46\u540c\u65f6\u8fd8\u4f1a\u6709\u591a\u4e2a\u5bf9\u8c61\u6307\u5411\u5b83\uff08\u8fd9\u5c31\u662f\u4e3a\u4f55\u4f60\u7b2c\u4e00\u65f6\u95f4\u9700\u8981\u5f15\u7528\u8ba1\u6570\u7684\u7406\u7531\uff09\u3002<\/p>\n<p>See what happens? There is no longer one single lock for lookup. Imagine walking a graph of objects, where objects have pointers to each other. Each pointer implies a reference to an object, but as you walk the graph, you have to release the lock from the source object, so you have to take a new reference to the object you are now entering.<\/p>\n<p>\u770b\u770b\u4f1a\u53d1\u751f\u4ec0\u4e48\uff1f\u67e5\u8be2\u4e0d\u6b62\u5b58\u5728\u4e00\u4e2a\u9501\u4fdd\u62a4\u3002\u4f60\u53ef\u4ee5\u60f3\u8c61\u8d70\u8fc7\u4e00\u5f20\u5bf9\u8c61\u6d41\u7a0b\u56fe\uff0c\u5176\u4e2d\u5bf9\u8c61\u5b58\u5728\u6307\u5411\u5176\u5b83\u5bf9\u8c61\u7684\u6307\u9488\uff0c\u6bcf\u4e2a\u6307\u9488\u6697\u542b\u4e86\u4e00\u6b21\u5bf9\u8c61\u5f15\u7528\uff0c\u4f46\u5f53\u4f60\u8d70\u8fc7\u8fd9\u4e2a\u6d41\u7a0b\u56fe\uff0c\u4f60\u5fc5\u987b\u91ca\u653e\u6e90\u5bf9\u8c61\u7684\u9501\uff0c\u800c\u4f60\u8fdb\u5165\u65b0\u5bf9\u8c61\u65f6\u53c8\u5fc5\u987b\u589e\u52a0\u4e00\u6b21\u5f15\u7528\u3002<\/p>\n<p>And in order to avoid deadlocks, you can not in the general case take the lock of the new object first &#8211; you have to release the lock on the source object, because otherwise (in a complex graph), how do you avoid simple ABBA deadlock?<\/p>\n<p>\u800c\u4e14\u4e3a\u4e86\u907f\u514d\u6b7b\u9501\uff0c\u4f60\u4e00\u822c\u4e0d\u80fd\u7acb\u5373\u5bf9\u65b0\u5bf9\u8c61\u4e0a\u9501\u2014\u2014\u4f60\u5fc5\u987b\u91ca\u653e\u6e90\u5bf9\u8c61\u7684\u9501\uff0c\u5426\u5219\u5728\u4e00\u4e2a\u590d\u6742\u6d41\u7a0b\u56fe\u91cc\uff0c\u4f60\u5982\u4f55\u907f\u514d<strong>ABBA\u6b7b\u9501<\/strong>\uff08\u8bd1\u8005\u6ce8\uff1a\u5047\u8bbe\u4e24\u4e2a\u7ebf\u7a0b\uff0c\u4e00\u4e2a\u662fA-&gt;B\uff0c\u53e6\u4e00\u4e2aB-&gt;;A\uff0c\u5f53\u7ebf\u7a0b\u4e00\u7ed9A\u4e0a\u9501\uff0c\u7ebf\u7a0b\u4e8c\u7ed9B\u4e0a\u9501\uff0c\u6b64\u65f6\u4e24\u8005\u8c01\u4e5f\u65e0\u6cd5\u91ca\u653e\u5bf9\u65b9\u7684\u9501\uff09\uff1f<\/p>\n<p>So atomic reference counts fix that. They work because when you move from object A to object B, you can do this:<\/p>\n<p>\u539f\u5b50\u5f15\u7528\u8ba1\u6570\u4fee\u6b63\u4e86\u8fd9\u4e00\u70b9\uff0c\u5f53\u4f60\u4ece\u5bf9\u8c61A\u5230\u5bf9\u8c61B\uff0c\u4f60\u4f1a\u8fd9\u6837\u505a\uff1a<\/p>\n<p>(a) you have a reference count to A, and you can lock A<\/p>\n<p style=\"padding-left: 30px;\">\u5bf9\u8c61A\u589e\u52a0\u4e00\u6b21\u5f15\u7528\u8ba1\u6570\uff0c\u5e76\u4e0a\u9501\u3002<\/p>\n<p>(b) once object A is locked, the pointer from A to B is stable, and you know you have a reference to B (because of that pointer from A to B)<\/p>\n<p style=\"padding-left: 30px;\">\u5bf9\u8c61A\u4e00\u65e6\u4e0a\u9501\uff0cA\u6307\u5411B\u7684\u6307\u9488\u5c31\u662f\u7a33\u5b9a\u7684\uff0c\u4e8e\u662f\u4f60\u77e5\u9053\u4f60\u5f15\u7528\u4e86\u5bf9\u8c61B\u3002<\/p>\n<p>(c) but you cannot take the object lock for B (ABBA deadlock) while holding the lock on A<\/p>\n<p style=\"padding-left: 30px;\">\u4f46\u4f60\u4e0d\u80fd\u5728\u5bf9\u8c61A\u4e0a\u9501\u671f\u95f4\u7ed9B\u4e0a\u9501\uff08ABBA\u6b7b\u9501\uff09\u3002<\/p>\n<p>(d) increment the atomic reference count on B<\/p>\n<p style=\"padding-left: 30px;\">\u5bf9\u8c61B\u589e\u52a0\u4e00\u6b21\u539f\u5b50\u5f15\u7528\u8ba1\u6570\u3002<\/p>\n<p>(e) now you can drop the lock on A (you&#8217;re &#8220;exiting&#8221; A)<\/p>\n<p style=\"padding-left: 30px;\">\u73b0\u5728\u4f60\u53ef\u4ee5\u6254\u6389\u5bf9\u8c61A\u7684\u9501\uff08\u9000\u51fa\u5bf9\u8c61A\uff09\u3002<\/p>\n<p>(f) your reference count means that B cannot go away from under you despite unlocking A, so now you can lock B.<\/p>\n<p style=\"padding-left: 30px;\">\u5bf9\u8c61B\u7684\u539f\u5b50\u5f15\u7528\u8ba1\u6570\u610f\u5473\u7740\u5373\u4f7f\u7ed9A\u89e3\u9501\u671f\u95f4\uff0cB\u4e5f\u4e0d\u4f1a\u5931\u8054\uff0c\u73b0\u5728\u4f60\u53ef\u4ee5\u7ed9B\u4e0a\u9501\u3002<\/p>\n<p>See? Atomic reference counts make this kind of situation possible. Yes, you want to avoid the overhead if at all possible (for example, maybe you have a strict ordering of objects, so you know you can walk from A to B, and never walk from B to A, so there is no ABBA deadlock, and you can just lock B while still holding the lock on A).<\/p>\n<p>\u770b\u89c1\u4e86\u5417\uff1f\u539f\u5b50\u5f15\u7528\u8ba1\u6570\u4f7f\u8fd9\u79cd\u60c5\u51b5\u6210\u4e3a\u53ef\u80fd\u3002\u662f\u7684\uff0c\u4f60\u60f3\u5c3d\u4e00\u5207\u529e\u6cd5\u907f\u514d\u8fd9\u79cd\u4ee3\u4ef7\uff0c\u6bd4\u5982\uff0c\u4f60\u4e5f\u8bb8\u628a\u5bf9\u8c61\u5199\u6210\u4e25\u683c\u987a\u5e8f\u7684\uff0c\u8fd9\u6837\u4f60\u53ef\u4ee5\u4eceA\u5230B\uff0c\u7edd\u4e0d\u4f1a\u4eceB\u5230A\uff0c\u5982\u6b64\u5c31\u4e0d\u5b58\u5728ABBA\u6b7b\u9501\u4e86\uff0c\u4f60\u4e5f\u5c31\u53ef\u4ee5\u5728A\u4e0a\u9501\u671f\u95f4\u7ed9B\u4e0a\u9501\u4e86\u3002<\/p>\n<p>But if you don&#8217;t have some kind of forced ordering, and if you have multiple ways to reach an object (and again &#8211; why have reference counts in the first place if that isn&#8217;t true!) then atomic reference counts really are the simple and sane answer.<\/p>\n<p>\u4f46\u5982\u679c\u4f60\u65e0\u6cd5\u505a\u5230\u8fd9\u79cd\u5f3a\u8feb\u5e8f\u5217\uff0c\u5982\u679c\u4f60\u6709\u591a\u79cd\u65b9\u5f0f\u63a5\u89e6\u4e00\u4e2a\u5bf9\u8c61\uff08\u518d\u4e00\u6b21\u5f3a\u8c03\uff0c\u8fd9\u662f\u7b2c\u4e00\u65f6\u95f4\u4f7f\u7528\u5f15\u7528\u8ba1\u6570\u7684\u7406\u7531\uff09\uff0c\u8fd9\u6837\uff0c\u539f\u5b50\u5f15\u7528\u8ba1\u6570\u5c31\u662f\u7b80\u5355\u53c8\u7406\u667a\u7684\u7b54\u6848\u3002<\/p>\n<p>If you think atomic refcounts are unnecessary, that&#8217;s a big flag that you don&#8217;t actually understand the complexities of locking.<\/p>\n<p><strong>\u5982\u679c\u4f60\u8ba4\u4e3a\u539f\u5b50\u5f15\u7528\u8ba1\u6570\u662f\u4e0d\u5fc5\u8981\u7684\uff0c\u8fd9\u5c31\u5927\u5927\u8bf4\u660e\u4f60\u5b9e\u9645\u4e0a\u4e0d\u4e86\u89e3\u9501\u673a\u5236\u7684\u590d\u6742\u6027\u3002<\/strong><\/p>\n<p>Trust me, concurrency is hard. There&#8217;s a reason all the examples of &#8220;look how easy it is to parallelize things&#8221; tend to use simple arrays and don&#8217;t ever have allocations or freeing of the objects.<\/p>\n<p>\u76f8\u4fe1\u6211\uff0c<strong>\u5e76\u53d1\u8bbe\u8ba1\u662f\u56f0\u96be\u7684\u3002<\/strong>\u6240\u6709\u5173\u4e8e\u201c\u5e76\u884c\u5316\u5982\u6b64\u5bb9\u6613\u201d\u7684\u7406\u7531\u90fd\u503e\u5411\u4e8e\u4f7f\u7528\u7b80\u5355\u6570\u7ec4\u64cd\u4f5c\u505a\u4f8b\u5b50\uff0c\u751a\u81f3\u4e0d\u5305\u542b\u5bf9\u8c61\u7684\u5206\u914d\u548c\u91ca\u653e\u3002<\/p>\n<p>People who think that the future is highly parallel are invariably completely unaware of just how hard concurrency really is. They&#8217;ve seen Linpack, they&#8217;ve seen all those wonderful examples of sorting an array in parallel, they&#8217;ve seen all these things that have absolutely no actual real complexity &#8211; and often very limited real usefulness.<\/p>\n<p>\u90a3\u4e9b\u8ba4\u4e3a\u672a\u6765\u662f\u9ad8\u5ea6\u5e76\u884c\u5316\u7684\u4eba\u4e00\u6210\u4e0d\u53d8\u5730\u5b8c\u5168\u6ca1\u6709\u610f\u8bc6\u5230\u5e76\u53d1\u8bbe\u8ba1\u662f\u591a\u4e48\u56f0\u96be\u3002\u4ed6\u4eec\u53ea\u89c1\u8fc7<a title=\"Linpack\" href=\"http:\/\/en.wikipedia.org\/wiki\/LINPACK\" target=\"_blank\">Linpack<\/a>\uff0c\u4ed6\u4eec\u53ea\u89c1\u8fc7\u5e76\u884c\u6280\u672f\u4e2d\u5173\u4e8e\u6570\u7ec4\u6392\u5e8f\u7684\u4e00\u5207\u7cbe\u5999\u4f8b\u5b50\uff0c\u4ed6\u4eec\u53ea\u89c1\u8fc7\u4e00\u5207\u7edd\u4e0d\u7b97\u771f\u6b63\u590d\u6742\u7684\u4e8b\u7269\u2014\u2014\u5bf9\u771f\u6b63\u7684\u7528\u5904\u7ecf\u5e38\u662f\u975e\u5e38\u6709\u9650\u7684\u3002<\/p>\n<p>\uff08\u8bd1\u8005\u6ce8\uff1a\u5f53\u7136\uff0c\u6211\u65e0\u610f\u501f\u5927\u795e\u4e4b\u53e3\u628a\u6280\u672f\u5b97\u6559\u5316\u3002\u5b9e\u9645\u4e0aLinus\u53c8\u5728\u53e6\u4e00\u7bc7<a title=\"\u8bc4\u4ef7\" href=\"http:\/\/www.realworldtech.com\/forum\/?threadid=146066&amp;curpostid=146198\" target=\"_blank\">\u5e16\u5b50<\/a>\u4e2d\u7efc\u5408\u4e86\u5bf9\u5e76\u884c\u7684\u8bc4\u4ef7\u3002\uff09<\/p>\n<p>Oh, I agree. My example was the simple case. The really complex cases are much worse.<\/p>\n<p>\u54e6\uff0c\u6211\u540c\u610f\u3002\u6211\u7684\u4f8b\u5b50\u8fd8\u7b97\u7b80\u5355\uff0c\u771f\u6b63\u590d\u6742\u7684\u7528\u4f8b\u66f4\u7cdf\u7cd5\u3002<\/p>\n<p>I seriously don&#8217;t believe that the future is parallel. People who think you can solve it with compilers or programming languages (or better programmers) are so far out to lunch that it&#8217;s not even funny.<\/p>\n<p>\u6211\u4e25\u91cd\u4e0d\u76f8\u4fe1\u672a\u6765\u662f\u5e76\u884c\u7684\u3002\u6709\u4eba\u8ba4\u4e3a\u4f60\u53ef\u4ee5\u901a\u8fc7\u7f16\u8bd1\u5668\uff0c\u7f16\u7a0b\u8bed\u8a00\u6216\u8005\u66f4\u597d\u7684\u7a0b\u5e8f\u5458\u6765\u89e3\u51b3\u95ee\u9898\uff0c\u4ed6\u4eec\u76ee\u524d\u90fd\u662f\u795e\u5fd7\u4e0d\u6e05\uff0c\u6ca1\u610f\u8bc6\u5230\u8fd9\u4e00\u70b9\u90fd\u4e0d\u6709\u8da3\u3002<\/p>\n<p>Parallelism works well in simplified cases with fairly clear interfaces and models. You find parallelism in servers with independent queries, in HPC, in kernels, in databases. And even there, people work really hard to make it work at all, and tend to expressly limit their models to be more amenable to it (eg databases do some things much better than others, so DB admins make sure that they lay out their data in order to cater to the limitations).<\/p>\n<p>\u5e76\u884c\u8ba1\u7b97\u53ef\u4ee5\u5728\u7b80\u5316\u7684\u7528\u4f8b\u4ee5\u53ca\u5177\u5907\u6e05\u6670\u7684\u63a5\u53e3\u548c\u6a21\u578b\u4e0a\u6b63\u5e38\u5de5\u4f5c\u3002\u4f60\u53d1\u73b0\u5e76\u884c\u5728\u670d\u52a1\u5668\u4e0a\u72ec\u7acb\u67e5\u8be2\u91cc\uff0c\u5728\u9ad8\u6027\u80fd\u8ba1\u7b97(High-performance computing)\u91cc\uff0c\u5728\u5185\u6838\u91cc\uff0c\u5728\u6570\u636e\u5e93\u91cc\u3002\u5373\u4f7f\u5982\u6b64\uff0c\u4eba\u4eec\u8fd8\u5f97\u82b1\u5f88\u5927\u529b\u6c14\u624d\u80fd\u4f7f\u5b83\u5de5\u4f5c\uff0c\u5e76\u4e14\u8fd8\u8981\u660e\u786e\u9650\u5236\u4ed6\u4eec\u7684\u6a21\u578b\u6765\u5c3d\u66f4\u591a\u4e49\u52a1\uff08\u4f8b\u5982\u6570\u636e\u5e93\u8981\u60f3\u505a\u5f97\u66f4\u597d\uff0c\u6570\u636e\u5e93\u7ba1\u7406\u5458\u5f97\u786e\u4fdd\u6570\u636e\u5f97\u5230\u5408\u7406\u5b89\u6392\u6765\u8fce\u5408\u5c40\u9650\u6027\uff09\u3002<\/p>\n<p>Of course, other programming models can work. Neural networks are inherently very parallel indeed. And you don&#8217;t need smarter programmers to program them either..<\/p>\n<p>\u5f53\u7136\uff0c\u5176\u5b83\u7f16\u7a0b\u6a21\u578b\u5012\u80fd\u6d3e\u4e0a\u7528\u573a\uff0c\u795e\u7ecf\u7f51\u7edc(neural networking)\u5929\u751f\u5c31\u662f\u975e\u5e38\u5e76\u884c\u5316\u7684\uff0c\u4f60\u4e0d\u9700\u8981\u66f4\u806a\u660e\u7684\u7a0b\u5e8f\u5458\u4e3a\u4e4b\u5199\u4ee3\u7801\u3002<\/p>\n<h4>\u53c2\u8003\u8d44\u6599<\/h4>\n<ul>\n<li><a title=\"Real World Technologies\" href=\"http:\/\/www.realworldtech.com\/\" target=\"_blank\">Real World Technologies<\/a>\uff1aLinus\u5e38\u53bb\u201c\u704c\u6c34\u201d\u7684\u4e00\u4e2a\u8bba\u575b\uff0c\u8ba8\u8bba\u672a\u6765\u673a\u5668\u67b6\u6784\uff08\u770b\u540d\u5b57\u5c31\u77e5\u9053Linus\u6280\u672f\u504f\u597d\uff0c\u53ca\u5176\u4e4b\u524d\u5bf9\u865a\u62df\u5316\u6280\u672f(virtualization)\u7684<a title=\"virtualization is evil\" href=\"http:\/\/www.networkworld.com\/article\/2220440\/opensource-subnet\/torvalds-says---virtualization-is-evil-.html\" target=\"_blank\">\u5410\u69fd<\/a>\uff09<\/li>\n<li><a title=\"\u591a\u7ebf\u7a0b\u7a0b\u5e8f\u4e2d\u64cd\u4f5c\u7684\u539f\u5b50\u6027\" href=\"http:\/\/www.parallellabs.com\/2010\/04\/15\/atomic-operation-in-multithreaded-application\/\" target=\"_blank\">\u591a\u7ebf\u7a0b\u7a0b\u5e8f\u4e2d\u64cd\u4f5c\u7684\u539f\u5b50\u6027<\/a>\uff1a\u89e3\u91ca\u4e3a\u4ec0\u4e48i++\u4e0d\u662f\u539f\u5b50\u64cd\u4f5c<\/li>\n<li><a title=\"Concurrency Is Not Parallelism\" href=\"http:\/\/www.vaikan.com\/docs\/Concurrency-is-not-Parallelism\" target=\"_blank\">\u00a0Concurrency Is Not Parallelism<\/a>\uff1aGo\u8bed\u8a00\u4e4b\u7236Rob Pike\u5e7b\u706f\u7247\u89e3\u91ca\u201c\u5e76\u53d1\u201d\u4e0e\u201c\u5e76\u884c\u201d\u6982\u5ff5\u4e0a\u7684\u533a\u522b<\/li>\n<\/ul>\n<p>\uff08\u5168\u6587\u5b8c\uff09<\/p>\n","raw":"","protected":false},"excerpt":{"rendered":"<p>\uff08\u611f\u8c22\u7f51\u53cb\u00a0@\u6211\u7684\u4e0a\u94fa\u53eb\u8def\u9065\u00a0\u6295\u7a3f\uff09 Linus\u5927\u795e\u53c8\u5728rant\u4e86\uff01\u8fd9\u6b21\u7684\u5410\u69fd\u5bf9\u8c61\u662f\u65f6\u4e0b\u5f88\u706b\u70ed\u7684\u5e76\u884c\u6280\u672f(parellism)\uff0c\u5e76\u76f4\u622a\u4e86\u5f53\u5730\u8868\u793a\u5e76\u884c\u8ba1\u7b97\u662f\u6d6a\u8d39\u6240&#8230;<\/p>\n<p class=\"read-more\"><a class=\"btn btn-default\" href=\"https:\/\/coolshell.cn\/articles\/16910.html\"> Read More<span class=\"screen-reader-text\">  Read More<\/span><\/a><\/p>\n","protected":false},"author":15168,"featured_media":0,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":[],"categories":[23,3],"tags":[774,775,183,608,776],"series":[],"aioseo_notices":[],"views":50897,"post_thumbnail_image":"","content_first_image":"","post_medium_image_300":"","post_thumbnail_image_624":"","post_frist_image":"","post_medium_image":"","post_large_image":"","post_full_image":"","post_all_images":[],"videoAdId":"","listAd":"0","listAdId":"","listAdEvery":5,"total_comments":37,"category_name":"\u7a0b\u5e8f\u8bbe\u8ba1","post_date":"2014-12-31","like_count":"0","praiseWord":"\u9f13\u52b1","excitationAd":"0","rewardedVideoAdId":"","detailAdId":"","detailAd":"0","enterpriseMinapp":"0","audios":[],"postImageUrl":"http:\/\/coolshell.cn\/wp-content\/uploads\/2016\/09\/coolshell-360x200.jpg","avatarurls":[],"related_posts":[],"pageviews":50898,"pageviews_wl":48017,"ratings_average":3,"ratings_total":161,"ratings_users":42,"next_post_id":17066,"next_post_title":"\u5173\u4e8e\u79fb\u52a8\u7aef\u7684\u9493\u9c7c\u5f0f\u653b\u51fb","previous_post_id":12052,"previous_post_title":"Leetcode \u7f16\u7a0b\u8bad\u7ec3"}